/* Definicion del pasers con CUP para el analisis de la gramatica. */

/* Imports que se ocupan */
package parser;

import java_cup.runtime.*;
import lexer.*;
import java.io.*;
import lexer.Lexer;

/* Parsers */
parser code {:
    private int errorContador = 0;

    public int getErrorContador() {
        return errorContador;
    }

    public void syntax_error(Symbol cur_token) {
        errorContador++;
        String tokenInfo = obtenerInfoToken(cur_token);
        System.err.println("Error sintactico en linea " + cur_token.left + 
                          ", columna " + cur_token.right + ": " + tokenInfo);
    }
    // Mapeo de tokens a mensajes claros para debugueo
    private String obtenerInfoToken(Symbol token) {
        switch (token.sym) {
            case sym.IDENTIFICADOR:
                return "Se encontro identificador inesperado: '" + token.value + "'";
            case sym.INT_LITERAL:
                return "Se encontro numero entero inesperado: '" + token.value + "'";
            case sym.FLOAT_LITERAL:
                return "Se encontro numero flotante inesperado: '" + token.value + "'";
            case sym.STRING_LITERAL:
                return "Se encontro texto inesperado";
            case sym.CHAR_LITERAL:
                return "Se encontro caracter inesperado";
            case sym.ASIGNACION:
                return "Se encontro '=' inesperado";
            case sym.DELIMITADOR:
                return "Se encontro '$' inesperado";
            case sym.EOF:
                return "Final de archivo inesperado";
            default:
                return "Token inesperado: " + token.value;
        }
    }

    public void report_error(String message, Object info) {
    }

    public void unrecovered_syntax_error(Symbol cur_token) {
        System.err.println("Error sintactico irrecuperable en linea " + cur_token.left + 
                          ", columna " + cur_token.right + ": No se puede continuar el analisis");
    }

:};

/* Definición de terminales (tokens) */
// Son las palabras reservadas
terminal LET, GLOBAL, VOID, PRINCIPAL, DECIDE, OF, ELSE, END, LOOP, EXIT;
terminal  WHEN,  RETURN, BREAK, INPUT, FOR, STEP, TO, DOWNTO, DO, OUTPUT;
 

// Tipos de datos
terminal INT, FLOAT, BOOLEAN, CHAR, STRING;

// Literales de los tipos de datos, esta es la representacion en string.
terminal Integer INT_LITERAL;
terminal Double FLOAT_LITERAL;
terminal String STRING_LITERAL;
terminal Character CHAR_LITERAL;
terminal Boolean TRUE, FALSE;

// Identificadores.
terminal IDENTIFICADOR;

// Operadores aritmeticos
terminal MAS, MENOS, MULTIPLICACION, DIVISION, DIVISION_ENTERA, MODULO, POTENCIA;
terminal INCREMENTO, DECREMENTO;

// Operadores relacionales
terminal IGUAL, DIFERENTE, MENOR_IGUAL, MAYOR_IGUAL, MENOR, MAYOR;

// Operadores logicos
terminal AND, OR, NOT;

// Asignacion
terminal ASIGNACION;

// Delimitadores y separadores
terminal DELIMITADOR, COMA;
terminal PAREN_I, PAREN_D,CORCHETE_I, CORCHETE_D, LLAVE_I, LLAVE_D;

// La flecha para los if y el concatenador de los prints.
terminal FLECHA, CONCATENACION_OUTPUT;

// Terminar para la deficion de errores lexicos.
terminal ERROR;




/* -------------->>>> Seccion para los no terminales */

/* >> Estructura general*/
non terminal programa, principal, funciones, funcion, params, param;

/* >> Tipos de datos */
non terminal tipoDatoFuncion, tipoDatoVariable;

/* >> Sentencias y bloques */
non terminal bloque, sentencias, sentencia;

/* >> Declaraciones y variables */
non terminal var, varAsignacion, varCyAsignacion, varGlobal;

/* >> Expresiones  */

non terminal expresion;

/* > Numericas */
non terminal expresionNumerica, expresionSuma, expresionProducto, expresionPotencia, expresionFactor, expresionAritmeticaUnaria, expresionAritmeticaUnariaNegativa;

/* > Boolenas  */
non terminal expresionBooleana;

/* > Literales */
non terminal  expresionChar, expresionString;

/* > Expresiones compuestas */
non terminal expresionAritmetica, expresionLogica, expresionRelacional;

/* >> Control de flujo */
non terminal estructruraControl, decide, condicion, loop, for;

/* >> Funciones y sus llamadas  */
non terminal funcionLlamada, argumentos, return, break;

/* Aqui estoy poniendo los no terminales que estan faltando */
non terminal  tipoDatoInput, condiciones, listaFunciones;


/* >> Input y ouput */
non terminal input, output, output_inline;

/* >> Listas */
non terminal lista, declaracionLista, creacionYAsignacionLista, elementos, elementoLista, modificarElementoLista, obtenerElementoLista, tipoLista;



/* Precedencia de operadores (de menor a mayor precedencia) */

// Operadores binarios
precedence left OR;
precedence left AND;
precedence right NOT; 

/* Operadores booleanos y relacionales */
precedence left IGUAL, DIFERENTE;
precedence left MENOR, MAYOR, MENOR_IGUAL, MAYOR_IGUAL;

/* Operadores aritmeticos */
precedence left MAS, MENOS;
precedence left MULTIPLICACION, DIVISION, DIVISION_ENTERA, MODULO;
precedence right POTENCIA;

// Operadores unarios
precedence left INCREMENTO, DECREMENTO;
precedence right MENOS; /* Pasar a negativo: Revisar la gramatica original para una posible correccion. */


/* Precedencia para resolver conflictos */
precedence left COMA;
precedence right ASIGNACION;


/* expect 6; Esto es para decirle a cup qie espere hasta 6 congliuctos y que los acepte */

/* Esta es la que dice como se inicia todo. */
start with programa;



/* -------------------------  >> Definicion << -------------------------------------------------------------------  */


/* Producciones generales */
/* FIX: La estructura del principal está como opcional, debe de ser obligatorio y al final (por diseño) */
/* FIXED: Se arreglo la estructura para que siempre haya un bloque principal */
programa ::= varGlobal programa
           | funciones principal  
           | principal
           | error programa {: System.err.println("Error: Declaracion global o funcion no valida"); :};

principal ::= VOID PRINCIPAL PAREN_I PAREN_D bloque;

tipoDatoFuncion ::= INT
                  | FLOAT
                  | BOOLEAN;

tipoDatoVariable ::= INT
                   | FLOAT
                   | BOOLEAN
                   | CHAR
                   | STRING
                   | error {: System.err.println("Error: tipo de variable debe ser int, float, boolean, char o string"); :};

/*funciones ::= funcion
            | funciones funcion;*/

/* Esta modificacion es para intentar resolver el conflicto de funcion */
funciones ::= listaFunciones;

listaFunciones ::= funcion
                 | listaFunciones funcion;

funcion ::= tipoDatoFuncion IDENTIFICADOR PAREN_I params PAREN_D bloque
          | tipoDatoFuncion IDENTIFICADOR PAREN_I PAREN_D bloque
          | error IDENTIFICADOR PAREN_I params PAREN_D bloque {: System.err.println("Error: Tipo de dato de funcion no valido, debe ser int, float o boolean"); :}
          | error PAREN_I params PAREN_D bloque {: System.err.println("Error: Identificador de función no encontrado"); :}
          | error params PAREN_D bloque {: System.err.println("Error: Faltan parentesis de apertura є"); :}
          | error bloque {: System.err.println("Error: Faltan parentesis de cierre э"); :}
          | error IDENTIFICADOR PAREN_I PAREN_D bloque {: System.err.println("Error: Tipo de dato de funcion no valido, debe ser int, float o boolean"); :}
          | error PAREN_I PAREN_D bloque {: System.err.println("Error: Identificador no encontrado"); :}
          | error params PAREN_D bloque {: System.err.println("Error: Faltan parentesis de apertura є"); :};

params ::= param
         | params COMA param
         | error COMA param{: System.err.println("Error: No puede haber una (,) sola al inicio de los parametros."); :};

param ::= INT IDENTIFICADOR
        | FLOAT IDENTIFICADOR
        | BOOLEAN IDENTIFICADOR
        | CHAR IDENTIFICADOR
        | STRING IDENTIFICADOR
        | tipoLista IDENTIFICADOR
        | error IDENTIFICADOR {: System.err.println("Error: Para los parametros de una funcion se debe de indicar su tipo de dato."); :};

/* Producciones de sentencias y bloques */
bloque ::= LLAVE_I sentencias LLAVE_D
         | LLAVE_I LLAVE_D
         | error sentencias LLAVE_D {: System.err.println("Error: Los bloques deben de tener una llave de apertura (¿)."); :}
         | error LLAVE_D {: System.err.println("Error: Los bloques deben de tener una llave de apertura (¿). "); :}
         | LLAVE_I sentencias error {: System.err.println("Error: Los bloques deben de tener una llave de cierre (?). "); :};

sentencias ::= sentencia
             | sentencias sentencia;

sentencia ::= var
            | varAsignacion  
            | varCyAsignacion
            | lista
            | estructruraControl
            | funcionLlamada DELIMITADOR
            | return
            | break
            | input DELIMITADOR
            | output DELIMITADOR
            | output_inline DELIMITADOR
            | modificarElementoLista
            | expresionAritmeticaUnaria DELIMITADOR;

/* FIX: El identificador no debe de ser validado, se valida en producción identificador, sino encuentra busca terminal  */
/*FIXED: Eliminando la linea que valida nombre: | error PAREN_I argumentos PAREN_D  {: System.err.println("Error: Nombre de funcion no valido"); :}*/
funcionLlamada ::= IDENTIFICADOR PAREN_I argumentos PAREN_D
                 | IDENTIFICADOR PAREN_I PAREN_D
                 | IDENTIFICADOR error argumentos PAREN_D {: System.err.println("Error: Se esperaba parentesis de apertura 'є'"); :}
                 | IDENTIFICADOR PAREN_I argumentos error {: System.err.println("Error: Se esperaba parentesis de cierre 'э'"); :}
                 | IDENTIFICADOR PAREN_I error PAREN_D {: System.err.println("Error: Argumentos no validos en llamada a funcion"); :};

argumentos ::= expresion
             | argumentos COMA expresion
             | error COMA expresion  {: System.err.println("Error: Argumento no valido antes de ','"); :}
             | argumentos COMA error {: System.err.println("Error: Se esperaba expresion despues de ','"); :}
             | argumentos error expresion {: System.err.println("Error: Se esperaba ',' entre argumentos"); :};
             
return ::= RETURN DELIMITADOR
         | RETURN expresion DELIMITADOR
         | RETURN expresion error {: System.err.println("Error: Se esperaba un delimitador '$'"); :}
         | RETURN error {: System.err.println("Error: Se esperaba un delimitador '$'"); :};

break ::= BREAK DELIMITADOR;

/*FIX: Se debe hacer algo para que cuando el cup lea un IDENTIFICADOR -> PAREN_I detecte que es input, no una llamada a función*/
input ::= INPUT PAREN_I tipoDatoInput PAREN_D
        | INPUT PAREN_I error PAREN_D {: System.err.println("Error: Tipo de dato no valido para input, debe ser int o float."); :};

tipoDatoInput ::= INT
                | FLOAT;
            
output ::= output_inline
         | output CONCATENACION_OUTPUT output_inline         
         | output error output_inline {: System.err.println("Error: Se debe de definir el caracter de concatenacion (<<) para los outpout "); :};

output_inline ::= OUTPUT PAREN_I expresion PAREN_D
| error PAREN_I expresion PAREN_D {: System.err.println("Error: Se debe de definir la palabra de (input) para indicar una salida en consola."); :};

/* Estructuras de control */
estructruraControl ::= decide 
                     | loop 
                     | for;

decide ::= DECIDE OF condiciones END DECIDE DELIMITADOR
         | DECIDE OF condiciones ELSE bloque END DECIDE DELIMITADOR
         | DECIDE error condiciones END DECIDE DELIMITADOR {: System.err.println("Error: Se esperaba 'of' despues de 'decide'"); :}
         | DECIDE OF error END DECIDE DELIMITADOR {: System.err.println("Error: Condiciones no validas en estructura decide"); :}
         | DECIDE OF condiciones error DECIDE DELIMITADOR  {: System.err.println("Error: Se esperaba 'end' antes de 'decide'"); :}
         | DECIDE OF condiciones END error DELIMITADOR {: System.err.println("Error: Se esperaba 'decide' despues de 'end'"); :};

condiciones ::= condicion FLECHA bloque
              | condiciones condicion FLECHA bloque;

condicion ::= PAREN_I expresion PAREN_D
            | error expresion PAREN_D {: System.err.println("Error: Se esperaba parentesis de apertura 'є' en condicion"); :}
            | PAREN_I expresion error {: System.err.println("Error: Se esperaba parentesis de cierre 'э' en condicion"); :}
            | PAREN_I error PAREN_D {: System.err.println("Error: Expresion no valida en condicion"); :};


loop ::= LOOP bloque EXIT WHEN condicion DELIMITADOR END LOOP DELIMITADOR
       | LOOP bloque break EXIT WHEN condicion DELIMITADOR END LOOP DELIMITADOR
       | LOOP error EXIT WHEN condicion DELIMITADOR END LOOP DELIMITADOR {: System.err.println("Error: Bloque no valido en estructura loop"); :}
       | LOOP bloque error WHEN condicion DELIMITADOR END LOOP DELIMITADOR {: System.err.println("Error: Se esperaba 'exit' antes de 'when'"); :}
       | LOOP bloque EXIT error condicion DELIMITADOR END LOOP DELIMITADOR {: System.err.println("Error: Se esperaba 'when' despues de 'exit'"); :}
       | LOOP bloque EXIT WHEN condicion DELIMITADOR error LOOP DELIMITADOR {: System.err.println("Error: Se esperaba 'end' antes de 'loop'"); :};

for ::= FOR IDENTIFICADOR STEP INT_LITERAL TO expresion DO bloque DELIMITADOR
      | FOR IDENTIFICADOR STEP INT_LITERAL DOWNTO expresion DO bloque DELIMITADOR
      | FOR error STEP INT_LITERAL TO expresion DO bloque DELIMITADOR {: System.err.println("Error: Se esperaba identificador despues de 'for'"); :}
      | FOR IDENTIFICADOR error INT_LITERAL TO expresion DO bloque DELIMITADOR {: System.err.println("Error: Se esperaba 'step' despues del identificador"); :}
      | FOR IDENTIFICADOR STEP error TO expresion DO bloque DELIMITADOR {: System.err.println("Error: Se esperaba numero entero despues de 'step'"); :}
      | FOR IDENTIFICADOR STEP INT_LITERAL error expresion DO bloque DELIMITADOR {: System.err.println("Error: Se esperaba 'to' o 'downto' en bucle for"); :}
      | FOR IDENTIFICADOR STEP INT_LITERAL TO expresion error bloque DELIMITADOR {: System.err.println("Error: Se esperaba 'do' antes del bloque"); :};

/* Producciones de declaraciones y variables con DELIMITADOR (pendiente) */
var ::= LET tipoDatoVariable IDENTIFICADOR DELIMITADOR; /* | LET tipoDatoVariable IDENTIFICADOR ASIGNACION expresion DELIMITADOR    -- Se cambio esto por que era lo mismo */

varAsignacion ::= IDENTIFICADOR ASIGNACION expresion DELIMITADOR;
                 
varCyAsignacion ::= LET tipoDatoVariable IDENTIFICADOR ASIGNACION expresion DELIMITADOR
                  | LET tipoDatoVariable IDENTIFICADOR ASIGNACION error DELIMITADOR 
                    {: System.err.println("Error: Expresion no valida despues de '='"); :}
                  | LET tipoDatoVariable IDENTIFICADOR error 
                    {: System.err.println("Error: Se esperaba '=' despues del identificador"); :}
                  | LET tipoDatoVariable error ASIGNACION expresion DELIMITADOR
                    {: System.err.println("Error: Identificador no valido"); :}
                  | LET error IDENTIFICADOR ASIGNACION expresion DELIMITADOR
                    {: System.err.println("Error: Tipo de dato no valido"); :};

/* FIX: ERROR en global para que detecte 'global tipo identificador...' */
/* FIXED: Se agrega produ de error en falta de global */
varGlobal ::= GLOBAL tipoDatoVariable IDENTIFICADOR DELIMITADOR
            | error tipoDatoVariable IDENTIFICADOR DELIMITADOR
              {: System.err.println("Error: Se esperaba la palabra 'global' al inicio de la declaracion"); :}
            | GLOBAL tipoDatoVariable IDENTIFICADOR ASIGNACION expresion DELIMITADOR;

/* ##### Seccion para las expresiones ######*/
expresion ::= expresionAritmetica
            | expresionLogica
            | expresionChar
            | expresionString;


/* Modificar las derivacion para expresion logica con el fin de que pueda volver a arriba:  expresionLogica AND expresionLogica| expresionLogica OR expresionLogica*/
expresionLogica ::= expresionRelacional AND expresionLogica
                  | expresionRelacional OR expresionLogica
                  | NOT expresionLogica                  
                  | expresionRelacional
                  | expresionBooleana; 
                  

/* Los de expresionAritmetica no se pueden cambiar ya que los operadores de mayores y menore solo funcionan con estos. Asi */
expresionRelacional ::= expresionAritmetica IGUAL expresionAritmetica
                      | expresionAritmetica DIFERENTE expresionAritmetica
                      | expresionAritmetica MENOR expresionAritmetica
                      | expresionAritmetica MAYOR expresionAritmetica
                      | expresionAritmetica MENOR_IGUAL expresionAritmetica
                      | expresionAritmetica MAYOR_IGUAL expresionAritmetica

                      | expresionBooleana IGUAL expresionBooleana
                      | expresionBooleana DIFERENTE expresionBooleana
                      | expresionChar IGUAL expresionChar
                      | expresionChar DIFERENTE expresionChar
                      | expresionString
                      | PAREN_I expresion PAREN_D; /* Con esta en teoria deberia de volver a arriba. */

expresionChar ::= CHAR_LITERAL
                | obtenerElementoLista
                | funcionLlamada;

expresionString ::= STRING_LITERAL
                  | IDENTIFICADOR;

expresionBooleana ::= TRUE
                    | FALSE
                    | IDENTIFICADOR;


/* >> Expresiones aritmeticas */

expresionAritmetica ::= expresionSuma;


expresionSuma ::= expresionSuma MAS expresionProducto
                | expresionSuma MENOS expresionProducto
                | expresionProducto
                | expresionSuma MAS error
                  {: System.err.println("Error: Expresion no valida despues de '+'"); :}
                | expresionSuma MENOS error
                  {: System.err.println("Error: Expresion no valida despues de '-'"); :};

expresionProducto ::= expresionProducto MULTIPLICACION expresionPotencia
                    | expresionProducto DIVISION expresionPotencia
                    | expresionProducto DIVISION_ENTERA expresionPotencia
                    | expresionProducto MODULO expresionPotencia
                    | expresionPotencia;
          
expresionPotencia ::= expresionFactor POTENCIA expresionPotencia
                    | expresionFactor;


expresionFactor ::= PAREN_I expresionAritmetica PAREN_D
                  | expresionNumerica
                  | expresionAritmeticaUnaria
                  | expresionAritmeticaUnariaNegativa
                  | error
                    {: System.err.println("Error: Expresion aritmetica no valida"); :};

expresionNumerica ::= INT_LITERAL
                    | FLOAT_LITERAL  
                    | IDENTIFICADOR
                    | funcionLlamada
                    | obtenerElementoLista
                    | input
                    | INT_LITERAL IDENTIFICADOR error
                      {: System.err.println("Error: Numero seguido de identificador no es valido (ej: 2f5)"); :}
                    | FLOAT_LITERAL IDENTIFICADOR error
                      {: System.err.println("Error: Numero flotante seguido de identificador no es valido"); :};

expresionAritmeticaUnaria ::= IDENTIFICADOR INCREMENTO
                            | IDENTIFICADOR DECREMENTO;

expresionAritmeticaUnariaNegativa ::= MENOS expresionNumerica;


/* ##### Seccion parael manejo de listas ######*/
lista ::= declaracionLista
        | creacionYAsignacionLista;

declaracionLista ::= LET tipoLista IDENTIFICADOR DELIMITADOR;

creacionYAsignacionLista ::= LET tipoLista IDENTIFICADOR ASIGNACION LLAVE_I elementos LLAVE_D DELIMITADOR;

elementos ::= elementoLista
            | elementos COMA elementoLista;

elementoLista ::= INT_LITERAL
                | CHAR_LITERAL
                | IDENTIFICADOR; /* FIXED: El elemento en lista deberia poder permitir identificadores validos*/

/* FIX: El elemento en lista deberia poder permitir identificadores validos*/
modificarElementoLista ::= IDENTIFICADOR CORCHETE_I expresionAritmetica CORCHETE_D ASIGNACION elementoLista DELIMITADOR 
                         | error CORCHETE_I expresionAritmetica CORCHETE_D ASIGNACION elementoLista DELIMITADOR
                           {: System.err.println("Error: Nombre de lista no valido"); :};

obtenerElementoLista ::= IDENTIFICADOR CORCHETE_I expresionAritmetica CORCHETE_D
                      | error CORCHETE_I expresionAritmetica CORCHETE_D
                        {: System.err.println("Error: Nombre de lista no valido"); :};

tipoLista ::= INT CORCHETE_I CORCHETE_D
            | CHAR CORCHETE_I CORCHETE_D
            | INT CORCHETE_I INT_LITERAL CORCHETE_D
            | CHAR CORCHETE_I INT_LITERAL CORCHETE_D;

