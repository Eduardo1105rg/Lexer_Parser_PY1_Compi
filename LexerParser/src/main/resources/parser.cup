/* Definicion del pasers con CUP para el analisis de la gramatica. */

/* Imports que se ocupan */
package parser;

import java_cup.runtime.*;
import lexer.*;
import java.io.*;
import lexer.Lexer;

/* Parsers */
parser code {:
    private int errorContador = 0;

    public int getErrorContador() {
        return errorContador;
    }

    public void syntax_error(Symbol cur_token) {
        errorContador++;
        report_error("Error de sintaxis", cur_token);
    }

    public void report_error(String message, Object info) {
        StringBuilder error = new StringBuilder();
        
        if (info instanceof Symbol) {
            Symbol s = (Symbol) info;
            
            // Se agrega linea y columna si se pueden obtener
            if (s.left >= 0) {
                error.append("Línea ").append(s.left);
                if (s.right >= 0) {
                    error.append(", columna ").append(s.right);
                }
                error.append(": ");
            }
            
            error.append(message);
            
        } else {
            error.append(message);
        }
        
        System.err.println(error.toString());
    }

    public void unrecovered_syntax_error(Symbol cur_token) {
        report_error("Error sintáctico irrecuperable - continuando análisis", cur_token);
    }

:};

/* Definición de terminales (tokens) */
// Son las palabras reservadas
terminal LET, GLOBAL, VOID, PRINCIPAL, DECIDE, OF, ELSE, END, LOOP, EXIT;
terminal  WHEN,  RETURN, BREAK, INPUT, FOR, STEP, TO, DOWNTO, DO, OUTPUT;
 

// Tipos de datos
terminal INT, FLOAT, BOOLEAN, CHAR, STRING;

// Literales de los tipos de datos, esta es la representacion en string.
terminal Integer INT_LITERAL;
terminal Double FLOAT_LITERAL;
terminal String STRING_LITERAL;
terminal Character CHAR_LITERAL;
terminal Boolean TRUE, FALSE;

// Identificadores.
terminal IDENTIFICADOR;

// Operadores aritmeticos
terminal MAS, MENOS, MULTIPLICACION, DIVISION, DIVISION_ENTERA, MODULO, POTENCIA;
terminal INCREMENTO, DECREMENTO;

// Operadores relacionales
terminal IGUAL, DIFERENTE, MENOR_IGUAL, MAYOR_IGUAL, MENOR, MAYOR;

// Operadores logicos
terminal AND, OR, NOT;

// Asignacion
terminal ASIGNACION;

// Delimitadores y separadores
terminal DELIMITADOR, COMA;
terminal PAREN_I, PAREN_D,CORCHETE_I, CORCHETE_D, LLAVE_I, LLAVE_D;

// La flecha para los if y el concatenador de los prints.
terminal FLECHA, CONCATENACION_OUTPUT;

// Terminar para la deficion de errores lexicos.
terminal ERROR;




/* -------------->>>> Seccion para los no terminales */

/* >> Estructura general*/
non terminal programa, principal, funciones, funcion, params, param;

/* >> Tipos de datos */
non terminal tipoDatoFuncion, tipoDatoVariable;

/* >> Sentencias y bloques */
non terminal bloque, sentencias, sentencia;

/* >> Declaraciones y variables */
non terminal var, varAsignacion, varCyAsignacion, varGlobal;

/* >> Expresiones  */

non terminal expresion;

/* > Numericas */
non terminal expresionNumerica, expresionSuma, expresionProducto, expresionPotencia, expresionFactor, expresionAritmeticaUnaria, expresionAritmeticaUnariaNegativa;

/* > Boolenas  */
non terminal expresionBooleana;

/* > Literales */
non terminal  expresionChar, expresionString;

/* > Expresiones compuestas */
non terminal expresionAritmetica, expresionLogica, expresionRelacional;

/* >> Control de flujo */
non terminal estructruraControl, decide, condicion, loop, for;

/* >> Funciones y sus llamadas  */
non terminal funcionLlamada, argumentos, return, break;

/* Aqui estoy poniendo los no terminales que estan faltando */
non terminal  tipoDatoInput, condiciones, listaFunciones;


/* >> Input y ouput */
non terminal input, output, output_inline;

/* >> Listas */
non terminal lista, declaracionLista, creacionYAsignacionLista, elementos, elementoLista, modificarElementoLista, obtenerElementoLista, tipoLista;



/* Precedencia de operadores (de menor a mayor precedencia) */

// Operadores binarios
precedence left OR;
precedence left AND;
precedence right NOT; 

/* Operadores booleanos y relacionales */
precedence left IGUAL, DIFERENTE;
precedence left MENOR, MAYOR, MENOR_IGUAL, MAYOR_IGUAL;

/* Operadores aritmeticos */
precedence left MAS, MENOS;
precedence left MULTIPLICACION, DIVISION, DIVISION_ENTERA, MODULO;
precedence right POTENCIA;

// Operadores unarios
precedence left INCREMENTO, DECREMENTO;
precedence right MENOS; /* Pasar a negativo: Revisar la gramatica original para una posible correccion. */


/* Precedencia para resolver conflictos */
precedence left COMA;
precedence right ASIGNACION;


/* expect 6; Esto es para decirle a cup qie espere hasta 6 congliuctos y que los acepte */

/* Esta es la que dice como se inicia todo. */
start with programa;



/* -------------------------  >> Definicion << -------------------------------------------------------------------  */


/* Producciones generales */
programa ::= varGlobal programa
           | funciones programa  
           | principal
           | error:e {: System.err.println("Error en el programa - recuperando"); :} programa
           | error:e {: System.err.println("Error de sintaxis en el programa"); :};

principal ::= VOID PRINCIPAL PAREN_I PAREN_D bloque
            | error:e PRINCIPAL PAREN_I PAREN_D bloque {: System.err.println("Error antes de 'principal'"); :}
            | VOID error:e PAREN_I PAREN_D bloque {: System.err.println("Error: esperaba 'principal'"); :}
            | VOID PRINCIPAL error:e PAREN_D bloque {: System.err.println("Error: 'principal' no debe tener parámetros"); :};

tipoDatoFuncion ::= INT
                  | FLOAT
                  | BOOLEAN; /* | error {: System.err.println("Error: tipo de función debe ser int, float o boolean"); :} */

tipoDatoVariable ::= INT
                   | FLOAT
                   | BOOLEAN
                   | CHAR
                   | STRING
                   | error {: System.err.println("Error: tipo de variable debe ser int, float, boolean, char o string"); :};

/*funciones ::= funcion
            | funciones funcion;*/

/* Esta modificacion es para intentar resolver el conflicto de funcion */
funciones ::= listaFunciones;

listaFunciones ::= funcion
                 | listaFunciones funcion;




funcion ::= tipoDatoFuncion IDENTIFICADOR PAREN_I params PAREN_D bloque
          | tipoDatoFuncion IDENTIFICADOR PAREN_I PAREN_D bloque
          | error IDENTIFICADOR PAREN_I params PAREN_D bloque {: System.err.println("Error en la definición de la función"); :};

params ::= param
         | params COMA param;

param ::= tipoDatoVariable IDENTIFICADOR;

/* Producciones de sentencias y bloques */
bloque ::= LLAVE_I sentencias LLAVE_D
         | LLAVE_I LLAVE_D
         | error LLAVE_I sentencias LLAVE_D {: System.err.println("Error en la definición del bloque"); :};

sentencias ::= sentencia
             | sentencias sentencia;

sentencia ::= var
            | varAsignacion  
            | varCyAsignacion
            | lista
            | estructruraControl
            | funcionLlamada DELIMITADOR
            | return
            | break
            | input DELIMITADOR
            | output
            | output_inline DELIMITADOR
            | modificarElementoLista
            | error:e DELIMITADOR {: System.err.println("Error en sentencia - recuperando en '$'"); :};

funcionLlamada ::= IDENTIFICADOR PAREN_I argumentos PAREN_D
                 | IDENTIFICADOR PAREN_I PAREN_D;

argumentos ::= expresion
             | argumentos COMA expresion;

return ::= RETURN DELIMITADOR
         | RETURN expresion DELIMITADOR;

break ::= BREAK DELIMITADOR;

input ::= INPUT PAREN_I tipoDatoInput PAREN_D;

tipoDatoInput ::= INT
                | FLOAT;
            
output ::= output_inline DELIMITADOR
          | output CONCATENACION_OUTPUT output_inline DELIMITADOR;

output_inline ::= OUTPUT PAREN_I expresion PAREN_D;

/* Estructuras de control */
estructruraControl ::= decide 
                     | loop 
                     | for;

decide ::= DECIDE OF condiciones END DECIDE DELIMITADOR
         | DECIDE OF condiciones ELSE bloque END DECIDE DELIMITADOR
         | DECIDE error:e condiciones END DECIDE DELIMITADOR 
           {: System.err.println("Error: falta 'of' después de 'decide'"); :}
         | DECIDE OF error:e END DECIDE DELIMITADOR 
           {: System.err.println("Error en las condiciones de 'decide'"); :}
         | DECIDE OF condiciones error:e DELIMITADOR 
           {: System.err.println("Error: falta 'end decide$' para cerrar"); :}
         | error:e OF condiciones END DECIDE DELIMITADOR 
           {: System.err.println("Error: esperaba 'decide'"); :};

condiciones ::= condicion FLECHA bloque
              | condiciones condicion FLECHA bloque
              | error:e FLECHA bloque 
                {: System.err.println("Error en condición"); :}
              | condicion error:e bloque 
                {: System.err.println("Error: falta '->' entre condición y bloque"); :};

loop ::= LOOP bloque EXIT WHEN condicion DELIMITADOR END LOOP DELIMITADOR
       | LOOP bloque break EXIT WHEN condicion DELIMITADOR END LOOP DELIMITADOR
       | LOOP bloque error:e WHEN condicion DELIMITADOR END LOOP DELIMITADOR
         {: 
            System.err.println("Error: falta 'exit' antes de 'when'"); 
         :}
       ;

for ::= FOR IDENTIFICADOR STEP INT_LITERAL TO expresion DO bloque DELIMITADOR
      | FOR IDENTIFICADOR STEP INT_LITERAL DOWNTO expresion DO bloque DELIMITADOR
      | FOR error:e STEP INT_LITERAL TO expresion DO bloque DELIMITADOR
        {: 
           System.err.println("Error: variable de iteración inválida en 'for'"); 
        :}
      | FOR IDENTIFICADOR STEP error:e TO expresion DO bloque DELIMITADOR
        {: 
           System.err.println("Error: valor de 'step' debe ser un entero"); 
        :}
      ;

/* Producciones de declaraciones y variables con DELIMITADOR (pendiente) */
var ::= LET tipoDatoVariable IDENTIFICADOR DELIMITADOR; /* | LET tipoDatoVariable IDENTIFICADOR ASIGNACION expresion DELIMITADOR    -- Se cambio esto por que era lo mismo */

varAsignacion ::= IDENTIFICADOR ASIGNACION expresion DELIMITADOR;
                 
varCyAsignacion ::= LET tipoDatoVariable IDENTIFICADOR ASIGNACION expresion DELIMITADOR;

varGlobal ::= GLOBAL tipoDatoVariable IDENTIFICADOR DELIMITADOR
            | GLOBAL tipoDatoVariable IDENTIFICADOR ASIGNACION expresion DELIMITADOR;



/* ##### Seccion para las expresiones ######*/
expresion ::= expresionAritmetica
            | expresionLogica
            | expresionChar
            | expresionString
            | obtenerElementoLista
            | funcionLlamada
            | IDENTIFICADOR;

expresionLogica ::= expresionLogica AND expresionLogica
                  | expresionLogica OR expresionLogica
                  | NOT expresionLogica
                  | PAREN_I expresionLogica PAREN_D
                  | expresionRelacional
                  | expresionBooleana;
                 
expresionRelacional ::= expresionAritmetica IGUAL expresionAritmetica
                      | expresionAritmetica DIFERENTE expresionAritmetica
                      | expresionAritmetica MENOR expresionAritmetica
                      | expresionAritmetica MAYOR expresionAritmetica
                      | expresionAritmetica MENOR_IGUAL expresionAritmetica
                      | expresionAritmetica MAYOR_IGUAL expresionAritmetica
                      | expresionBooleana IGUAL expresionBooleana
                      | expresionBooleana DIFERENTE expresionBooleana
                      | expresionChar IGUAL expresionChar
                      | expresionChar DIFERENTE expresionChar;
                     /* | PAREN_I expresionRelacional PAREN_D;*/
       

expresionChar ::= CHAR_LITERAL;

expresionString ::= STRING_LITERAL;

expresionBooleana ::= TRUE
                    | FALSE;




/* >> Expresiones aritmeticas */

expresionAritmetica ::= expresionSuma;


expresionSuma ::= expresionSuma MAS expresionProducto
                | expresionSuma MENOS expresionProducto
                | expresionProducto;

expresionProducto ::= expresionProducto MULTIPLICACION expresionPotencia
                    | expresionProducto DIVISION expresionPotencia
                    | expresionProducto DIVISION_ENTERA expresionPotencia
                    | expresionProducto MODULO expresionPotencia
                    | expresionPotencia;
          
expresionPotencia ::= expresionFactor POTENCIA expresionPotencia
                    | expresionFactor;


expresionFactor ::= PAREN_I expresionAritmetica PAREN_D
                  | expresionNumerica
                  | expresionAritmeticaUnaria
                  | expresionAritmeticaUnariaNegativa;

expresionNumerica ::= INT_LITERAL
                    | FLOAT_LITERAL
                    | IDENTIFICADOR
                    | funcionLlamada /* Esta psoiblemente se tenga que separar en los dos tipos de llamada */
                    | input;

expresionAritmeticaUnaria ::= IDENTIFICADOR INCREMENTO
                            | IDENTIFICADOR DECREMENTO;

expresionAritmeticaUnariaNegativa ::= MENOS expresionNumerica;


/* ##### Seccion parael manejo de listas ######*/
lista ::= declaracionLista
        | creacionYAsignacionLista;

declaracionLista ::= LET tipoLista IDENTIFICADOR DELIMITADOR;

creacionYAsignacionLista ::= LET tipoLista IDENTIFICADOR ASIGNACION LLAVE_I elementos LLAVE_D DELIMITADOR;

elementos ::= elementoLista
            | elementos COMA elementoLista;

elementoLista ::= INT_LITERAL
                | CHAR_LITERAL;

modificarElementoLista ::= IDENTIFICADOR CORCHETE_I expresionAritmetica CORCHETE_D ASIGNACION elementoLista DELIMITADOR;

obtenerElementoLista ::= IDENTIFICADOR CORCHETE_I expresionAritmetica CORCHETE_D;

tipoLista ::= INT CORCHETE_I CORCHETE_D
            | CHAR CORCHETE_I CORCHETE_D
            | INT CORCHETE_I INT_LITERAL CORCHETE_D
            | CHAR CORCHETE_I INT_LITERAL CORCHETE_D;

