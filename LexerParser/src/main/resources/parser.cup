/* Definicion del pasers con CUP para el analisis de la gramatica.  */

/* Imports que se ocupan */
package parser;

import java_cup.runtime.*;
import lexer.*;
import java.io.*;
import lexer.Lexer;

// Estos serian para la parte del manejo de la tabla de simbolos.
import java.util.HashMap;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.Stack;

// Import las clases necesarias para la tabla de simbolos.
import simbolos.Token;
import simbolos.Ambitos;
import simbolos.TipoLista;
import simbolos.TipoExpresiones;
import simbolos.TokenDecide;
import simbolos.CondicionBloque;

// Import de TAC
import simbolos.Cuad;
import simbolos.TAC_Generator;


/* Aqui vamos a definir lo que se va a ejecutar al reducir una produccion o algo asi. (Es diferente del 'parser code')*/
action code {: // Esta parte podria ir en un archivo aparte, pero probemoslo asi de momento.


// Esta es basicamente todo el manejo de la tabla de simbolos y asi definir su alcance por ambitos.

  {
    entornoActual = new Ambitos(null); // Ambito raiz, este es el inicial, el que contiene a los demas, aqui estan las globales y todas las funciones.
    System.out.println(" \n>> Ambito inicial global creado \n");
  }

  Token funcionActual; // Para trabajar lo que es el analisis semantico de la llamada a funciones.

  Token funcionEnAnalisis; // Esta esa para tener los datos de la funcionn que estamos revisando en este momento.

  Stack<String> pilaEstrucControl = new Stack<>();// La idea con esto que que para saber si estamos dentro de una estructura de control.
  Stack<String> pilaLoopExitLabels = new Stack<>();
  Stack<String> pilaLoopStartLabels = new Stack<>();
  int contador = 0; // Esto es para ayudar a generar el token de los identificadores del decide.

  int contadorFor = 0;

  int contadorLoop = 0;

  // Para tac:
  int indiceParametroActual = 0; // Indice del parametro que se se "lee" actualmente
  int contadorArgActual = 0;

  private String operandoString (TipoExpresiones expr) {
    if (expr == null) {
        return "null";
    }
    if (expr.temp != null) {
        return expr.temp;
    }
    if (expr.valorI != null) {
        return expr.valorI.toString();
    }
    if (expr.valorF != null) {
        return expr.valorF.toString();
    }
    if (expr.valorS != null) {
        return expr.valorS;
    }
    if (expr.valorC != null) {
        return expr.valorC.toString();
    }
    if (expr.valorB != null) {
        return expr.valorB.toString();
    }
    return "null";
  }






  // Crear un nuevo ambito y asigarle a lo anterior el que ya estabamos trabajando. [Este esta mas pensado para lo que pase dentro de BLOQUE]
  public void crearAmbito() {
      entornoActual = new Ambitos(entornoActual);
  }

  // Este seria para generar ambitos de funciones.
  public void crearAmbitoFuncion(String nombreFuncion, String tipo, int linea, int columna) {
      // Registrar la función como simbolo en el entorno padre

      Token funcion = new Token(nombreFuncion, tipo, "global", null, "funcion", linea, columna); // Queda mejor hacer el token aqui que en la parte de la produccion directamente.
      entornoActual.insertarNuevoToken(funcion);

      // Crear entorno local para parámetros y variables internas
      entornoActual = new Ambitos(entornoActual);
  }


  // Volver a lo que seria el ambito de mas arriba, el padre por asi decirlo, en algun punto vuelve al punto general del programa.
  public void cerrarAmbito() {
      entornoActual = entornoActual.getAnterior();
      System.out.println(" \n>> Ambito cerrado. \n");
  }

  // Ahora se inserta un nuevo simbolo en el ambito en el que estamos.
  public boolean insertarNuevoToken(Token token) {
      return entornoActual.insertarNuevoToken(token);
  }


  // >> Esta seria la seccion para la parte de busquedas.

  // Buscar la existencia de un simbolo especifico en ambito, [Esto deberia de cambiarse para que sean por  especifico para un identificador y especifico para funciones].
  public Token buscarToken(String nombre) {
      return entornoActual.buscar(nombre);
  }

  public Token buscarFuncion(String nombre) {

    for (Ambitos ambito = entornoActual; ambito != null; ambito = ambito.getAnterior()) {
      
        Token token = ambito.buscar(nombre);

        if (token != null && "funcion".equals(token.getCategoria())) {
          return token;
        }
    }
    return null;
  }

  // Mostrar la tabla de simbolos actual.
  public void mostrarTablaActual() {
      System.out.println("Tabla de simbolos actual:");
      for (Token token : entornoActual.getTablaActual().values()) {
          token.mostrarToken();
      }
  }

    // Para buscar el ambito de una funcion especifica.
    public Ambitos buscarAmbitoDeFuncion(String nombre) {
        Ambitos actual = entornoActual;
        while (actual != null) {

            Token token = actual.buscar(nombre);
            if (token != null && "funcion".equals(token.getCategoria())) {
                return actual;
            }

            actual = actual.getAnterior();
        }
        return null;
    }

    // Para obtener los tipos de parametros de una funcion
    public List<String> obtenerTiposParametros(Token funcion) {
        List<String> tipos = new ArrayList<>();
        Ambitos ambitoFuncion = funcion.getAmbitoLocal();
        if (ambitoFuncion == null) return tipos;
        
        for (Token t : ambitoFuncion.getTablaActual().values()) {
            if ("parametro".equals(t.getCategoria())) {
                tipos.add(t.getTipo());
            }
        }
        return tipos;
    }

    // public void mostrarTodosLosAmbitosV1() {
    //     System.out.println("╔════════════════════════════════════════════════════════════════════════════╗");
    //     System.out.println("║                    TABLA DE SÍMBOLOS EN TODOS LOS AMBITOS                  ║");
    //     System.out.println("╠════════════════════════════════════════════════════════════════════════════╣");
    //     System.out.printf("║ %-15s │ %-10s │ %-10s │ %-10s │ %-10s │ %-5s │ %-5s ║\n",
    //                     "Nombre", "Tipo", "Categoria", "Ambito", "Valor", "Linea", "Col");
    //     System.out.println("╠════════════════════════════════════════════════════════════════════════════╣");

    //     int nivel = 0;
    //     for (Ambitos ambito = entornoActual; ambito != null; ambito = ambito.getAnterior()) {
    //         System.out.println("\n>> Ambito con " + ambito.getTablaActual().size() + " tokens. \n");
    //         String nombreAmbito = "\nNivel_" + nivel;
    //         for (Token t : ambito.getTablaActual().values()) {
    //             System.out.printf("║ %-15s │ %-10s │ %-10s │ %-10s │ %-10s │ %-5d │ %-5d ║\n",
    //                             t.getNombre(), t.getTipo(), t.getCategoria(),
    //                             nombreAmbito, String.valueOf(t.getValor()),
    //                             t.getLinea(), t.getColumna());
    //         }
    //         nivel++;
    //     }

    //     System.out.println("╚════════════════════════════════════════════════════════════════════════════╝");
    // }





    // Para obtener el tipo de dato de un identificador, principalmente variables.
    public TipoExpresiones obtenerTipoIdentificador(String nombre) {
        for (Ambitos ambito = entornoActual; ambito != null; ambito = ambito.getAnterior()) {
            Token token = ambito.buscar(nombre);
            if (token != null && ("variable".equals(token.getCategoria()) || "parametro".equals(token.getCategoria()) || "global".equals(token.getCategoria()))
            ) {
                String tipo = token.getTipo();
                System.out.println("Identificador '" + nombre + "' encontrado como " + token.getCategoria() + " de tipo '" + token.getTipo() + "'");
                if ("int".equals(tipo)) return new TipoExpresiones("int");
                if ("float".equals(tipo)) return new TipoExpresiones("float");
                if ("char".equals(tipo)) return new TipoExpresiones("char");
                if ("boolean".equals(tipo)) return new TipoExpresiones("boolean");
                if ("string".equals(tipo)) return new TipoExpresiones("string");

                // Si querés manejar listas en el futuro:
                // if ("lista".equals(tipo)) {
                //     String tipoBase = token.getTipoBase();
                //     Integer tamano = token.getTamano();
                //     return new TipoExpresiones(tipoBase, tamano);
                // }

                // Si el tipo es válido pero no reconocido explícitamente:
                return new TipoExpresiones(tipo);
            }
        }
        System.err.println("Error semantico: identificador '" + nombre + "' no encontrado o no es una variable.");
        return new TipoExpresiones("error", 0);
    }

    // Para obtener el tipo de dato de una funcion.
    public TipoExpresiones obtenerTipoFuncion(Token funcionActualA) {
        if (funcionActualA == null || !"funcion".equals(funcionActualA.getCategoria())) {
            System.err.println("Error semantico: funcion no valida.");
            return new TipoExpresiones("error", 0);
        }
        String tipo = funcionActualA.getTipo(); // Ej: "int", "float", "void", etc.
        if ("void".equals(tipo)) {
            System.err.println("Error semantico: la funcion no retorna valor.");
            return new TipoExpresiones("error", 0);
        }
        return new TipoExpresiones(tipo);
    }

    // Esto es para validar el tipo de datos esperado en las expresiones.
    public boolean validarTipoEsperado(String esperado, TipoExpresiones tipoReal) {
        if (tipoReal == null || "error".equals(tipoReal.tipoDato)) return false;
        // return esperado.equals(tipoReal.tipoDato);

        // Con esta parte de aqui ya acepta esto "int|float", para que valide los dos a la vez.
        String[] tipos = esperado.split("\\|");
        for (String t : tipos) {
            if (t.equals(tipoReal.tipoDato)) {
                return true;
            }
        }
        return false;
    }

    // Funcion para validar si el tipo de dos argumentos de una expresionn son de tipo iguales y que solo sean numericos, esto podria separarse para dar mensajes mas explicitos.
    public boolean tiposIgualesNumericos(TipoExpresiones a, TipoExpresiones b) {
        if (a == null || b == null) return false;
        String t1 = a.tipoDato;
        String t2 = b.tipoDato;
        return (t1.equals(t2)) && (t1.equals("int") || t1.equals("float")); // Validar los tipos.
    }

    // Para validar que los tipos de datos sean iguales.
    public boolean tiposIguales(TipoExpresiones a, TipoExpresiones b) {
        return a != null && b != null && a.tipoDato != null && a.tipoDato.equals(b.tipoDato);
    }

    // Para validar que el operador sea valido con ese tipo de dato.
    public boolean tipoPermitidoComparacion(String tipo, String operador) {
        switch (operador) {
            case "==": case "!=":
                return tipo.equals("int") || tipo.equals("float") || tipo.equals("char") || tipo.equals("boolean");
            case "<": case ">": case "<=": case ">=":
                return tipo.equals("int") || tipo.equals("float");
            default:
                return false;
        }
    }



:};



/* Parsers */
parser code {:
    Ambitos entornoActual = null; // Para el entorno que seria basicamente lo que son cada uno de los ambitos de cada una de las partes del codigo leido.

    private int countErroresSemanticos = 0; // Para ir contando la cantidad de errores semanticos.

    private int errorContador = 0;

    public int getErrorContador() {
        return errorContador;
    }

    // Funcion para obtener todos los errores semanticos que se hayan encontrado.

    public int getCountErroresSemanticos () {
        return countErroresSemanticos;
    }

    private String obtenerInfoToken(Symbol tok) {
        if (tok == null) return "<EOF>";
        int s = tok.sym;
        Object v = tok.value;
        String val = (v == null) ? "" : (" '" + v.toString() + "'");
        switch (s) {
            case sym.LET: return "LET" + val;
            case sym.GLOBAL: return "GLOBAL";
            case sym.VOID: return "VOID";
            case sym.PRINCIPAL: return "PRINCIPAL";
            case sym.DECIDE: return "DECIDE";
            case sym.OF: return "OF";
            case sym.ELSE: return "ELSE";
            case sym.END: return "END";
            case sym.LOOP: return "LOOP";
            case sym.EXIT: return "EXIT";
            case sym.WHEN: return "WHEN";
            case sym.FOR: return "FOR";
            case sym.STEP: return "STEP";
            case sym.TO: return "TO";
            case sym.DOWNTO: return "DOWNTO";
            case sym.DO: return "DO";
            case sym.RETURN: return "RETURN";
            case sym.BREAK: return "BREAK";
            case sym.OUTPUT: return "OUTPUT";
            case sym.INPUT: return "INPUT";
            case sym.TRUE: return "TRUE";
            case sym.FALSE: return "FALSE";
            case sym.INT: return "INT";
            case sym.FLOAT: return "FLOAT";
            case sym.BOOLEAN: return "BOOLEAN";
            case sym.CHAR: return "CHAR";
            case sym.STRING: return "STRING";
            case sym.IDENTIFICADOR: return "IDENTIFICADOR" + val;
            case sym.INT_LITERAL: return "INT_LITERAL" + val;
            case sym.FLOAT_LITERAL: return "FLOAT_LITERAL" + val;
            case sym.STRING_LITERAL: return "STRING_LITERAL" + val;
            case sym.CHAR_LITERAL: return "CHAR_LITERAL" + val;
            case sym.MAS: return "+";
            case sym.MENOS: return "-";
            case sym.MULTIPLICACION: return "*";
            case sym.DIVISION: return "/";
            case sym.DIVISION_ENTERA: return "//";
            case sym.MODULO: return "%";
            case sym.POTENCIA: return "^";
            case sym.INCREMENTO: return "++";
            case sym.DECREMENTO: return "--";
            case sym.IGUAL: return "==";
            case sym.DIFERENTE: return "!=";
            case sym.MENOR: return "<";
            case sym.MAYOR: return ">";
            case sym.MENOR_IGUAL: return "<=";
            case sym.MAYOR_IGUAL: return ">=";
            case sym.AND: return "AND(@)";
            case sym.OR: return "OR(~)";
            case sym.NOT: return "NOT(Σ)";
            case sym.ASIGNACION: return "=";
            case sym.DELIMITADOR: return "$";
            case sym.COMA: return ",";
            case sym.PAREN_I: return "PAREN_I(є)";
            case sym.PAREN_D: return "PAREN_D(э)";
            case sym.CORCHETE_I: return "[";
            case sym.CORCHETE_D: return "]";
            case sym.LLAVE_I: return "LLAVE_I(¿)";
            case sym.LLAVE_D: return "LLAVE_D(?)";
            case sym.FLECHA: return "->";
            case sym.CONCATENACION_OUTPUT: return "<<";
            case sym.ERROR: return "ERROR" + val;
            default: return "SIMBOLO(" + s + ")" + val;
        }
    }

    public void syntax_error(Symbol cur_token) {
        System.err.println("Error sintactico en linea " + (cur_token != null ? cur_token.left : -1)
                + ", columna " + (cur_token != null ? cur_token.right : -1)
                + ": Token inesperado: " + obtenerInfoToken(cur_token));
        errorContador++;
    }

    public void report_error(String message, Object info) {
    }

    public void unrecovered_syntax_error(Symbol cur_token) throws java.lang.Exception {
        System.err.println("Error sintactico no recuperable en linea " + (cur_token != null ? cur_token.left : -1)
                + ", columna " + (cur_token != null ? cur_token.right : -1)
                + ": " + obtenerInfoToken(cur_token));
        throw new Exception("Fin del analisis por error sintactico grave.");
    }

    public void mostrarTS() {
        entornoActual.mostrarTodosLosAmbitos(entornoActual);
    }

    public void aumentarCountErroresSemanticos () {
        countErroresSemanticos++;
    }

    // PRUEBAS TAC
    public boolean esHoja (TipoExpresiones e) {
        return e.cuads.isEmpty(); // Si no contiene otros cuadruplos quiere decir que es hoja (no tiene subexpresiones)
    }

    public String valorHoja (TipoExpresiones e) {
        // Si es un constante o literal almacenado como un temporal:
        if (e.temp != null) {
            return e.temp;
        }
        return e.temp; // si es hoja no deberia llegar aqui porque el temp deberia tener valor
    }

:};




// >> El profe tambien define esto. >> De momento lo dejo comentado por que no se para que sirve.
// init with {: :};

// scan with {: return lexer.next_token(); :};




/* Definición de terminales (tokens) */
// Son las palabras reservadas
terminal String LET, GLOBAL, VOID, PRINCIPAL, DECIDE, OF, ELSE, END, LOOP, EXIT;
terminal String  WHEN,  RETURN, BREAK, INPUT, FOR, STEP, TO, DOWNTO, DO;

// Modificamos el output para que sea solo usado como sentencia y no en asignaciones o cosas raras:
terminal String OUTPUT;

// Tipos de datos
terminal String INT, FLOAT, BOOLEAN, CHAR, STRING;

// Literales de los tipos de datos, esta es la representacion en string.
terminal Integer INT_LITERAL;
terminal Double FLOAT_LITERAL;
terminal String STRING_LITERAL;
terminal Character CHAR_LITERAL;
terminal Boolean TRUE, FALSE;

// Identificadores.
terminal String IDENTIFICADOR;

// Operadores aritmeticos
terminal MAS, MENOS, MULTIPLICACION, DIVISION, DIVISION_ENTERA, MODULO, POTENCIA;
terminal INCREMENTO, DECREMENTO;

// Operadores relacionales
terminal IGUAL, DIFERENTE, MENOR_IGUAL, MAYOR_IGUAL, MENOR, MAYOR;

// Operadores logicos
terminal AND, OR, NOT;

// Asignacion
terminal ASIGNACION;

// Delimitadores y separadores
terminal DELIMITADOR, COMA;
terminal PAREN_I, PAREN_D,CORCHETE_I, CORCHETE_D, LLAVE_I, LLAVE_D;

// La flecha para los if y el concatenador de los prints.
terminal FLECHA, CONCATENACION_OUTPUT;

// Terminar para la deficion de errores lexicos.
terminal ERROR;

// Nuevos elementos agregados para el PY 2.

terminal LISTA;
terminal ARGUMENTOS;



// --------- Fin elementos nuevos.



/* -------------->>>> Seccion para los no terminales */

/* >> Estructura general*/
non terminal programa, principal, funciones, funcion, params, param;

/* >> Tipos de datos: A estos se les agrega que sean String para que sea mas facil trabajarles la parte semanatica. */
non terminal String tipoDatoFuncion, tipoDatoVariable;

/* >> Sentencias y bloques */
non terminal sentencias, sentencia;

non terminal Token bloque;

/* >> Declaraciones y variables */
non terminal var, varAsignacion, varCyAsignacion, varGlobal;

/* >> Expresiones  */

non terminal TipoExpresiones expresion;

/* > Numericas */
non terminal TipoExpresiones expresionNumerica, expresionSuma, expresionProducto, expresionPotencia, expresionFactor, expresionAritmeticaUnaria, expresionAritmeticaUnariaNegativa;

/* > Boolenas  */
non terminal TipoExpresiones expresionBooleana;

/* > Literales */
non terminal TipoExpresiones expresionChar, expresionString;

/* > Expresiones compuestas */
non terminal TipoExpresiones expresionAritmetica, expresionLogica, expresionRelacional;

/* >> Control de flujo */
non terminal estructruraControl, decide, loop, for;

non terminal TipoExpresiones condicion;

non terminal forInt, loopInicio;

/* >> Funciones y sus llamadas  */
non terminal funcionLlamada, argumentos, return, break;

/* Aqui estoy poniendo los no terminales que estan faltando */
non terminal listaFunciones;
non terminal String tipoDatoInput;

non terminal List<CondicionBloque> condiciones;

/* >> Input y ouput */
non terminal output, output_inline;
non terminal String input;
/* >> Listas */
non terminal lista, declaracionLista, creacionYAsignacionLista ;

non terminal TipoExpresiones elementos, elementoLista, modificarElementoLista, obtenerElementoLista;


// Esta son las nuevas declaraciones: 
non terminal principalParteIzquierda, funcionParteIzquierda, bloqueInicio, funcionLlamadaInicio;

non terminal String tipoDatoParametro; // Le definimo String para que sea mas facil trabajar con lo valores.

non terminal TipoLista tipoLista; // Aqui indicamos que lo que vamos a devolver es un objeto de TipoLista
non terminal Token decideParteIzquierda;

non terminal seExprAritUni, seOutput, seInput, seFuncLlama;

non terminal bloqueError;
// non terminal outputError;
// non terminal String operadorRelacional;
// --- Fin de declaracion de nuevos no terminales. 



/* Precedencia de operadores (de menor a mayor precedencia) */

// Operadores binarios
precedence left OR;
precedence left AND;
precedence right NOT; 

/* Operadores booleanos y relacionales */
precedence left IGUAL, DIFERENTE;
precedence left MENOR, MAYOR, MENOR_IGUAL, MAYOR_IGUAL;

/* Operadores aritmeticos */
precedence left MAS, MENOS;
precedence left MULTIPLICACION, DIVISION, DIVISION_ENTERA, MODULO;
precedence right POTENCIA;

// Operadores unarios
precedence left INCREMENTO, DECREMENTO;
precedence right MENOS; /* Pasar a negativo: Revisar la gramatica original para una posible correccion. */


/* Precedencia para resolver conflictos */
precedence left COMA;
precedence right ASIGNACION;


/* expect 6; Esto es para decirle a cup qie espere hasta 6 congliuctos y que los acepte */

/* Esta es la que dice como se inicia todo. */
start with programa;



/* -------------------------  >> Definicion << -------------------------------------------------------------------  */


/* Producciones generales */
/* FIX: La estructura del principal está como opcional, debe de ser obligatorio y al final (por diseño) */
/* FIXED: Se arreglo la estructura para que siempre haya un bloque principal */
programa ::= varGlobal programa
           | funciones principal {: 
                if (buscarFuncion("principal") == null) {
                    System.err.println(" -> Error semantico: no se ha definido la funcion principal.");
                    aumentarCountErroresSemanticos();
                }
                // mostrarTS();
            :} 
           | principal {: 
                if (buscarFuncion("principal") == null) {
                    System.err.println(" -> Error semantico: no se ha definido la funcion principal.");
                    aumentarCountErroresSemanticos();
                }
                // mostrarTS();
            :};
        //    | error programa {: System.err.println(" -> Error: Declaracion global o funcion no valida"); :};

principalParteIzquierda ::= VOID PRINCIPAL:pri PAREN_I PAREN_D {: 
                            Token principal = new Token("principal", "void", "global", null, "funcion", prileft, priright);
                            if (!insertarNuevoToken(principal)) {
                                System.err.println(" -> Error semantico: funcion 'principal' ya declarada.");
                                aumentarCountErroresSemanticos();
                            }


                            System.out.println("\n >> Reconociendo una funcion 1. \n");
                            crearAmbito(); // entorno local para principal
                            principal.setAmbitoLocal(entornoActual);
                            funcionEnAnalisis = principal; // Para trabajar con lo datos de la funcion.

                            // Generación TAC
                            simbolos.TAC_Generator.generarLabel("FUNC_principal");
                            simbolos.TAC_Generator.generarBeginFunc("principal");
                            indiceParametroActual = 0;
                        :};

principal ::= principalParteIzquierda bloque:blo {: 
            insertarNuevoToken(blo);

            //   mostrarTablaActual();
              cerrarAmbito(); // cerramos entorno de principal

              TAC_Generator.generarEndFunc("principal");
              System.out.println("\n >> Cerando el reconociendo una funcion 1. \n");
          :};

// Se le agrega el result para que las producciones sepan mejor el valor semantico que van a tener.
tipoDatoFuncion ::= INT {: RESULT = "int"; :}
                  | FLOAT {: RESULT = "float"; :}
                  | CHAR {: RESULT = "char"; :}
                  | BOOLEAN {: RESULT = "boolean"; :};

tipoDatoVariable ::= INT {: RESULT = "int"; :}
                  | FLOAT {: RESULT = "float"; :}
                  | BOOLEAN {: RESULT = "boolean"; :}
                  | CHAR {: RESULT = "char"; :}
                  | STRING {: RESULT = "string"; :};
                //    | error {: System.err.println("Error: tipo de variable debe ser int, float, boolean, char o string"); :};



/* Esta modificacion es para intentar resolver el conflicto de funcion */
funciones ::= listaFunciones;

listaFunciones ::= funcion
                 | listaFunciones funcion;


// Para esta porte de las funciones, las dividimos en parte izquierda y parte derecha para que sea mas facil el analisis.
funcionParteIzquierda ::= tipoDatoFuncion:tipo IDENTIFICADOR:ID PAREN_I  {: 
                        Token funcion = new Token(ID, tipo, "global", null, "funcion", IDleft, IDright);
                        if (!insertarNuevoToken(funcion)) {
                            System.err.println(" -> Error semantico: funcion '" + ID + "' ya declarada.");
                            aumentarCountErroresSemanticos();
                        }

                        System.out.println("\n >> Reconociendo una funcion 1. \n");
                        crearAmbito(); // Crear el ambito local de una funcion, esto antes de que se cree el bloque.
                        funcion.setAmbitoLocal(entornoActual); // Me parece que este deberia de 
                        funcionEnAnalisis = funcion; // Guardamos la funcion que acabamos de crear para que sea mas facil trabajarla despues.
                        TAC_Generator.generarLabel ("FUNC_" + ID);
                        TAC_Generator.generarBeginFunc (ID);
                        indiceParametroActual = 0;
                      :}; // Fin de produccion.
  


// Funciones en la parte derecha.
funcion ::= funcionParteIzquierda params PAREN_D bloque:blo {: 
            insertarNuevoToken(blo);
            cerrarAmbito(); // Cerramos el ambito local de una funcion.
            TAC_Generator.generarEndFunc (funcionEnAnalisis.getNombre());
            System.out.println("\n >> Creando el reconociendo una funcion 1. \n");
        :}
        | funcionParteIzquierda PAREN_D bloque:blo {: 
            insertarNuevoToken(blo);
            cerrarAmbito(); 
            TAC_Generator.generarEndFunc (funcionEnAnalisis.getNombre());
            System.out.println("\n >> Creando el reconociendo una funcion 1. \n");
        :}
        | funcionParteIzquierda params PAREN_D bloque:blo error {: System.err.println(" -> Error sintectico, se encontro un elemento inesperado despues del la funcion."); insertarNuevoToken(blo); cerrarAmbito(); :}
        | funcionParteIzquierda PAREN_D bloque:blo error {: System.err.println(" -> Error sintectico, se encontro un elemento inesperado despues del la funcion."); insertarNuevoToken(blo); cerrarAmbito(); :}; // Fin de produccion.


// >>>>>>>>>>Parte de los parametros de una funcion
params ::= param
         | params COMA param
         | error COMA param{: System.err.println(" -> Error: No puede haber una (,) sola al inicio de los parametros."); :};

// Definirle el valos de formas mas explicita para que puedan ser leidos.
tipoDatoParametro ::= INT {: RESULT = "int"; :}
                    | FLOAT {: RESULT = "float"; :}
                    | BOOLEAN {: RESULT = "boolean"; :}
                    | CHAR {: RESULT = "char"; :}
                    | STRING {: RESULT = "string"; :};
                    // | tipoLista {: RESULT = new Symbol(sym.LISTA, "lista"); :}; // Este se tiene que mover ya que no dejara trabajar con lo del semantico

param ::= tipoDatoParametro:tipo IDENTIFICADOR:ID {: 
          Token parametro = new Token(ID, tipo, "parametro", null, "parametro", IDleft, IDright);
          if (!insertarNuevoToken(parametro)) {
              System.err.println(" -> Error semantico: parametro '" + ID + "' ya declarado.");
              aumentarCountErroresSemanticos();
          }
          TAC_Generator.generarPopParam (indiceParametroActual++, ID); // Se luga el parametro al indice
        :}
      | tipoLista:tipo IDENTIFICADOR:ID {: //Despues se tiene que hacer algo para trabajar con lo del tamaño.
          Token parametro = new Token(ID, tipo.tipoBase, "parametro", null, "parametro", IDleft, IDright);
          if (!insertarNuevoToken(parametro)) {
              System.err.println(" -> Error semantico: parametro '" + ID + "' ya declarado.");
              aumentarCountErroresSemanticos();
          }
          TAC_Generator.generarPopParam (indiceParametroActual++, ID);
        :}
      | error IDENTIFICADOR {: System.err.println(" -> Error: Para los parametros de una funcion se debe de indicar su tipo de dato."); :};


// -------------------------- Seccion del bloque primario de lo que son las funciones.

bloqueInicio ::= LLAVE_I {: 
    crearAmbito(); 
:};

bloqueError ::= error sentencias LLAVE_D:ld {: 
                // Ambitos ambitoBloque = entornoActual;
                // cerrarAmbito();
                
                System.err.println(" -> Error: Los bloques deben de tener una llave de apertura (¿)."); 
                // RESULT = new Token("bloqueError", null, "local", null, "bloqueError", ldleft, ldright);
                // RESULT.setAmbitoLocal(entornoActual);
            :}
         | error LLAVE_D:ld {: 
                // Ambitos ambitoBloque = entornoActual;
                // cerrarAmbito();

                System.err.println(" -> Error: Los bloques deben de tener una llave de apertura (¿). "); 
                // RESULT = new Token("bloqueError", null, "local", null, "bloqueError", ldleft, ldright);
                // RESULT.setAmbitoLocal(ambitoBloque);
            :}
         | LLAVE_I:li sentencias error {: 
                // Ambitos ambitoBloque = entornoActual;
                // cerrarAmbito();

                System.err.println(" -> Error: Los bloques deben de tener una llave de cierre (?). "); 
                // RESULT = new Token("bloqueError", null, "local", null, "bloqueError", lileft, liright);
                // RESULT.setAmbitoLocal(ambitoBloque);
            :};


/* Producciones de sentencias y bloques */
bloque ::= bloqueInicio sentencias LLAVE_D:ld {: 
              // Guardar el entorno antes de cerrarlo
            //   mostrarTablaActual();
              Ambitos ambitoBloque = entornoActual;
              cerrarAmbito();

              // Crear un token de bloque o devolver el ambito
              RESULT = new Token("bloque", null, "local", null, "bloque", ldleft, ldright);
              RESULT.setAmbitoLocal(ambitoBloque);

              // Si estamos dentro de una función en análisis, enlazarlo
            //   if (funcionEnAnalisis != null) {
            //       funcionEnAnalisis.setAmbitoLocal(ambitoBloque);
            //   }
          :}
        | bloqueError:Id {:
                Ambitos ambitoBloque = entornoActual;
                cerrarAmbito();
        
                RESULT = new Token("bloqueError", null, "local", null, "bloqueError", Idleft, Idright);
                RESULT.setAmbitoLocal(ambitoBloque);

        :};
        // | bloqueInicio LLAVE_D:ld {: 
                // mostrarTablaActual();
            //   Ambitos ambitoBloque = entornoActual;
            //   cerrarAmbito();

            //   RESULT = new Token("bloque", null, "local", null, "bloque", ldleft, ldright);
            //   RESULT.setAmbitoLocal(entornoActual);

            //   if (funcionEnAnalisis != null) {
            //       funcionEnAnalisis.setAmbitoLocal(ambitoBloque);
            //   }
        //   :}

        //  | error sentencias LLAVE_D:ld {: 
        //         Ambitos ambitoBloque = entornoActual;
        //         cerrarAmbito();
                
        //         System.err.println(" -> Error: Los bloques deben de tener una llave de apertura (¿)."); 
        //         RESULT = new Token("bloqueError", null, "local", null, "bloqueError", ldleft, ldright);
        //         RESULT.setAmbitoLocal(entornoActual);
        //     :}
        //  | error LLAVE_D:ld {: 
        //         Ambitos ambitoBloque = entornoActual;
        //         cerrarAmbito();

        //         System.err.println(" -> Error: Los bloques deben de tener una llave de apertura (¿). "); 
        //         RESULT = new Token("bloqueError", null, "local", null, "bloqueError", ldleft, ldright);
        //         RESULT.setAmbitoLocal(ambitoBloque);
        //     :}
        //  | LLAVE_I:li sentencias error {: 
        //         Ambitos ambitoBloque = entornoActual;
        //         cerrarAmbito();

        //         System.err.println(" -> Error: Los bloques deben de tener una llave de cierre (?). "); 
        //         RESULT = new Token("bloqueError", null, "local", null, "bloqueError", lileft, liright);
        //         RESULT.setAmbitoLocal(ambitoBloque);
        //     :};

// bloqueError ::= error sentencias LLAVE_D
//               | error LLAVE_D
//               | LLAVE_I sentencias error ;
// bloque ::= bloqueCorrecto
//          | bloqueError ;



// No tocar esta parte, por alguna razon si funciona y no dio el error de tokens inesperados, esto es brujeria.
sentencias ::= /* vacío */
             | sentencias sentencia ;

// Esta es para el trabajo con la parte de error:
// sentenciasOpc ::= /* vacío */
//                 | sentencias ;

sentencia ::= var
            | varAsignacion  
            | varCyAsignacion
            | lista
            | estructruraControl
            | seFuncLlama
            | return
            | break
            | seInput
            | seOutput
            | modificarElementoLista
            | seExprAritUni;

seFuncLlama ::= funcionLlamada DELIMITADOR;
seInput ::= input DELIMITADOR;
seOutput ::= output DELIMITADOR;
seExprAritUni ::= expresionAritmeticaUnaria DELIMITADOR;

/* FIX: El identificador no debe de ser validado, se valida en producción identificador, sino encuentra busca terminal  */
/*FIXED: Eliminando la linea que valida nombre: | error PAREN_I argumentos PAREN_D  {: System.err.println("Error: Nombre de funcion no valido"); :}*/
funcionLlamadaInicio ::= IDENTIFICADOR:ID PAREN_I {: 
                      Token funcion = buscarFuncion(ID);
                      if (funcion == null) {
                          System.err.println(" -> Error semantico: funcion '" + ID + "' no declarada.");
                          funcionActual = null;
                          aumentarCountErroresSemanticos();
                      } else {
                          System.out.println("Llamada a funcion '" + ID + "' valida.");
                          funcionActual = funcion;
                          // Se podria hacer algo para guardar el token y validar sus argumentos luego.
                      }
                      contadorArgActual = 0; // Reiniciamos el conteo de argumentos cuando leeos llamada
                  :};
// Para la llamada a una funcion.
funcionLlamada ::= funcionLlamadaInicio argumentos:args PAREN_D {: 

                      if (funcionActual == null) {
                          System.err.println(" -> Error semantico: No se puede validardar los argumentos de la funcion, debido a que la funcion  buscada no esta declarada." + "Fila: " + argsleft + ", Columna: " + argsright);
                          aumentarCountErroresSemanticos();
                          RESULT = new TipoExpresiones("error");
                      } else {

                        List<String> argumentos = (List<String>) ((Symbol)args).value;
                        List<String> parametrosEsperados = obtenerTiposParametros(funcionActual);

                        if (argumentos.size() != parametrosEsperados.size()) {
                            System.err.println(" -> Error semantico: funcion '" + funcionActual.getNombre() + "' esperaba " + parametrosEsperados.size() + " argumentos, pero recibio " + argumentos.size() + "Fila: " + argsleft + ", Columna: " + argsright);
                        } else {
                            for (int i = 0; i < argumentos.size(); i++) {
                                if (!argumentos.get(i).equals(parametrosEsperados.get(i))) {
                                    System.err.println(" -> Error semantico: argumento " + (i+1) + " de funcion '" + funcionActual.getNombre() + "' esperaba tipo '" + parametrosEsperados.get(i) + "', pero recibio '" + argumentos.get(i) + "'" + "Fila: " + argsleft + ", Columna: " + argsright);
                                }
                            }
                        }
                        // Generacion TAC
                        if ("void".equals(funcionActual.getTipo())) {
                            TAC_Generator.generarCall (funcionActual.getNombre(), contadorArgActual++, null);
                            RESULT = new TipoExpresiones("void");
                        } else {
                            String t = TAC_Generator.newTemp();
                            TAC_Generator.generarCall (funcionActual.getNombre(), contadorArgActual++, t);
                            TipoExpresiones res = new TipoExpresiones(funcionActual.getTipo());
                            res.temp = t;
                            RESULT = res;
                        }

                      }
                  :}
                 | funcionLlamadaInicio PAREN_D {:
                        if (funcionActual == null) {
                            aumentarCountErroresSemanticos();
                            RESULT = new TipoExpresiones("error");
                        } else {

                            // Generacion TAC
                            if ("void".equals(funcionActual.getTipo())) {
                                TAC_Generator.generarCall (funcionActual.getNombre(), 0, null);
                                RESULT = new TipoExpresiones("void");
                            } else {
                                String t = TAC_Generator.newTemp();
                                TAC_Generator.generarCall (funcionActual.getNombre(), 0, t);
                                TipoExpresiones res = new TipoExpresiones(funcionActual.getTipo());
                                res.temp = t;
                                RESULT = res;
                            }
                        }
                    :}

                 ;


argumentos ::= expresion:expr {: 
                  String valor = operandoString (expr);
                  TAC_Generator.generarParam (valor);
                  contadorArgActual++;

                  List<String> args = new ArrayList<>();
                  args.add(expr.getTipo()); // suponiendo que expresion devuelve tipo: ((Symbol)expr).value.toString()
                  RESULT = new Symbol(sym.ARGUMENTOS, args);
              :}
             | argumentos:prev COMA expresion:expr {:
                  String valor = operandoString (expr);
                  TAC_Generator.generarParam (valor);
                  contadorArgActual++;

                  ((List<String>) ((Symbol)prev).value).add(expr.getTipo()); //((Symbol)expr).value.toString()
                  RESULT = new Symbol(sym.ARGUMENTOS, ((Symbol)prev).value);
              :}
             | error COMA expresion  {: System.err.println(" -> Error: Argumento no valido antes de ','"); :}
             | argumentos COMA error {: System.err.println(" -> Error: Se esperaba expresion despues de ','"); :}
             | argumentos error expresion {: System.err.println(" -> Error: Se esperaba ',' entre argumentos"); :};
             
return ::= RETURN:ret DELIMITADOR {: 
            if (!"void".equals(funcionEnAnalisis.getTipo())) {
                System.err.println(" -> Error semantico: la funcion '" + funcionEnAnalisis.getNombre() + "' debe retornar un valor de tipo '" + funcionEnAnalisis.getTipo() + "'." + "Fila: " + retleft + ", Columna: " + retright);
                aumentarCountErroresSemanticos();
            }
        :}
         | RETURN expresion:expr DELIMITADOR {: 
                String tipoExpr = expr.getTipo(); // suponiendo que expresion devuelve un String con el tipo, pero creo que devolvera una clase con otros datos.
                String tipoFuncion = funcionEnAnalisis.getTipo();

                if ("void".equals(tipoFuncion)) {
                    System.err.println(" -> Error semantico: la funcion '" + funcionEnAnalisis.getNombre() + "' no debe retornar ningun valor." + "Fila: " + exprleft + ", Columna: " + exprright);
                    aumentarCountErroresSemanticos();
                } else if (!tipoExpr.equals(tipoFuncion)) {
                    System.err.println(" -> Error semantico: la funcion '" + funcionEnAnalisis.getNombre() + "' debe retornar tipo '" + tipoFuncion + "', pero se retorno tipo '" + tipoExpr + "'." + "Fila: " + exprleft + ", Columna: " + exprright);
                    aumentarCountErroresSemanticos();
                }   
            :}
         | RETURN expresion error {: System.err.println(" -> Error: Se esperaba un delimitador '$'"); :}
         | RETURN error {: System.err.println(" -> Error: Se esperaba un delimitador '$'"); :};

break ::= BREAK:bre DELIMITADOR {: 
            if (pilaEstrucControl.isEmpty() || !"loop".equals(pilaEstrucControl.peek())) {
                System.err.println(" -> Error semantico: 'break' fuera de loop.");
                aumentarCountErroresSemanticos();
            } else if (pilaLoopExitLabels.isEmpty()) {
                System.err.println(" -> Error interno: no hay etiqueta de salida de loop.");
            } else {
                TAC_Generator.generarCuadSaltoIncondicional(pilaLoopExitLabels.peek());
            }
        :};

/*FIX: Se debe hacer algo para que cuando el cup lea un IDENTIFICADOR -> PAREN_I detecte que es input, no una llamada a función*/
input ::= INPUT PAREN_I tipoDatoInput:tipo PAREN_D {:
                if (!"int".equals(tipo) && !"float".equals(tipo)) {
                    System.err.println(" -> Error semantico: tipo '" + tipo + "' no valido para input. Solo se permite int o float. Fila: " + tipoleft + ", Columna: " + tiporight);
                    RESULT = "error";
                    aumentarCountErroresSemanticos();
                } else {
                    RESULT = tipo; // Devolvemos el tipo esperado.
                }
            :}
        | INPUT PAREN_I error PAREN_D {: System.err.println(" -> Error: Tipo de dato no valido para input, debe ser int o float."); :};

tipoDatoInput ::= INT {: RESULT = "int"; :}
                | FLOAT {: RESULT = "float"; :};

// Ouput para imprimir los datos.
output ::= output_inline {: RESULT = "output"; :}
         | output CONCATENACION_OUTPUT output_inline         
         | output error output_inline {: System.err.println(" -> Error: Se debe de definir el caracter de concatenacion (<<) para los outpout "); :};

output_inline ::= OUTPUT PAREN_I expresion PAREN_D;
                // | error PAREN_I expresion PAREN_D {: System.err.println(" -> Error: Se debe de definir la palabra de (output) para indicar una salida en consola."); :};
                // | outputError;

// outputError ::= error PAREN_I expresion PAREN_D {: 
//     System.err.println(" -> Error: Se debe de definir la palabra 'output' para indicar una salida en consola."); 
// :};

/* -------------------- Estructuras de control ----------------------------- */
estructruraControl ::= decide
                     | loop
                     | for
                     ;

decideParteIzquierda ::= DECIDE:deci OF {: 
                            // esta parte deberia ser mas bien para cuando se cierre el ambito.
                            Token estructura = new Token("otro_decide_" + contador++, "estructura", "local", null, "decide", decileft, deciright);
                            // insertarNuevoToken(estructura);
                            crearAmbito();
                            pilaEstrucControl.push("decide");

                            RESULT = estructura;
                        :};

// Aqui hay que agregar algo para agregar a la pila de estructura de control.
decide ::= decideParteIzquierda:deciP condiciones:condi END DECIDE:deci DELIMITADOR {:
                String L_end = TAC_Generator.newEtiqueta();
                for (CondicionBloque cb : condi) {
                    String tCond = operandoString (cb.getCondicion());
                    String t_next = TAC_Generator.newEtiqueta ();
                    TAC_Generator.generarCuadIfFalse (tCond, t_next);
                    TAC_Generator.unir (cb.getTac());
                    TAC_Generator.generarCuadSaltoIncondicional (L_end); //Un salto luego del decide 
                    TAC_Generator.generarLabel (t_next);
                }
                TAC_Generator.generarLabel (L_end);

                // Token estructura = new Token("otro_decide_" + contador++, "estructura", "local", null, "decide", decileft, deciright);
                TokenDecide bloques = new TokenDecide();
                for (CondicionBloque cb : condi) {
                   bloques.addCondiBloque(cb);
                }
                
                deciP.setBloqueDecide(bloques); // Guardamos la estructura interna.
                deciP.setAmbitoLocal(entornoActual); // Este de aqui basicamente no se ocupa, puesto que guardamos las estrcuturas de los bloques por aparte.
                cerrarAmbito(); 
                insertarNuevoToken(deciP);
            :}
         | decideParteIzquierda:deciP condiciones:condi ELSE {: TAC_Generator.iniciarBuffer(); :} bloque:blo END DECIDE DELIMITADOR {:
                List<Cuad> tacElse = TAC_Generator.finalizarBuffer();
                String L_end = TAC_Generator.newEtiqueta();

                for (CondicionBloque cb : condi) {
                    String tCond = operandoString (cb.getCondicion());
                    String t_next = TAC_Generator.newEtiqueta ();
                    TAC_Generator.generarCuadIfFalse (tCond, t_next);
                    TAC_Generator.unir (cb.getTac());
                    TAC_Generator.generarCuadSaltoIncondicional (L_end); //Un salto luego del decide 
                    TAC_Generator.generarLabel (t_next);
                }
                TAC_Generator.unir(tacElse);
                TAC_Generator.generarLabel (L_end);
                
                TokenDecide bloques = new TokenDecide();
                for (CondicionBloque cb : condi) {
                   bloques.addCondiBloque(cb);
                } 

                bloques.setBloqueElse(blo);
                deciP.setBloqueDecide(bloques); // Guardamos la estructura interna.
                deciP.setAmbitoLocal(entornoActual); // Este de aqui basicamente no se ocupa, puesto que guardamos las estrcuturas de los bloques por aparte.
                cerrarAmbito(); 
                insertarNuevoToken(deciP);

            :} // Posiblemente requiramos crear una ambito especifico para el else.
         
         | decideParteIzquierda error condiciones END DECIDE DELIMITADOR {: System.err.println(" -> Error: Se esperaba 'of' despues de 'decide'"); cerrarAmbito(); :}
         | decideParteIzquierda error END DECIDE DELIMITADOR {: System.err.println(" -> Error: Condiciones no validas en estructura decide"); cerrarAmbito(); :}
         | decideParteIzquierda condiciones error DECIDE DELIMITADOR  {: System.err.println(" -> Error: Se esperaba 'end' antes de 'decide'"); cerrarAmbito();  :}
         | decideParteIzquierda condiciones END error DELIMITADOR {: System.err.println(" -> Error: Se esperaba 'decide' despues de 'end'"); cerrarAmbito(); :};

// Esta es la que se usa para DECIDE OF
condiciones ::= condicion:cond FLECHA {: TAC_Generator.iniciarBuffer(); :} bloque:blo {:
                        List<Cuad> tacBloque = TAC_Generator.finalizarBuffer();
                        if (!"boolean".equals(cond.getTipo())) {
                            System.err.println(" -> Error semantico: la condicion en 'decide' debe ser de tipo boolean, pero se recibio '" + cond.getTipo() + "'" + "Fila: " + condleft + ", Columna: " + condright);
                            aumentarCountErroresSemanticos();
                        }
                        CondicionBloque cb = new CondicionBloque (cond, blo);
                        cb.setTac(tacBloque);
                        List<CondicionBloque> lista = new ArrayList<>();
                        lista.add(cb);
                        RESULT = lista;
                    :}
                | condiciones:lista condicion:cond FLECHA {: TAC_Generator.iniciarBuffer(); :} bloque:blo {: 
                        List<Cuad> tacBloque = TAC_Generator.finalizarBuffer();
                        if (!"boolean".equals(cond.getTipo())) {
                            System.err.println(" -> Error semantico: la condicion en 'decide' debe ser de tipo boolean, pero se recibio '" + cond.getTipo() + "'" + "Fila: " + condleft + ", Columna: " + condright);
                            aumentarCountErroresSemanticos();
                        }
                        CondicionBloque cb = new CondicionBloque (cond, blo);
                        cb.setTac(tacBloque);
                        lista.add(cb);
                        RESULT = lista;
                    :};

// Esta parte es mas general y es para cada una 
condicion ::= PAREN_I expresion:expr PAREN_D {: // Esto probablemente tenga una forma diferente despues, la parte de expr va a ser diferente y se tendra que cambiar esta validacion.
                    String tipo = expr.getTipo();
                    if (!"boolean".equals(tipo)) {
                        System.err.println(" -> Error semantico: la condicion en 'decide' debe ser de tipo boolean, pero se recibio '" + tipo + "'" + "Fila: " + exprleft + ", Columna: " + exprright);
                        RESULT = new TipoExpresiones("error");
                        aumentarCountErroresSemanticos();
                    } else {
                        RESULT = expr;
                    }
                :}
            | error expresion PAREN_D {: System.err.println(" -> Error: Se esperaba parentesis de apertura 'є' en condicion"); RESULT = new TipoExpresiones("error"); :}
            | PAREN_I expresion error {: System.err.println(" -> Error: Se esperaba parentesis de cierre 'э' en condicion"); RESULT = new TipoExpresiones("error"); :}
            | PAREN_I error PAREN_D {: System.err.println(" -> Error: Expresion no valida en condicion"); RESULT = new TipoExpresiones("error"); :};


loopInicio ::= LOOP {: 

                // En esta parte debemos de crear el entorno y crear al token que almacenara ese entorno.
                // para que una vez que finalice el loop, agreguemos al entorno padre el token

                crearAmbito(); // Crear el ambito.
                pilaEstrucControl.push("loop"); // Registrar el la pila que hay una nueva estructura.
            :};

loop ::= loopInicio:loopIni {:
                    // Se preparan las etiquetas y el buffer para el body
                    String L_start = TAC_Generator.newEtiqueta();
                    String L_exit  = TAC_Generator.newEtiqueta();
                    pilaLoopStartLabels.push(L_start);
                    pilaLoopExitLabels.push(L_exit);

                    TAC_Generator.generarLabel(L_start);
                    TAC_Generator.iniciarBuffer();
                :} sentencias EXIT WHEN condicion:cond DELIMITADOR END LOOP DELIMITADOR {:
                // Mantenemos el cuerpo del loop
                List<Cuad> cuerpo = TAC_Generator.finalizarBuffer();
                TAC_Generator.unir(cuerpo);

                // Se valida que la expresion sea booleana sino se fuerza un false
                String tCond = operandoString(cond);
                if (!"boolean".equals(cond.getTipo())) {
                    System.err.println(" -> Error semantico: condicion de loop debe ser booleana, se recibio '" 
                                        + cond.getTipo() + "'.");
                    aumentarCountErroresSemanticos();
                    if ("null".equals(tCond)) {
                        tCond = TAC_Generator.newTemp();
                        TAC_Generator.generarCuad("=", "0", null, tCond); // false por defecto
                    }
                }

                // exit when cond  => si cond TRUE, salir; si FALSE, repetir
                TAC_Generator.generarCuadIf(tCond, pilaLoopExitLabels.peek());      // IF cond GOTO L_exit
                TAC_Generator.generarCuadSaltoIncondicional(pilaLoopStartLabels.peek()); // GOTO L_start
                TAC_Generator.generarLabel(pilaLoopExitLabels.peek());              // L_exit:
                if (!pilaLoopExitLabels.isEmpty()) {
                    pilaLoopExitLabels.pop();
                }
                if (!pilaLoopStartLabels.isEmpty()) {
                    pilaLoopStartLabels.pop();
                }
                if (!pilaEstrucControl.isEmpty()) {
                    pilaEstrucControl.pop();
                }
                Token estructura = new Token("otro_loop_" + (contadorLoop++), "estructura", "local", null, "loop", loopInileft, loopIniright);
                estructura.setAmbitoLocal(entornoActual);
                cerrarAmbito();
                insertarNuevoToken(estructura);
            :};

// El for debe de ser una asignacion y la variable debe de estar previamente creada
forInt ::= FOR IDENTIFICADOR:id ASIGNACION expresionAritmetica:exp {:
                crearAmbito(); // Crear el ambito.
                pilaEstrucControl.push("for"); // Registrar el la pila que hay una nueva estructura.
                Token token = entornoActual.buscar(id);

                // Aqui basicamente validamos que el id exista
                if (token == null) {
                    System.err.println(" -> Error semantico: La variable '" + id + "' no ha sido declarada para ser usada en el for. Fila: " + idleft + ", Columna: " + idright);
                    aumentarCountErroresSemanticos();
                } else if (!token.getTipo().equals(exp.tipoDato)){ 
                    // Token varFor = new Token (id, tipo, "local", null, "variable", idleft, idright );
                    // insertarNuevoToken(varFor);
                    System.err.println(" -> Error semantico: Tipo incompatible en asignacion para el for. Se esperaba '" + token.getTipo() + "', pero se recibio '" + exp.tipoDato + "'. Fila: " + idleft + ", Columna: " + idright);
                    aumentarCountErroresSemanticos();

                }


                if (!"int".equals(exp.tipoDato)) {
                    System.err.println(" -> Error semantico: La expresion que se define en el for debe ser tipo int, pero se recibio -> " + exp.tipoDato + "Fila: " + expleft + ", Columna: " + expright);
                    aumentarCountErroresSemanticos();
                }


            :};
        // | FOR   error ASIGNACION expresionAritmetica {:
        //     System.err.println("Error: Se esperaba identificador despues de 'for'");
        //     crearAmbito(); // Crear el ambito.
        //     pilaEstrucControl.push("for");
        // :};

for ::= forInt:init STEP INT_LITERAL TO expresion:expr DO bloque:blo {:

            if (!"int".equals(expr.tipoDato)) {
                System.err.println(" -> Error semantico: La expresion que se define en el for debe ser tipo int, pero se recibio -> " + expr.tipoDato + "Fila: " + exprleft + ", Columna: " + exprright);
                aumentarCountErroresSemanticos();
            }


            // Crear el token del for y registrarlo en el entorno.
            Token estructura = new Token("otro_for_" + contadorFor++, "estructura", "local", null, "for", initleft, initright);
            // Registrar el bloque.
            insertarNuevoToken(blo);
            estructura.setAmbitoLocal(entornoActual);

            // Cerrar el entorno.
            cerrarAmbito();
            insertarNuevoToken(estructura);

        :}
      | forInt:init STEP INT_LITERAL DOWNTO expresion:expr DO bloque:blo {:
            if (!"int".equals(expr.tipoDato)) {
                System.err.println(" -> Error semantico: La expresion que se define en el for debe ser tipo int, pero se recibio -> " + expr.tipoDato + "Fila: " + exprleft + ", Columna: " + exprright);
                aumentarCountErroresSemanticos();
            }
            // Crear el token del for y registrarlo en el entorno.
            Token estructura = new Token("otro_for_" + contadorFor++, "estructura", "local", null, "for", initleft, initright);
            // Registrar el bloque.
            insertarNuevoToken(blo);
            estructura.setAmbitoLocal(entornoActual);

            // Cerrar el entorno.
            cerrarAmbito();
            insertarNuevoToken(estructura);
        :}

    //   | FOR LET INT error ASIGNACION expresionAritmetica STEP INT_LITERAL TO expresion DO bloque  {: System.err.println(" -> Error: Se esperaba identificador despues de 'for'"); :}
      | forInt error INT_LITERAL TO expresion DO bloque  {: System.err.println(" -> Error: Se esperaba 'step' despues del identificador"); cerrarAmbito(); :}
      | forInt STEP error TO expresion DO bloque  {: System.err.println(" -> Error: Se esperaba numero entero despues de 'step'"); cerrarAmbito(); :}
      | forInt STEP INT_LITERAL error expresion DO bloque  {: System.err.println(" -> Error: Se esperaba 'to' o 'downto' en bucle for"); cerrarAmbito(); :}
      | forInt STEP INT_LITERAL TO expresion error bloque  {: System.err.println(" -> Error: Se esperaba 'do' antes del bloque"); cerrarAmbito(); :};

/* Producciones de declaraciones y variables con DELIMITADOR (pendiente) */
var ::= LET tipoDatoVariable:tipo IDENTIFICADOR:id DELIMITADOR {: 
            if (entornoActual.buscar(id) != null) {
                System.err.println(" -> Error semantico: la variable '" + id + "' ya fue declarada. Fila: " + idleft + ", Columna: " + idright);
                aumentarCountErroresSemanticos();
            } else {
                // nombre, tipo, ambito, valor, categoria, linea, columna
                Token tokenVar = new Token(id, tipo, "local", null, "variable", idleft, idright);
                insertarNuevoToken(tokenVar);
                System.out.println("\n >> Definicion var registrada. var \n");
            }
        :}
        | LET tipoDatoVariable:tipo error DELIMITADOR {: System.err.println(" -> Error sintactico: Se debe de colocar un identificador al definir una variable." + "Fila: " + tipoleft + ", Columna: " + tiporight); :};
        //| LET error IDENTIFICADOR:di DELIMITADOR {: System.err.println(" -> Error sintactico: Se debe de definir el tipo de dato al crear una variable." + "Fila: " + idleft + ", Columna: " + idright)); :}; /* | LET tipoDatoVariable IDENTIFICADOR ASIGNACION expresion DELIMITADOR    -- Se cambio esto por que era lo mismo */

varAsignacion ::= IDENTIFICADOR:id ASIGNACION expresion:exp DELIMITADOR {: 
                    Token token = entornoActual.buscar(id);
                    if (token == null) {
                        System.err.println(" -> Error semantico: La variable '" + id + "' no ha sido declarada. Fila: " + idleft + ", Columna: " + idright);
                        aumentarCountErroresSemanticos();
                    } else if (!token.getTipo().equals(exp.tipoDato)) {
                        System.err.println(" -> Error semantico: Tipo incompatible en asignacion. Se esperaba '" + token.getTipo() + "', pero se recibio '" + exp.tipoDato + "'. Fila: " + idleft + ", Columna: " + idright);
                        aumentarCountErroresSemanticos();
                    } else {
                        // Generamos TAC: Si la expresión producjo temporales usamos el ultimo temp, si es hoja usamos el valor directo.
                        String fuente = (exp.temp != null) ? exp.temp : null;
                        System.out.println("Temporal: " + exp.temp);
                        if (fuente == null) {
                            // Usar el valor literal
                            if (exp.valorI != null) {
                                fuente = exp.valorI.toString();
                            } else if (exp.valorF != null) {
                                fuente = exp.valorF.toString();
                            } else if (exp.valorS != null) {
                                fuente = exp.valorS;
                            } else if (exp.valorC != null) {
                                fuente = exp.valorC.toString();
                            } else if (exp.valorB != null) {
                                fuente = exp.valorB.toString();
                            }
                        }
                        if (fuente == null) {
                            System.err.println ("Error: No se pudo obtener el valor de la expresion para asignar a la variable '" + id + "'. Fila: " + idleft + ", Columna: " + idright);
                        } else {
                            TAC_Generator.generarCuadAsignacion (fuente, id);
                        }
                        //token.setValor(exp.valor); // actualizar el valor de la variable
                        // token.setValor(null);
                        System.out.println("\n >> Var globar registrada. varAsignacion\n");
                        
                    }
                :};
                 
varCyAsignacion ::= LET tipoDatoVariable:tipo IDENTIFICADOR:id ASIGNACION expresion:exp DELIMITADOR {: 
                        if (entornoActual.buscar(id) != null) {
                            System.err.println(" -> Error semantico: La variable '" + id + "' ya fue declarada. Fila: " + idleft + ", Columna: " + idright);
                            aumentarCountErroresSemanticos();

                        } else if (!tipo.equals(exp.tipoDato)) {
                            System.err.println(" -> Error semantico: El tipo de la variable '" + id + "' no es compatible con el tipo de la expresion. Se esperaba '" + tipo + "', pero se recibio '" + exp.tipoDato + "'. Fila: " + idleft + ", Columna: " + idright);
                            aumentarCountErroresSemanticos();
                        } else {
                            // nombre, tipo, ambito, valor, categoria, linea, columna
                            Token tokenLocal = new Token(id, tipo, "local", null, "variable", idleft, idright); //<- Se tiene que cambiar esto para para guardar el valor, pero se tiene que modificar desde expresion.
                            insertarNuevoToken(tokenLocal);
                            String fuente = exp.temp;
                            if (fuente == null) {
                                if (exp.valorI != null) {
                                    fuente = exp.valorI.toString();
                                } else if (exp.valorF != null) {
                                    fuente = exp.valorF.toString();
                                } else if (exp.valorS != null) {
                                    fuente = exp.valorS;
                                } else if (exp.valorC != null) {
                                    fuente = exp.valorC.toString();
                                } else if (exp.valorB != null) {
                                    fuente = exp.valorB.toString();
                                }
                            }
                            if (fuente != null) {
                                TAC_Generator.generarCuadAsignacion (fuente, id);
                            } else {
                                System.err.println ("Error: No se pudo obtener el valor de la expresion para asignar a la variable '" + id + "'. Fila: " + idleft + ", Columna: " + idright);
                            }

                            System.out.println("\n >> Variable local registrada. varCyAsignacion \n");
                        }
                    :}
                  | LET tipoDatoVariable IDENTIFICADOR ASIGNACION error DELIMITADOR {: System.err.println("Error: Expresion no valida despues de '='"); :}
                  | LET tipoDatoVariable IDENTIFICADOR error  {: System.err.println("Error: Se esperaba '=' despues del identificador"); :}
                  | LET tipoDatoVariable error ASIGNACION expresion DELIMITADOR {: System.err.println("Error: Identificador no valido"); :}
                  | LET error IDENTIFICADOR ASIGNACION expresion DELIMITADOR {: System.err.println("Error: Tipo de dato no valido"); :};

/* FIX: ERROR en global para que detecte 'global tipo identificador...' */
/* FIXED: Se agrega produ de error en falta de global */
varGlobal ::= GLOBAL tipoDatoVariable:tipo IDENTIFICADOR:id DELIMITADOR {: 
                    if (entornoActual.buscar(id) != null) {
                        System.err.println("-> Error semantico: La variable global '" + id + "' ya fue declarada."  + "Fila: " + idleft + ", Columna: " + idright);
                        aumentarCountErroresSemanticos();
                    } else {
                        //String nombre, String tipo, String ambito, Object valor, String categoria, int linea, int columna
                        Token tokenGlobal = new Token (id, tipo, "global", null, "global", idleft, idright );
                        insertarNuevoToken(tokenGlobal);
                        System.out.println("\n >> Var globar registrada. \n");
                    }
                    System.out.println(">> Reconocida variable global simple");
                :}
            | GLOBAL tipoDatoVariable:tipo IDENTIFICADOR:id ASIGNACION expresion:exp DELIMITADOR {: 
                    if (entornoActual.buscar(id) != null) {
                        System.err.println("-> Error semantico: la variable global '" + id + "' ya fue declarada." + "Fila: " + idleft + ", Columna: " + idright);
                        aumentarCountErroresSemanticos();

                    } else if (!tipo.equals(exp.tipoDato)) {
                        System.err.println("-> Error semantico: El tipo de la variable global no es compatible con el tipo de la expresion que se le asigna. Se esperaba '" + tipo + "', pero se recibió '" + exp.tipoDato + "'." + "Fila: " + idleft + ", Columna: " + idright);
                        aumentarCountErroresSemanticos();
                    } else {
                        Token tokenGlobal = new Token (id, tipo, "global", null, "global", idleft, idright );
                        insertarNuevoToken(tokenGlobal);
                        System.out.println("\n >> Var globar con expresion registrada. \n");

                    }
                :}
                // Estos errores estan dando shift reduce, probablemente hay alguna otra expresion que tambien los tenga.
            // | error tipoDatoVariable IDENTIFICADOR DELIMITADOR {: System.err.println("Error: Se esperaba la palabra 'global' al inicio de la declaracion"); :};
            | GLOBAL error IDENTIFICADOR DELIMITADOR {: System.err.println(" -> Error sintactico: se debe de definir el tipo de dato para la variable global."); :}
            | GLOBAL tipoDatoVariable error DELIMITADOR {: System.err.println(" -> Error sintactico: Se debe de definir una identificador para la variable global."); :}
            | GLOBAL tipoDatoVariable IDENTIFICADOR error {: System.err.println(" -> Error sintactico: Se debe de colocar un delimitador al definir una variable global."); :};





// /* ##### Seccion para las expresiones ######*/
expresion ::= expresionLogica:exp {: RESULT = exp; System.out.println("\n Expresion en validacion -> expresion completa: inicio de la derivacion" + "Tipo final:" + exp.getTipo() + "\n"); :};


/* Modificar las derivacion para expresion logica con el fin de que pueda volver a arriba:  expresionLogica AND expresionLogica| expresionLogica OR expresionLogica*/
expresionLogica ::= expresionLogica:izq AND expresionRelacional:der {: 
                    if (!"boolean".equals(izq.tipoDato) || !"boolean".equals(der.tipoDato)) {
                        System.err.println(" -> Error semantico: El operador 'AND' requiere expresiones booleanas." + "Fila: " + izqleft + ", Columna: " + izqright);
                        aumentarCountErroresSemanticos();
                        RESULT = new TipoExpresiones("error");
                    } else {
                        System.out.println("\n Expresion en validacion -> expr rela: and \n");
                        String a1 = izq.temp != null ? izq.temp : (izq.valorB != null ? izq.valorB.toString() : "null");
                        String a2 = der.temp != null ? der.temp : (der.valorB != null ? der.valorB.toString() : "null");
                        String t = TAC_Generator.newTemp();
                        izq.append(der);
                        TAC_Generator.generarCuad("AND", a1, a2, t); // luego veo como representarlo
                        TipoExpresiones res = new TipoExpresiones("boolean");
                        res.cuads = izq.cuads;
                        res.temp = t;
                        RESULT = res;
                    }
                :}
                | expresionLogica:izq OR expresionRelacional:der {: 
                    if (!"boolean".equals(izq.tipoDato) || !"boolean".equals(der.tipoDato)) {
                        System.err.println(" -> Error semantico: operador 'OR' requiere expresiones booleanas." + "Fila: " + izqleft + ", Columna: " + izqright);
                        aumentarCountErroresSemanticos();
                        RESULT = new TipoExpresiones("error");
                    } else {
                        System.out.println("\n Expresion en validacion -> expr rela: or \n");
                        String a1 = izq.temp != null ? izq.temp : (izq.valorB != null ? izq.valorB.toString() : "null");
                        String a2 = der.temp != null ? der.temp : (der.valorB != null ? der.valorB.toString() : "null");
                        String t = TAC_Generator.newTemp();
                        izq.append(der);
                        TAC_Generator.generarCuad("OR", a1, a2, t); // igual que arriba luego veo como representarlo
                        TipoExpresiones res = new TipoExpresiones("boolean");
                        res.cuads = izq.cuads;
                        res.temp = t;
                        RESULT = res;
                    }
                :}
                | NOT expresionLogica:exp {: 
                    if (!"boolean".equals(exp.tipoDato)) {
                        System.err.println(" -> Error semantico: operador 'NOT' requiere expresion booleana." + "Fila: " + expleft + ", Columna: " + expright);
                        aumentarCountErroresSemanticos();
                        RESULT = new TipoExpresiones("error");
                    } else {
                        System.out.println("\n Expresion en validacion -> expr rela: not  \n");
                        String a1 = exp.temp != null ? exp.temp : (exp.valorB != null ? exp.valorB.toString() : "null");
                        String t = TAC_Generator.newTemp();
                        TAC_Generator.generarCuadUnario("NOT", a1, t, null);
                        TipoExpresiones res = new TipoExpresiones("boolean");
                        res.cuads = exp.cuads;
                        res.temp = t;
                        RESULT = res;
                    }
                :}
                | expresionRelacional:exp {: // En teoria esta deveria de dejar pasar el valor directo
                    // if (!"boolean".equals(exp.tipoDato)) {
                    //     System.err.println("Error semántico: expresion relacional no válida como lógica.");
                    //     RESULT = new TipoExpresiones("error", null);
                    // } else {
                        RESULT = exp;
                        System.out.println("\n Expresion en validacion -> expr logi: expr rela\n");
                    // }
                :};

                  

/* Los de expresionAritmetica no se pueden cambiar ya que los operadores de mayores y menore solo funcionan con estos. Asi */
// expresionRelacional ::= expresionRelacional operadorRelacional expresionAritmetica
//                       | expresionAritmetica
//                       | PAREN_I expresion PAREN_D;

// operadorRelacional ::= IGUAL {: RESULT = "=="; :}
//                      | DIFERENTE {: RESULT = "!="; :}
//                      | MENOR {: RESULT = "<"; :}
//                      | MAYOR {: RESULT = ">"; :}
//                      | MENOR_IGUAL {: RESULT = "<="; :}
//                      | MAYOR_IGUAL {: RESULT = ">="; :};

expresionRelacional ::= expresionAritmetica:izq IGUAL expresionAritmetica:der {:  // En esto podriamos separar las validaciones para que den errores mas explicitos.
                            if (!tiposIguales(izq, der) || !tipoPermitidoComparacion(izq.tipoDato, "==")) {
                                System.err.println(" -> Error semantico: La comparacion '==' no es valida entre tipos '" + izq.tipoDato + "' y '" + der.tipoDato + "'." + "Fila: " + izqleft + ", Columna: " + izqright);
                                aumentarCountErroresSemanticos();
                                RESULT = new TipoExpresiones("error");
                            } else {
                                System.out.println("\n Expresion en validacion -> expr rela: igual\n");
                                String a1 = operandoString (izq);
                                String a2 = operandoString (der);
                                String t = TAC_Generator.newTemp();
                                // izq.append(der);
                                TAC_Generator.generarCuad("==", a1, a2, t);
                                TipoExpresiones res = new TipoExpresiones("boolean");
                                // res.cuads = izq.cuads;
                                res.temp = t;
                                RESULT = res;
                            }
                        :}
                        | expresionAritmetica:izq DIFERENTE expresionAritmetica:der {: 
                            if (!tiposIguales(izq, der) || !tipoPermitidoComparacion(izq.tipoDato, "!=")) {
                                System.err.println(" -> Error semantico: La comparación '!=' no es valida entre tipos '" + izq.tipoDato + "' y '" + der.tipoDato + "'." + "Fila: " + izqleft + ", Columna: " + izqright);
                                aumentarCountErroresSemanticos();
                                RESULT = new TipoExpresiones("error");
                            } else {
                                System.out.println("\n Expresion en validacion -> expr rela: diferente \n");
                                String a1 = operandoString(izq);
                                String a2 = operandoString(der);
                                String t = TAC_Generator.newTemp();
                                // izq.append(der);
                                TAC_Generator.generarCuad("!=", a1, a2, t);
                                TipoExpresiones res = new TipoExpresiones("boolean");
                                // res.cuads = izq.cuads;
                                res.temp = t;
                                RESULT = res;
                            }
                        :}
                        | expresionAritmetica:izq MENOR expresionAritmetica:der {: 
                            if (!tiposIguales(izq, der) || !tipoPermitidoComparacion(izq.tipoDato, "<")) {
                                System.err.println(" -> Error semantico: La comparación '<' no es valida entre tipos '" + izq.tipoDato + "' y '" + der.tipoDato +"'." + "Fila: " + izqleft + ", Columna: " + izqright);
                                aumentarCountErroresSemanticos();
                                RESULT = new TipoExpresiones("error");
                            } else {
                                System.out.println("\n Expresion en validacion -> expr rela: menor\n");
                                String a1 = operandoString(izq);
                                String a2 = operandoString(der);
                                String t = TAC_Generator.newTemp();
                                // izq.append(der);
                                TAC_Generator.generarCuad ("<", a1, a2, t);
                                TipoExpresiones res = new TipoExpresiones("boolean");
                                // res.cuads = izq.cuads;
                                res.temp = t;
                                RESULT = res;
                            }
                        :}
                        | expresionAritmetica:izq MAYOR expresionAritmetica:der {: 
                            if (!tiposIguales(izq, der) || !tipoPermitidoComparacion(izq.tipoDato, ">")) {
                                System.err.println(" -> Error semantico: La comparacion '>' no es valida entre tipos '" + izq.tipoDato + "' y '" + der.tipoDato + "'." + "Fila: " + izqleft + ", Columna: " + izqright);
                                aumentarCountErroresSemanticos();
                                RESULT = new TipoExpresiones("error");
                            } else {
                                System.out.println("\n Expresion en validacion -> expr rela: mayor\n");
                                String a1 = operandoString(izq);
                                String a2 = operandoString(der);
                                String t = TAC_Generator.newTemp();
                                // izq.append(der);
                                TAC_Generator.generarCuad (">", a1, a2, t);
                                TipoExpresiones res = new TipoExpresiones("boolean");
                                // res.cuads = izq.cuads;
                                res.temp = t;
                                RESULT = res;
                            }
                        :}
                        | expresionAritmetica:izq MENOR_IGUAL expresionAritmetica:der {: 
                            if (!tiposIguales(izq, der) || !tipoPermitidoComparacion(izq.tipoDato, "<=")) {
                                System.err.println(" -> Error semantico: La comparacion '<=' no es valida entre tipos '" + izq.tipoDato + "' y '" + der.tipoDato + "'." + "Fila: " + izqleft + ", Columna: " + izqright);
                                aumentarCountErroresSemanticos();
                                RESULT = new TipoExpresiones("error");
                            } else {
                                System.out.println("\n Expresion en validacion -> expr rela: menor igual\n");
                                String a1 = operandoString(izq);
                                String a2 = operandoString(der);
                                String t = TAC_Generator.newTemp();
                                // izq.append(der);
                                TAC_Generator.generarCuad ("<=", a1, a2, t);
                                TipoExpresiones res = new TipoExpresiones("boolean");
                                // res.cuads = izq.cuads;
                                res.temp = t;
                                RESULT = res;
                            }
                        :}
                        | expresionAritmetica:izq MAYOR_IGUAL expresionAritmetica:der {: 
                            if (!tiposIguales(izq, der) || !tipoPermitidoComparacion(izq.tipoDato, ">=")) {
                                System.err.println(" -> Error semantico: La comparacion '>=' no es valida entre tipos '" + izq.tipoDato + "' y '" + der.tipoDato + "'." + "Fila: " + izqleft + ", Columna: " + izqright);
                                aumentarCountErroresSemanticos();
                                RESULT = new TipoExpresiones("error");
                            } else {
                                System.out.println("\n Expresion en validacion -> expr rela: mayor igual\n");
                                String a1 = operandoString(izq);
                                String a2 = operandoString(der);
                                String t = TAC_Generator.newTemp();
                                // izq.append(der);
                                TAC_Generator.generarCuad (">=", a1, a2, t);
                                TipoExpresiones res = new TipoExpresiones("boolean");
                                // res.cuads = izq.cuads;
                                res.temp = t;
                                RESULT = res;
                            }
                        :}
                      | expresionAritmetica:expr {: RESULT = expr; System.out.println("\n Expresion en validacion -> expre rela: expr arit" + "Tipo final:" + expr.getTipo() + "\n"); :};
                      //| PAREN_I expresion:expr PAREN_D {: RESULT = expr; System.out.println("\n Expresion en validacion -> expre rela: parentesis" + "Tipo final:" + expr.getTipo() + "\n"); :}; /* Con esta en teoria deberia de volver a arriba. */



expresionChar ::= CHAR_LITERAL:charLi {: 
                    RESULT = new TipoExpresiones("char", charLi); 
                :};

expresionString ::= STRING_LITERAL:strLit {: 
                    RESULT = new TipoExpresiones("string", strLit); 
                :};

expresionBooleana ::= TRUE{: 
                        RESULT = new TipoExpresiones("boolean", Boolean.TRUE); 
                    :}
                    | FALSE {: 
                        RESULT = new TipoExpresiones("boolean", Boolean.FALSE); 
                    :};


/* >> Expresiones aritmeticas */

expresionAritmetica ::= expresionSuma:expr {: RESULT = expr; System.out.println("\n Expresion en validacion -> expr arit: inicip expr arit " + "Tipo final:" + expr.getTipo() + "\n");  :};


expresionSuma ::= expresionSuma:izq MAS expresionProducto:der {:
                    if (!tiposIgualesNumericos(izq, der)) {
                        System.err.println("Error semantico: La suma requiere tipos numericos iguales (int o float) valor. Fila: " + izqleft + ", Columna: " + izqright);
                        RESULT = new TipoExpresiones("error");
                    } else {
                        System.out.println("\n Expresion en validacion -> expr suma: suma\n");
                        if (izq == null || der == null) {
                            RESULT = new TipoExpresiones("error");
                            aumentarCountErroresSemanticos();
                        } else if ("error".equals(izq.getTipo()) || "error".equals(der.getTipo())) {
                            RESULT = new TipoExpresiones("error");
                        } else {
                            String tipoResultado = "int";
                            if ("float".equals(izq.getTipo()) || "float".equals(der.getTipo())) {
                                tipoResultado = "float";
                            }

                            String a1 = izq.temp != null ? izq.temp : (izq.valorI != null ? izq.valorI.toString() : (izq.valorF != null ? izq.valorF.toString() : izq.valorS));
                            String a2 = der.temp != null ? der.temp : (der.valorI != null ? der.valorI.toString() : (der.valorF != null ? der.valorF.toString() : der.valorS));

                            if (a1 == null){
                                a1 = "null";
                            }

                            if (a2 == null){
                                a2 = "null";
                            }

                            String t = TAC_Generator.newTemp();
                            izq.append(der);
                            TAC_Generator.generarCuad ("+", a1, a2, t);

                            TipoExpresiones res = new TipoExpresiones (tipoResultado);
                            res.temp = t;
                            RESULT = res;
                        }
                    }
                :}
                | expresionSuma:izq MENOS expresionProducto:der {: 
                        if (!tiposIgualesNumericos(izq, der)) {
                            System.err.println(" -> Error semantico: La resta requiere tipos numericos iguales (int o float). Fila: " + izqleft + ", Columna: " + izqright);
                            aumentarCountErroresSemanticos();
                            RESULT = new TipoExpresiones("error");
                        } else {
                            System.out.println("\n Expresion en validacion -> expr suma: resta\n");
                            if (izq == null || der == null) {
                                RESULT = new TipoExpresiones("error");
                            } else if ("error".equals(izq.getTipo()) || "error".equals(der.getTipo())) {
                                RESULT = new TipoExpresiones("error");
                            } else {
                                String tipoResultado = "int";
                                if ("float".equals(izq.getTipo()) || "float".equals(der.getTipo())) {
                                    tipoResultado = "float";
                                }

                                String a1 = izq.temp != null ? izq.temp : (izq.valorI != null ? izq.valorI.toString() : (izq.valorF != null ? izq.valorF.toString() : izq.valorS));
                                String a2 = der.temp != null ? der.temp : (der.valorI != null ? der.valorI.toString() : (der.valorF != null ? der.valorF.toString() : der.valorS));

                                if (a1 == null){
                                    a1 = "null";
                                }

                                if (a2 == null){
                                    a2 = "null";
                                }

                                String t = TAC_Generator.newTemp();
                                izq.append(der);
                                TAC_Generator.generarCuad ("-", a1, a2, t);

                                TipoExpresiones res = new TipoExpresiones (tipoResultado);
                                res.temp = t;
                                RESULT = res;
                            }
                        }
                    :}
                | expresionProducto:expr {: RESULT = expr; System.out.println("\n Expresion en validacion -> expr suma: expr prod \n"); :}
                | expresionSuma MAS error {: System.err.println(" -> Error: Expresion no valida despues de '+'"); RESULT = new TipoExpresiones("error"); :}
                | expresionSuma MENOS error {: System.err.println(" -> Error: Expresion no valida despues de '-'"); RESULT = new TipoExpresiones("error"); :};

expresionProducto ::= expresionProducto:izq MULTIPLICACION expresionPotencia:der {:
                    if (!tiposIgualesNumericos(izq, der)) {
                        System.err.println(" -> Error semantico: La multiplicacion requiere tipos numericos iguales (int o float). Fila: " + izqleft + ", Columna: " + izqright);
                        aumentarCountErroresSemanticos();
                        RESULT = new TipoExpresiones("error");
                    } else {
                        if (izq == null || der == null) {
                            RESULT = new TipoExpresiones ("error");
                        } else if ("error".equals(izq.getTipo()) || "error".equals(der.getTipo())) {
                            RESULT = new TipoExpresiones("error");
                        } else {
                            String tipoResultado = "int";
                            if ("float".equals(izq.getTipo()) || "float".equals(der.getTipo())) {
                                tipoResultado = "float";
                            }

                            String a1 = izq.temp != null ? izq.temp : (izq.valorI != null ? izq.valorI.toString() : (izq.valorF != null ? izq.valorF.toString() : izq.valorS));
                            String a2 = der.temp != null ? der.temp : (der.valorI != null ? der.valorI.toString() : (der.valorF != null ? der.valorF.toString() : der.valorS));

                            if (a1 == null){
                                a1 = "null";
                            }

                            if (a2 == null){
                                a2 = "null";
                            }

                            String t = TAC_Generator.newTemp();
                            TAC_Generator.generarCuad ("*", a1, a2, t);

                            TipoExpresiones res = new TipoExpresiones (tipoResultado);
                            res.temp = t;
                            RESULT = res;
                        }
                    }
                    :}
                    | expresionProducto:izq DIVISION expresionPotencia:der {: 
                        if (!tiposIgualesNumericos(izq, der)) {
                            System.err.println(" -> Error semantico: La division requiere tipos numericos iguales (int o float). Fila: " + izqleft + ", Columna: " + izqright);
                            aumentarCountErroresSemanticos();
                            RESULT = new TipoExpresiones("error");
                        } else {
                            System.out.println("\n Expresion en validacion -> expr prod div entera \n");
                            String a1 = izq.temp != null ? izq.temp : (izq.valorI != null ? izq.valorI.toString() : (izq.valorF != null ? izq.valorF.toString() : izq.valorS));
                            String a2 = der.temp != null ? der.temp : (der.valorI != null ? der.valorI.toString() : (der.valorF != null ? der.valorF.toString() : der.valorS));
                            if (a1 == null) a1 = "null";
                            if (a2 == null) a2 = "null";
                            String t = TAC_Generator.newTemp();
                            izq.append(der);
                            TAC_Generator.generarCuad("/", a1, a2, t);
                            TipoExpresiones res = new TipoExpresiones("float");
                            res.cuads = izq.cuads;
                            res.temp = t;
                            RESULT = res;
                        }
                    :}
                    | expresionProducto:izq DIVISION_ENTERA expresionPotencia:der {: 
                        if (!"int".equals(izq.tipoDato) || !"int".equals(der.tipoDato)) {
                            System.err.println(" -> Error semantico: La division entera solo se permite entre enteros. Fila: " + izqleft + ", Columna: " + izqright);
                            aumentarCountErroresSemanticos();
                            RESULT = new TipoExpresiones("error");
                        } else {
                            System.out.println("\n Expresion en validacion -> expr prod div entera \n");
                            String a1 = izq.temp != null ? izq.temp : (izq.valorI != null ? izq.valorI.toString() : (izq.valorF != null ? izq.valorF.toString() : izq.valorS));
                            String a2 = der.temp != null ? der.temp : (der.valorI != null ? der.valorI.toString() : (der.valorF != null ? der.valorF.toString() : der.valorS));
                            if (a1 == null) a1 = "null";
                            if (a2 == null) a2 = "null";
                            String t = TAC_Generator.newTemp();
                            izq.append(der);
                            TAC_Generator.generarCuad("//", a1, a2, t);
                            TipoExpresiones res = new TipoExpresiones("int");
                            res.cuads = izq.cuads;
                            res.temp = t;
                            RESULT = res;
                        }
                    :}
                    | expresionProducto:izq MODULO expresionPotencia:der {: 
                        if (!"int".equals(izq.tipoDato) || !"int".equals(der.tipoDato)) {
                            System.err.println(" -> Error semantico: El modulo solo se permite entre enteros. Fila: " + izqleft + ", Columna: " + izqright);
                            aumentarCountErroresSemanticos();
                            RESULT = new TipoExpresiones("error");
                        } else {
                            System.out.println("\n Expresion en validacion -> expr prod modulo \n");
                            String a1 = izq.temp != null ? izq.temp : (izq.valorI != null ? izq.valorI.toString() : (izq.valorF != null ? izq.valorF.toString() : izq.valorS));
                            String a2 = der.temp != null ? der.temp : (der.valorI != null ? der.valorI.toString() : (der.valorF != null ? der.valorF.toString() : der.valorS));
                            if (a1 == null) a1 = "null";
                            if (a2 == null) a2 = "null";
                            String t = TAC_Generator.newTemp();
                            izq.append(der);
                            TAC_Generator.generarCuad("%", a1, a2, t);
                            TipoExpresiones res = new TipoExpresiones("int");
                            res.cuads = izq.cuads;
                            res.temp = t;
                            RESULT = res;
                        }
                    :}
                    | expresionPotencia:expr {: RESULT = expr; System.out.println("\n Expresion en validacion -> expr prod exp poten\n"); :};


// Para este hay que validar si el exponente y la base son enteros y solo enteros.
expresionPotencia ::= expresionFactor:base POTENCIA expresionPotencia:exp {: 
                    if (base == null || exp == null || "error".equals(base.getTipo()) || "error".equals(exp.getTipo())) {
                        RESULT = new TipoExpresiones("error");
                        System.err.println(" -> Error semantico: Las potentencia debe de ser base int o float y el exponente debe ser int. Tipos definidos: Base -> '" + base.tipoDato + "' y Exponente -> '" + exp.tipoDato + "'." + "Linea: " + baseleft + ", Columna: " + baseright);
                        aumentarCountErroresSemanticos();
                    } else {
                        System.out.println("\n Expresion en validacion -> expr prod potencia \n");
                        String a1 = base.temp != null ? base.temp : (base.valorI != null ? base.valorI.toString() : (base.valorF != null ? base.valorF.toString() : base.valorS));
                        String a2 = exp.temp != null ? exp.temp : (exp.valorI != null ? exp.valorI.toString() : (exp.valorF != null ? exp.valorF.toString() : exp.valorS));
                        if (a1 == null) a1 = "null";
                        if (a2 == null) a2 = "null";
                        String t = TAC_Generator.newTemp();
                        base.append(exp);
                        TAC_Generator.generarCuad("^", a1, a2, t);
                        String tipoFinal = ("float".equals(base.tipoDato) || "float".equals(exp.tipoDato)) ? "float" : "int";
                        TipoExpresiones res = new TipoExpresiones(tipoFinal);
                        res.cuads = base.cuads;
                        res.temp = t;
                        RESULT = res;
                    }
                    :}
                    | expresionFactor:expr {: RESULT = expr; System.out.println("\n Expresion en validacion -> po expr fac\n"); :};


expresionFactor ::= PAREN_I expresion:expr PAREN_D {: RESULT = expr; System.out.println("\n Expresion en validacion -> expresionFactor: paren expr \n"); :}
                  | expresionNumerica:expr {: RESULT = expr; System.out.println("\n Expresion en validacion -> fac exp num \n"); :}
                  | expresionAritmeticaUnaria:expr {: RESULT = expr; System.out.println("\n Expresion en validacion -> fac uni \n"); :}
                  | expresionAritmeticaUnariaNegativa:expr {: RESULT = expr; System.out.println("\n Expresion en validacion -> facuni nega \n"); :};
                //   | error {: System.err.println("Error: Expresion aritmetica no valida"); :};

expresionNumerica ::= INT_LITERAL:n {: 
                        RESULT = new TipoExpresiones("int", n); 
                        System.out.println("\n Expresion en validacion -> num int \n"); 
                        
                        :}
                    | FLOAT_LITERAL:f  {: RESULT = new TipoExpresiones("float", f); System.out.println("\n Expresion en validacion -> num flo \n"); :}
                    | IDENTIFICADOR:id {: 
                        // Pruebas TAC:
                        Token t = entornoActual != null ? entornoActual.buscar (id) : null;
                        if (t == null) {
                            System.err.println("Error semantico: El identificador '" + id + "' no ha sido declarado. Fila: " + idleft + ", Columna: " + idright);
                            RESULT = new TipoExpresiones("error");
                        } else {
                            TipoExpresiones te = new TipoExpresiones (t.getTipo());
                            te.temp = id;
                            RESULT = te;
                        }
                        // RESULT = obtenerTipoIdentificador(id); 
                        System.out.println("\n Expresion en validacion -> num id \n");
                        // RESULT = te;
                    :}
                    | funcionLlamada:func {: 
                        RESULT = obtenerTipoFuncion(funcionActual); 
                        System.out.println("\n Expresion en validacion -> num func\n");
                    :}
                    | obtenerElementoLista:ob {: 
                        // RESULT = obtenerTipoElementoLista(ob); 
                        RESULT = ob;//new TipoExpresiones("int"); //>> Esta se tiene que arrglar para que funcione con la funcion que deberia.
                        :}
                    | input:inp {: RESULT = new TipoExpresiones(inp); System.out.println("\n Expresion en validacion -> elemento lista\n");:}

                    // Esta parte es para intentar olucionar los problemas:
                    | expresionChar:charExp {: 
                        // if (!validarTipoEsperado("int|float", charExp)) {
                        //     System.err.println("Error semantico: tipo '" + charExp.tipoDato + "' no valido en expresion numerica.");
                        // }
                        System.out.println("\n Expresion en validacion -> char \n");
                        RESULT = charExp;
                    :}
                    | expresionString:strExp {: 
                        // if (!validarTipoEsperado("int|float", strExp)) {
                        //     System.err.println("Error semantico: tipo '" + strExp.tipoDato + "' no valido en expresion numerica.");
                        // }
                        RESULT = strExp;
                        System.out.println("\n Expresion en validacion -> String\n");
                    :}
                    | expresionBooleana:boolExp {: 
                        // if (!validarTipoEsperado("int|float", boolExp)) {
                        //     System.err.println("Error semantico: tipo '" + boolExp.tipoDato + "' no valido en expresion numerica.");
                        // }
                        RESULT = boolExp;
                        System.out.println("\n Expresion en validacion -> expr booneana\n");
                    :}

                    | INT_LITERAL:n IDENTIFICADOR error
                      {: System.err.println(" -> Error: Numero seguido de identificador no es valido (ej: 2f5)"); RESULT = new TipoExpresiones("erro",n);:}
                    | FLOAT_LITERAL:n IDENTIFICADOR error
                      {: System.err.println(" -> Error: Numero flotante seguido de identificador no es valido"); RESULT = new TipoExpresiones("error", n); :}; 
                    // Fin de la expresion.



// Faltan trabajar estas para que se validen semanticamente.
expresionAritmeticaUnaria ::= IDENTIFICADOR:id INCREMENTO {:
                                TipoExpresiones tipo = obtenerTipoIdentificador(id);
                                System.out.println("Tipo obtenido para id '" + id + "': " + tipo.tipoDato);
                                if (!validarTipoEsperado("int|float", tipo)) {
                                    System.err.println(" -> Error semantico: El operador '++' no es valido para tipo '" + tipo.tipoDato + "'." + "Linea: " + idleft + ", Columna: " + idright);
                                    aumentarCountErroresSemanticos();
                                    RESULT = new TipoExpresiones("error");
                                } else {
                                    // Depende del tipo int o float se genera cuad diferente
                                    System.out.println("\n Expresion en validacion -> Unaria incremento.\n");
                                    TipoExpresiones res = new TipoExpresiones(tipo.tipoDato); 
                                    String a1 = id; // el identificador como operando
                                    String t = TAC_Generator.newTemp();
                                    TAC_Generator.generarCuadUnario("++", a1, t, tipo.tipoDato);
                                    res.temp = t;
                                    RESULT = res;
                                }
                            :}
                            | IDENTIFICADOR:id DECREMENTO {:
                                TipoExpresiones tipo = obtenerTipoIdentificador(id);
                                if (!validarTipoEsperado("int|float", tipo)) {
                                    System.err.println(" -> Error semantico: El operador '--' no es valido para tipo '" + tipo.tipoDato + "'." + "Linea: " + idleft + ", Columna: " + idright);
                                    aumentarCountErroresSemanticos();
                                    RESULT = new TipoExpresiones("error");
                                } else {
                                    RESULT = tipo;
                                    System.out.println("\n Expresion en validacion -> Unaria decremento. \n");
                                    TipoExpresiones res = new TipoExpresiones(tipo.tipoDato); 
                                    String a1 = id; // el identificador como operando
                                    String t = TAC_Generator.newTemp();
                                    TAC_Generator.generarCuadUnario("--", a1, t, tipo.tipoDato);
                                    res.temp = t;
                                    RESULT = res;
                                }
                            :};

expresionAritmeticaUnariaNegativa ::= MENOS expresionNumerica:expr {: 
                                        if (!validarTipoEsperado("int|float", expr) || expr == null || "error".equals(expr.getTipo())) {
                                            System.err.println(" -> Error semantico: operador para pasar a negativo una operacion no es valido para tipo '" + expr.tipoDato + "''." + "Linea: " + exprleft + ", Columna: " + exprright);
                                            aumentarCountErroresSemanticos();
                                            RESULT = new TipoExpresiones("error");
                                        } else {
                                            System.out.println("\n Expresion en validacion -> Unaria negativa.\n");
                                            // El argumento es número (int o float)
                                            String a1 = expr.temp != null ? expr.temp : (expr.valorI != null ? expr.valorI.toString() : (expr.valorF != null ? expr.valorF.toString() : expr.valorS));
                                            if (a1 == null) {
                                                a1 = "null";
                                            }
                                            String t = TAC_Generator.newTemp();
                                            TAC_Generator.generarCuadUnario ("NEG", a1, t, expr.tipoDato); // voy a ver como manejo la negacion en representacion TAC
                                            TipoExpresiones res = new TipoExpresiones(expr.tipoDato);
                                            res.cuads = expr.cuads;
                                            res.temp = t;
                                            RESULT = res;
                                        }
                                    :};


/* ##### Seccion para el manejo de listas ######*/
lista ::= declaracionLista
        | creacionYAsignacionLista;

declaracionLista ::= LET tipoLista:tipo IDENTIFICADOR:id DELIMITADOR {: 
                    if (entornoActual.buscar(id) != null) {
                        System.err.println(" -> Error semantico: la lista '" + id + "' ya fue declarada. Fila: " + idleft + ", Columna: " + idright);
                        aumentarCountErroresSemanticos();
                    } else {
                        // nombre, tipoBase, ambito, valor, categoria, linea, columna
                        Token tokenLista = new Token(id, tipo.tipoBase, "local", null, "lista", idleft, idright);
                        tokenLista.setTipoLista(tipo);
                        insertarNuevoToken(tokenLista);
                    }
                :};

creacionYAsignacionLista ::= LET tipoLista:tipo IDENTIFICADOR:id ASIGNACION LLAVE_I elementos:elems LLAVE_D DELIMITADOR {: 
                                if (entornoActual.buscar(id) != null) {
                                    System.err.println(" -> Error semantico: La lista '" + id + "' ya fue declarada. Fila: " + idleft + ", Columna: " + idright);
                                    aumentarCountErroresSemanticos();
                                
                                } else if (!elems.tipoDato.equals(tipo.tipoBase)) {
                                    System.err.println(" -> Error semantico: Los elementos de la lista '" + id + "' no coinciden con el tipo declarado. Se esperaba '" + tipo.tipoBase + "', pero se recibio '" + elems.tipoDato + "'. Fila: " + idleft + ", Columna: " + idright);
                                    aumentarCountErroresSemanticos();
                                } else if (tipo.tamano != null && elems.tamano > tipo.tamano) {
                                    System.err.println(" -> Error semantico: La lista '" + id + "' excede el tamaño declarado. Se esperaba maximo " + tipo.tamano + " elementos, pero se recibieron " + elems.tamano + ". Fila: " + idleft + ", Columna: " + idright);
                                    aumentarCountErroresSemanticos();
                                } else {
                                    Token tokenLista = new Token(id, tipo.tipoBase, "local", null, "lista", idleft, idright);
                                    tipo.setTamano(elems.tamano); // Modificamos el tamaño de la lista por si la definieron como []
                                    tokenLista.setTipoLista(tipo);
                                    insertarNuevoToken(tokenLista);
                                }
                            :};

elementos ::= elementoLista:elem {: 
                // Primer elemento: inicializamos la lista de tipos
                List<String> tipos = new ArrayList<>();
                tipos.add(elem.tipoDato);
                RESULT = new TipoExpresiones(elem.tipoDato, tipos, 1);
            :}
            | elementos:lst COMA elementoLista:elem {: 
                if (!lst.tipoDato.equals(elem.tipoDato)) { 
                    System.err.println(" -> Error semantico: Todos los elementos de la lista deben ser del mismo tipo. Se esperaba '" + lst.tipoDato + "', pero se recibio '" + elem.tipoDato + "'. Fila: " + elemleft + ", Columna: " + elemright);
                    aumentarCountErroresSemanticos();
                    RESULT = new TipoExpresiones("error");
                } else {
                    lst.tipos.add(elem.tipoDato);
                    lst.tamano++;
                    RESULT = lst;
                }
            :};


/* Este deberia ser expresion aritmetica en ves de -> INT_LITERAL*/
elementoLista ::= expresionAritmetica:op {: 
                    // Guardamos cada uno de los elementos de la lista.
                    List<String> tipos = new ArrayList<>();
                    tipos.add(op.tipoDato);
                    RESULT = new TipoExpresiones(op.tipoDato, tipos, 1); 
                :}; /* Este deberia ser expresion aritmetica en ves de -> INT_LITERAL*/

/* FIX: El elemento en lista deberia poder permitir identificadores validos*/
modificarElementoLista ::= IDENTIFICADOR:id CORCHETE_I expresionAritmetica:indice CORCHETE_D ASIGNACION elementoLista:elem DELIMITADOR {: 
                                Token token = entornoActual.buscar(id);
                                if (token == null) {

                                    System.err.println(" -> Error semantico: La lista '" + id + "' no ha sido declarada. Fila: " + idleft + ", Columna: " + idright);
                                    aumentarCountErroresSemanticos();
                                    RESULT = new TipoExpresiones("error");

                                } else if (!"lista".equals(token.getCategoria())) {
                                    System.err.println(" -> Error semantico: el identificador '" + id + "' no corresponde a una lista. Fila: " + idleft + ", Columna: " + idright);
                                    aumentarCountErroresSemanticos();
                                    RESULT = new TipoExpresiones("error");
                                    
                                } else if (!"int".equals(indice.tipoDato)) {
                                    System.err.println(" -> Error semantico: El indice de la lista '" + id + "' debe ser de tipo int, pero se recibio '" + indice.tipoDato + "'. Fila: " + idleft + ", Columna: " + idright);
                                    aumentarCountErroresSemanticos();
                                    RESULT = new TipoExpresiones("error");

                                } else {
                                    TipoLista tipoLista = token.getTipoLista();
                                    Integer tamano = tipoLista.tamano;

                                    // Validacion de rango
                                    // if (tamano != null && (indice.valor < 0 || indice.valor >= tamano)) {
                                    //     System.err.println("Error semantico: El indice " + indice.valor + " esta fuera del rango de la lista '" + id + "'. Tamano maximo: " + (tamano-1));
                                    //     RESULT = new TipoExpresiones("error");} else

                                    if (!elem.tipoDato.equals(tipoLista.tipoBase)) {
                                        System.err.println(" _> Error semantico: El tipo del elemento asignado no coincide con el tipo base de la lista '" + id + "'. Se esperaba '" + tipoLista.tipoBase + "', pero se recibio '" + elem.tipoDato + "'.");
                                        aumentarCountErroresSemanticos();
                                        RESULT = new TipoExpresiones("error");

                                    } else {
                                        // Asignacion valida
                                        RESULT = new TipoExpresiones(tipoLista.tipoBase);
                                    }
                                }
                            :}
                         | error CORCHETE_I expresionAritmetica CORCHETE_D ASIGNACION elementoLista DELIMITADOR {: System.err.println("Error: Nombre de lista no valido"); RESULT = new TipoExpresiones("error"); :};

obtenerElementoLista ::= IDENTIFICADOR:id CORCHETE_I expresionAritmetica:op CORCHETE_D {: 
                                Token token = entornoActual.buscar(id);
                                if (token == null) {
                                    System.err.println(" -> Error semantico: lLa lista '" + id + "' no ha sido declarada. Fila: " + idleft + ", Columna: " + idright);
                                    aumentarCountErroresSemanticos();
                                    RESULT = new TipoExpresiones("error");

                                } else if (!"lista".equals(token.getCategoria())) {
                                    System.err.println(" -> Error semantico: El identificador '" + id + "' no corresponde a una lista. Fila: " + idleft + ", Columna: " + idright);
                                    aumentarCountErroresSemanticos();
                                    RESULT = new TipoExpresiones("error");

                                } else if (!"int".equals(op.tipoDato)) {
                                    System.err.println(" -> Error semantico: El indice de la lista '" + id + "' debe ser de tipo int, pero se recibio '" + op.tipoDato + "'. Fila: " + idleft + ", Columna: " + idright);
                                    aumentarCountErroresSemanticos();
                                    RESULT = new TipoExpresiones("error");

                                } else {
                                    TipoLista tipoLista = token.getTipoLista();
                                    Integer tamano = tipoLista.tamano;

                                    // Validacion de rango
                                    // if (tamano != null && (op.valor < 0 || op.valor >= tamano)) {
                                    //     System.err.println("Error semantico: El indice " + op.valor + " esta fuera del rango de la lista '" + id + "'. Tamano maximo: " + (tamano - 1));
                                    //     RESULT = new TipoExpresiones("error");

                                    // } else {
                                        // Propagar el tipo base de la lista
                                        RESULT = new TipoExpresiones(tipoLista.tipoBase);
                                    // }
                                }
                            :}
                        | error CORCHETE_I expresionAritmetica CORCHETE_D {: System.err.println(" -> Error: Nombre de lista no valido"); RESULT = new TipoExpresiones("error"); :};

tipoLista ::= INT CORCHETE_I CORCHETE_D {: 
                TipoLista tipoL = new TipoLista("int", null);
                RESULT = tipoL;
            :}
           | CHAR CORCHETE_I CORCHETE_D {: 
                TipoLista tipoL = new TipoLista("char", null);
                RESULT = tipoL;
            :}

            // Aqui hay que agregar algo para validar que el numero sea un entero positivo mayor que cero.
           | INT CORCHETE_I INT_LITERAL:num CORCHETE_D {: 
                int tama = num;
                TipoLista tipoL = new TipoLista("int", tama);
                RESULT = tipoL;
            :}
           | CHAR CORCHETE_I INT_LITERAL:num CORCHETE_D {: 
                int tama = num;
                TipoLista tipoL = new TipoLista("char", tama);
                RESULT = tipoL;
            :};


