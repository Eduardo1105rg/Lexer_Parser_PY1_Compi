/* Definicion del pasers con CUP para el analisis de la gramatica.  */

/* Imports que se ocupan */
package parser;

import java_cup.runtime.*;
import lexer.*;
import java.io.*;
import lexer.Lexer;

// Estos serian para la parte del manejo de la tabla de simbolos.
import java.util.HashMap;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;

// Import las clases necesarias para la tabla de simbolos.
import simbolos.Token;
import simbolos.Ambitos;
import simbolos.TipoLista;


/* Parsers */
parser code {:
    private int errorContador = 0;

    public int getErrorContador() {
        return errorContador;
    }

    public void syntax_error(Symbol cur_token) {
        errorContador++;
        String tokenInfo = obtenerInfoToken(cur_token);
        System.err.println("Error sintactico en linea " + cur_token.left + 
                          ", columna " + cur_token.right + ": " + tokenInfo);
    }
    // Mapeo de tokens a mensajes claros para debugueo
    private String obtenerInfoToken(Symbol token) {
        switch (token.sym) {
            case sym.IDENTIFICADOR:
                return "Se encontro identificador inesperado: '" + token.value + "'";
            case sym.INT_LITERAL:
                return "Se encontro numero entero inesperado: '" + token.value + "'";
            case sym.FLOAT_LITERAL:
                return "Se encontro numero flotante inesperado: '" + token.value + "'";
            case sym.STRING_LITERAL:
                return "Se encontro texto inesperado";
            case sym.CHAR_LITERAL:
                return "Se encontro caracter inesperado";
            case sym.ASIGNACION:
                return "Se encontro '=' inesperado";
            case sym.DELIMITADOR:
                return "Se encontro '$' inesperado";
            case sym.EOF:
                return "Final de archivo inesperado";
            default:
                return "Token inesperado: " + token.value;
        }
    }

    public void report_error(String message, Object info) {
    }

    public void unrecovered_syntax_error(Symbol cur_token) {
        System.err.println("Error sintactico irrecuperable en linea " + cur_token.left + 
                          ", columna " + cur_token.right + ": No se puede continuar el analisis");
    }




  // El profe tiene esto en el codigo de el, me parece que es para hacer la sobrecarga, pero no s epara que llama al lexer.


  // Lexer lexer;

  // public Parser (Lexer lexer) {
  //   this.lexer = lexer;
  //   this.symbolFactory = new DefaultSymbolFactory();
  // }


:};

/* Aqui vamos a definir lo que se va a ejecutar al reducir una produccion o algo asi. (Es diferente del 'parser code')*/
action code {: // Esta parte podria ir en un archivo aparte, pero probemoslo asi de momento.

  // Esta es basicamente todo el manejo de la tabla de simbolos y asi definir su alcance por ambitos.
  Ambitos entornoActual = null;

  {
    entornoActual = new Ambitos(null); // Ambito raiz, este es el inicial, el que contiene a los demas, aqui estan las globales y todas las funciones.
  }

  Token funcionActual; // Para trabajar lo que es el analisis semantico de la llamada a funciones.


  // Crear un nuevo ambito y asigarle a lo anterior el que ya estabamos trabajando. [Este esta mas pensado para lo que pase dentro de BLOQUE]
  public void crearAmbito() {
      entornoActual = new Ambitos(entornoActual);
  }

  // Este seria para generar ambitos de funciones.
  public void crearAmbitoFuncion(String nombreFuncion, String tipo, int linea, int columna) {
      // Registrar la función como simbolo en el entorno padre

      Token funcion = new Token(nombreFuncion, tipo, "global", null, "funcion", linea, columna); // Queda mejor hacer el token aqui que en la parte de la produccion directamente.
      entornoActual.insertarNuevoToken(funcion);

      // Crear entorno local para parámetros y variables internas
      entornoActual = new Ambitos(entornoActual);
  }


  // Volver a lo que seria el ambito de mas arriba, el padre por asi decirlo, en algun punto vuelve al punto general del programa.
  public void cerrarAmbito() {
      entornoActual = entornoActual.getAnterior();
  }

  // Ahora se inserta un nuevo simbolo en el ambito en el que estamos.
  public boolean insertarNuevoToken(Token token) {
      return entornoActual.insertarNuevoToken(token);
  }


  // >> Esta seria la seccion para la parte de busquedas.

  // Buscar la existencia de un simbolo especifico en ambito, [Esto deberia de cambiarse para que sean por  especifico para un identificador y especifico para funciones].
  public Token buscarToken(String nombre) {
      return entornoActual.buscar(nombre);
  }

  public Token buscarFuncion(String nombre) {

    for (Ambitos ambito = entornoActual; ambito != null; ambito = ambito.getAnterior()) {
      
        Token token = ambito.buscar(nombre);

        if (token != null && "funcion".equals(token.getCategoria())) {
          return token;
        }
    }
    return null;
  }

  // Mostrar la tabla de simbolos actual.
  public void mostrarTablaActual() {
      System.out.println("Tabla de símbolos actual:");
      for (Token token : entornoActual.getTablaActual().values()) {
          token.mostrarToken();
      }
  }

    // Para buscar el ambito de una funcion especifica.
    public Ambitos buscarAmbitoDeFuncion(String nombre) {
        Ambitos actual = entornoActual;
        while (actual != null) {

            Token token = actual.buscar(nombre);
            if (token != null && "funcion".equals(token.getCategoria())) {
                return actual;
            }

            actual = actual.getAnterior();
        }
        return null;
    }

    // Para obtener los tipos de parametros de una funcion
    public List<String> obtenerTiposParametros(Token funcion) {
        List<String> tipos = new ArrayList<>();
        Ambitos ambitoFuncion = funcion.getAmbitoLocal();
        if (ambitoFuncion == null) return tipos;
        
        for (Token t : ambitoFuncion.getTablaActual().values()) {
            if ("parametro".equals(t.getCategoria())) {
                tipos.add(t.getTipo());
            }
        }
        return tipos;
    }

    public void mostrarTodosLosAmbitos() {
        System.out.println("╔════════════════════════════════════════════════════════════════════════════╗");
        System.out.println("║                    TABLA DE SÍMBOLOS EN TODOS LOS ÁMBITOS                 ║");
        System.out.println("╠════════════════════════════════════════════════════════════════════════════╣");
        System.out.printf("║ %-15s │ %-10s │ %-10s │ %-10s │ %-10s │ %-5s │ %-5s ║\n",
                        "Nombre", "Tipo", "Categoría", "Ambito", "Valor", "Linea", "Col");
        System.out.println("╠════════════════════════════════════════════════════════════════════════════╣");

        int nivel = 0;
        for (Ambitos ambito = entornoActual; ambito != null; ambito = ambito.getAnterior()) {
            String nombreAmbito = "Nivel_" + nivel;
            for (Token t : ambito.getTablaActual().values()) {
                System.out.printf("║ %-15s │ %-10s │ %-10s │ %-10s │ %-10s │ %-5d │ %-5d ║\n",
                                t.getNombre(), t.getTipo(), t.getCategoria(),
                                nombreAmbito, String.valueOf(t.getValor()),
                                t.getLinea(), t.getColumna());
            }
            nivel++;
        }

        System.out.println("╚════════════════════════════════════════════════════════════════════════════╝");
    }





:};


// >> El profe tambien define esto. >> De momento lo dejo comentado por que no se para que sirve.
// init with {: :};

// scan with {: return lexer.next_token(); :};




/* Definición de terminales (tokens) */
// Son las palabras reservadas
terminal LET, GLOBAL, VOID, PRINCIPAL, DECIDE, OF, ELSE, END, LOOP, EXIT;
terminal  WHEN,  RETURN, BREAK, INPUT, FOR, STEP, TO, DOWNTO, DO, OUTPUT;
 

// Tipos de datos
terminal String INT, FLOAT, BOOLEAN, CHAR, STRING;

// Literales de los tipos de datos, esta es la representacion en string.
terminal Integer INT_LITERAL;
terminal Double FLOAT_LITERAL;
terminal String STRING_LITERAL;
terminal Character CHAR_LITERAL;
terminal Boolean TRUE, FALSE;

// Identificadores.
terminal String IDENTIFICADOR;

// Operadores aritmeticos
terminal MAS, MENOS, MULTIPLICACION, DIVISION, DIVISION_ENTERA, MODULO, POTENCIA;
terminal INCREMENTO, DECREMENTO;

// Operadores relacionales
terminal IGUAL, DIFERENTE, MENOR_IGUAL, MAYOR_IGUAL, MENOR, MAYOR;

// Operadores logicos
terminal AND, OR, NOT;

// Asignacion
terminal ASIGNACION;

// Delimitadores y separadores
terminal DELIMITADOR, COMA;
terminal PAREN_I, PAREN_D,CORCHETE_I, CORCHETE_D, LLAVE_I, LLAVE_D;

// La flecha para los if y el concatenador de los prints.
terminal FLECHA, CONCATENACION_OUTPUT;

// Terminar para la deficion de errores lexicos.
terminal ERROR;

// Nuevos elementos agregados para el PY 2.

terminal LISTA;
terminal ARGUMENTOS;


// --------- Fin elementos nuevos.



/* -------------->>>> Seccion para los no terminales */

/* >> Estructura general*/
non terminal programa, principal, funciones, funcion, params, param;

/* >> Tipos de datos: A estos se les agrega que sean String para que sea mas facil trabajarles la parte semanatica. */
non terminal String tipoDatoFuncion, tipoDatoVariable;

/* >> Sentencias y bloques */
non terminal bloque, sentencias, sentencia;

/* >> Declaraciones y variables */
non terminal var, varAsignacion, varCyAsignacion, varGlobal;

/* >> Expresiones  */

non terminal expresion;

/* > Numericas */
non terminal expresionNumerica, expresionSuma, expresionProducto, expresionPotencia, expresionFactor, expresionAritmeticaUnaria, expresionAritmeticaUnariaNegativa;

/* > Boolenas  */
non terminal expresionBooleana;

/* > Literales */
non terminal  expresionChar, expresionString;

/* > Expresiones compuestas */
non terminal expresionAritmetica, expresionLogica, expresionRelacional;

/* >> Control de flujo */
non terminal estructruraControl, decide, condicion, loop, for;

/* >> Funciones y sus llamadas  */
non terminal funcionLlamada, argumentos, return, break;

/* Aqui estoy poniendo los no terminales que estan faltando */
non terminal  tipoDatoInput, condiciones, listaFunciones;


/* >> Input y ouput */
non terminal input, output, output_inline;

/* >> Listas */
non terminal lista, declaracionLista, creacionYAsignacionLista, elementos, elementoLista, modificarElementoLista, obtenerElementoLista;


// Esta son las nuevas declaraciones: 
non terminal principalParteIzquierda, funcionParteIzquierda, bloqueInicio, funcionLlamadaInicio;

non terminal String tipoDatoParametro; // Le definimo String para que sea mas facil trabajar con lo valores.

non terminal TipoLista tipoLista; // Aqui indicamos que lo que vamos a devolver es un objeto de TipoLista

// --- Fin de declaracion de nuevos no terminales. 



/* Precedencia de operadores (de menor a mayor precedencia) */

// Operadores binarios
precedence left OR;
precedence left AND;
precedence right NOT; 

/* Operadores booleanos y relacionales */
precedence left IGUAL, DIFERENTE;
precedence left MENOR, MAYOR, MENOR_IGUAL, MAYOR_IGUAL;

/* Operadores aritmeticos */
precedence left MAS, MENOS;
precedence left MULTIPLICACION, DIVISION, DIVISION_ENTERA, MODULO;
precedence right POTENCIA;

// Operadores unarios
precedence left INCREMENTO, DECREMENTO;
precedence right MENOS; /* Pasar a negativo: Revisar la gramatica original para una posible correccion. */


/* Precedencia para resolver conflictos */
precedence left COMA;
precedence right ASIGNACION;


/* expect 6; Esto es para decirle a cup qie espere hasta 6 congliuctos y que los acepte */

/* Esta es la que dice como se inicia todo. */
start with programa;



/* -------------------------  >> Definicion << -------------------------------------------------------------------  */


/* Producciones generales */
/* FIX: La estructura del principal está como opcional, debe de ser obligatorio y al final (por diseño) */
/* FIXED: Se arreglo la estructura para que siempre haya un bloque principal */
programa ::= varGlobal programa
           | funciones principal  
           | principal
           | error programa {: System.err.println("Error: Declaracion global o funcion no valida"); :};

principalParteIzquierda ::= VOID PRINCIPAL PAREN_I PAREN_D {: 
                            crearAmbito(); // entorno local para principal
                        :};

principal ::= principalParteIzquierda bloque {: 
              cerrarAmbito(); // cerramos entorno de principal
          :};

// Se le agrega el result para que las producciones sepan mejor el valor semantico que van a tener.
tipoDatoFuncion ::= INT {: RESULT = "int"; :}
                  | FLOAT {: RESULT = "float"; :}
                  | BOOLEAN {: RESULT = "boolean"; :};

tipoDatoVariable ::= INT {: RESULT = "int"; :}
                  | FLOAT {: RESULT = "float"; :}
                  | BOOLEAN {: RESULT = "boolean"; :}
                  | CHAR {: RESULT = "char"; :}
                  | STRING {: RESULT = "string"; :}
                   | error {: System.err.println("Error: tipo de variable debe ser int, float, boolean, char o string"); :};



/* Esta modificacion es para intentar resolver el conflicto de funcion */
funciones ::= listaFunciones;

listaFunciones ::= funcion
                 | listaFunciones funcion;


// Para esta porte de las funciones, las dividimos en parte izquierda y parte derecha para que sea mas facil el analisis.
funcionParteIzquierda ::= tipoDatoFuncion:tipo IDENTIFICADOR:ID PAREN_I  {: 
                        Token funcion = new Token(ID, tipo, "global", null, "funcion", IDleft, IDright);
                        if (!insertarNuevoToken(funcion)) {
                            System.err.println("Error semantico: funcion '" + ID + "' ya declarada.");
                        }

                        crearAmbito(); // Crear el ambito local de una funcion, esto antes de que se cree el bloque.
                        funcion.setAmbitoLocal(entornoActual);
                      :}; // Fin de produccion.
  


// Funciones en la parte derecha.
funcion ::= funcionParteIzquierda params PAREN_D bloque {: 
            cerrarAmbito(); // Cerramos el ambito local de una funcion.
        :}
        | PAREN_D bloque {: cerrarAmbito(); :}; // Fin de produccion.


// >>>>>>>>>>Parte de los parametros de una funcion
params ::= param
         | params COMA param
         | error COMA param{: System.err.println("Error: No puede haber una (,) sola al inicio de los parametros."); :};

// Definirle el valos de formas mas explicita para que puedan ser leidos.
tipoDatoParametro ::= INT {: RESULT = "int"; :}
                    | FLOAT {: RESULT = "float"; :}
                    | BOOLEAN {: RESULT = "boolean"; :}
                    | CHAR {: RESULT = "char"; :}
                    | STRING {: RESULT = "string"; :};
                    // | tipoLista {: RESULT = new Symbol(sym.LISTA, "lista"); :}; // Este se tiene que mover ya que no dejara trabajar con lo del semantico

param ::= tipoDatoParametro:tipo IDENTIFICADOR:ID {: 
          Token parametro = new Token(ID, tipo, "parametro", null, "parametro", IDleft, IDright);
          if (!insertarNuevoToken(parametro)) {
              System.err.println("Error semantico: parametro '" + ID + "' ya declarado.");
          }
        :}
      | tipoLista:tipo IDENTIFICADOR:ID {: //Despues se tiene que hacer algo para trabajar con lo del tamaño.
          Token parametro = new Token(ID, tipo.tipoBase, "parametro", null, "parametro", IDleft, IDright);
          if (!insertarNuevoToken(parametro)) {
              System.err.println("Error semantico: parametro '" + ID + "' ya declarado.");
          }
        :}
      | error IDENTIFICADOR {: System.err.println("Error: Para los parametros de una funcion se debe de indicar su tipo de dato."); :};


// -------------------------- Seccion del bloque primario de lo que son las funciones.

bloqueInicio ::= LLAVE_I {: 
    crearAmbito(); 
:};

/* Producciones de sentencias y bloques */
bloque ::= bloqueInicio sentencias LLAVE_D {: 
              cerrarAmbito(); 
          :}

          | bloqueInicio LLAVE_D {: 
              cerrarAmbito(); 
          :}

         | error sentencias LLAVE_D {: System.err.println("Error: Los bloques deben de tener una llave de apertura (¿)."); :}
         | error LLAVE_D {: System.err.println("Error: Los bloques deben de tener una llave de apertura (¿). "); :}
         | LLAVE_I sentencias error {: System.err.println("Error: Los bloques deben de tener una llave de cierre (?). "); :};

sentencias ::= sentencia
             | sentencias sentencia;

sentencia ::= var
            | varAsignacion  
            | varCyAsignacion
            | lista
            | estructruraControl
            | funcionLlamada DELIMITADOR
            | return
            | break
            | input DELIMITADOR
            | output DELIMITADOR
            | output_inline DELIMITADOR
            | modificarElementoLista
            | expresionAritmeticaUnaria DELIMITADOR;

/* FIX: El identificador no debe de ser validado, se valida en producción identificador, sino encuentra busca terminal  */
/*FIXED: Eliminando la linea que valida nombre: | error PAREN_I argumentos PAREN_D  {: System.err.println("Error: Nombre de funcion no valido"); :}*/
funcionLlamadaInicio ::= IDENTIFICADOR:ID PAREN_I {: 
                      Token funcion = buscarFuncion(ID);
                      if (funcion == null) {
                          System.err.println("Error semantico: funcion '" + ID + "' no declarada.");
                          funcionActual = null;
                      } else {
                          System.out.println("Llamada a funcion '" + ID + "' valida.");
                          funcionActual = funcion;
                          // Se podria hacer algo para guardar el token y validar sus argumentos luego.
                      }
                  :};
// Para la llamada a una funcion.
funcionLlamada ::= funcionLlamadaInicio argumentos:args PAREN_D {: 

                      if (funcionActual == null) {
                          System.err.println("Error: No se puede validardar los argumentos de la funcion, debido a que la funcion  buscada no esta declarada.");
                          
                      } else {

                        List<String> argumentos = (List<String>) ((Symbol)args).value;
                        List<String> parametrosEsperados = obtenerTiposParametros(funcionActual);

                        if (argumentos.size() != parametrosEsperados.size()) {
                            System.err.println("Error semantico: funcion '" + funcionActual.getNombre() + "' esperaba " + parametrosEsperados.size() + " argumentos, pero recibio " + argumentos.size());
                        } else {
                            for (int i = 0; i < argumentos.size(); i++) {
                                if (!argumentos.get(i).equals(parametrosEsperados.get(i))) {
                                    System.err.println("Error semantico: argumento " + (i+1) + " de funcion '" + funcionActual.getNombre() + "' esperaba tipo '" + parametrosEsperados.get(i) + "', pero recibio '" + argumentos.get(i) + "'");
                                }
                            }
                        }

                      }
                  :}
                 | funcionLlamadaInicio PAREN_D;


argumentos ::= expresion:expr {: 
                  List<String> args = new ArrayList<>();
                  args.add("Prueba_tipo"); // suponiendo que expresion devuelve tipo: ((Symbol)expr).value.toString()
                  RESULT = new Symbol(sym.ARGUMENTOS, args);
              :}
             | argumentos:prev COMA expresion:expr {: 
                  ((List<String>) ((Symbol)prev).value).add("Prueba_tipo"); //((Symbol)expr).value.toString()
                  RESULT = new Symbol(sym.ARGUMENTOS, ((Symbol)prev).value);
              :}
             | error COMA expresion  {: System.err.println("Error: Argumento no valido antes de ','"); :}
             | argumentos COMA error {: System.err.println("Error: Se esperaba expresion despues de ','"); :}
             | argumentos error expresion {: System.err.println("Error: Se esperaba ',' entre argumentos"); :};
             
return ::= RETURN DELIMITADOR
         | RETURN expresion DELIMITADOR
         | RETURN expresion error {: System.err.println("Error: Se esperaba un delimitador '$'"); :}
         | RETURN error {: System.err.println("Error: Se esperaba un delimitador '$'"); :};

break ::= BREAK DELIMITADOR;

/*FIX: Se debe hacer algo para que cuando el cup lea un IDENTIFICADOR -> PAREN_I detecte que es input, no una llamada a función*/
input ::= INPUT PAREN_I tipoDatoInput PAREN_D
        | INPUT PAREN_I error PAREN_D {: System.err.println("Error: Tipo de dato no valido para input, debe ser int o float."); :};

tipoDatoInput ::= INT
                | FLOAT;
            
output ::= output_inline
         | output CONCATENACION_OUTPUT output_inline         
         | output error output_inline {: System.err.println("Error: Se debe de definir el caracter de concatenacion (<<) para los outpout "); :};

output_inline ::= OUTPUT PAREN_I expresion PAREN_D
| error PAREN_I expresion PAREN_D {: System.err.println("Error: Se debe de definir la palabra de (input) para indicar una salida en consola."); :};

/* Estructuras de control */
estructruraControl ::= decide 
                     | loop 
                     | for;

decide ::= DECIDE OF condiciones END DECIDE DELIMITADOR
         | DECIDE OF condiciones ELSE bloque END DECIDE DELIMITADOR
         | DECIDE error condiciones END DECIDE DELIMITADOR {: System.err.println("Error: Se esperaba 'of' despues de 'decide'"); :}
         | DECIDE OF error END DECIDE DELIMITADOR {: System.err.println("Error: Condiciones no validas en estructura decide"); :}
         | DECIDE OF condiciones error DECIDE DELIMITADOR  {: System.err.println("Error: Se esperaba 'end' antes de 'decide'"); :}
         | DECIDE OF condiciones END error DELIMITADOR {: System.err.println("Error: Se esperaba 'decide' despues de 'end'"); :};

condiciones ::= condicion FLECHA bloque
              | condiciones condicion FLECHA bloque;

condicion ::= PAREN_I expresion PAREN_D
            | error expresion PAREN_D {: System.err.println("Error: Se esperaba parentesis de apertura 'є' en condicion"); :}
            | PAREN_I expresion error {: System.err.println("Error: Se esperaba parentesis de cierre 'э' en condicion"); :}
            | PAREN_I error PAREN_D {: System.err.println("Error: Expresion no valida en condicion"); :};


loop ::= LOOP bloque EXIT WHEN condicion DELIMITADOR END LOOP DELIMITADOR
       | LOOP bloque break EXIT WHEN condicion DELIMITADOR END LOOP DELIMITADOR
       | LOOP error EXIT WHEN condicion DELIMITADOR END LOOP DELIMITADOR {: System.err.println("Error: Bloque no valido en estructura loop"); :}
       | LOOP bloque error WHEN condicion DELIMITADOR END LOOP DELIMITADOR {: System.err.println("Error: Se esperaba 'exit' antes de 'when'"); :}
       | LOOP bloque EXIT error condicion DELIMITADOR END LOOP DELIMITADOR {: System.err.println("Error: Se esperaba 'when' despues de 'exit'"); :}
       | LOOP bloque EXIT WHEN condicion DELIMITADOR error LOOP DELIMITADOR {: System.err.println("Error: Se esperaba 'end' antes de 'loop'"); :};

for ::= FOR IDENTIFICADOR STEP INT_LITERAL TO expresion DO bloque DELIMITADOR
      | FOR IDENTIFICADOR STEP INT_LITERAL DOWNTO expresion DO bloque DELIMITADOR
      | FOR error STEP INT_LITERAL TO expresion DO bloque DELIMITADOR {: System.err.println("Error: Se esperaba identificador despues de 'for'"); :}
      | FOR IDENTIFICADOR error INT_LITERAL TO expresion DO bloque DELIMITADOR {: System.err.println("Error: Se esperaba 'step' despues del identificador"); :}
      | FOR IDENTIFICADOR STEP error TO expresion DO bloque DELIMITADOR {: System.err.println("Error: Se esperaba numero entero despues de 'step'"); :}
      | FOR IDENTIFICADOR STEP INT_LITERAL error expresion DO bloque DELIMITADOR {: System.err.println("Error: Se esperaba 'to' o 'downto' en bucle for"); :}
      | FOR IDENTIFICADOR STEP INT_LITERAL TO expresion error bloque DELIMITADOR {: System.err.println("Error: Se esperaba 'do' antes del bloque"); :};

/* Producciones de declaraciones y variables con DELIMITADOR (pendiente) */
var ::= LET tipoDatoVariable IDENTIFICADOR DELIMITADOR; /* | LET tipoDatoVariable IDENTIFICADOR ASIGNACION expresion DELIMITADOR    -- Se cambio esto por que era lo mismo */

varAsignacion ::= IDENTIFICADOR ASIGNACION expresion DELIMITADOR;
                 
varCyAsignacion ::= LET tipoDatoVariable IDENTIFICADOR ASIGNACION expresion DELIMITADOR
                  | LET tipoDatoVariable IDENTIFICADOR ASIGNACION error DELIMITADOR 
                    {: System.err.println("Error: Expresion no valida despues de '='"); :}
                  | LET tipoDatoVariable IDENTIFICADOR error 
                    {: System.err.println("Error: Se esperaba '=' despues del identificador"); :}
                  | LET tipoDatoVariable error ASIGNACION expresion DELIMITADOR
                    {: System.err.println("Error: Identificador no valido"); :}
                  | LET error IDENTIFICADOR ASIGNACION expresion DELIMITADOR
                    {: System.err.println("Error: Tipo de dato no valido"); :};

/* FIX: ERROR en global para que detecte 'global tipo identificador...' */
/* FIXED: Se agrega produ de error en falta de global */
varGlobal ::= GLOBAL tipoDatoVariable IDENTIFICADOR DELIMITADOR
            | error tipoDatoVariable IDENTIFICADOR DELIMITADOR
              {: System.err.println("Error: Se esperaba la palabra 'global' al inicio de la declaracion"); :}
            | GLOBAL tipoDatoVariable IDENTIFICADOR ASIGNACION expresion DELIMITADOR;

/* ##### Seccion para las expresiones ######*/
expresion ::= expresionAritmetica
            | expresionLogica
            | expresionChar
            | expresionString;


/* Modificar las derivacion para expresion logica con el fin de que pueda volver a arriba:  expresionLogica AND expresionLogica| expresionLogica OR expresionLogica*/
expresionLogica ::= expresionRelacional AND expresionLogica
                  | expresionRelacional OR expresionLogica
                  | NOT expresionLogica                  
                  | expresionRelacional
                  | expresionBooleana; 
                  

/* Los de expresionAritmetica no se pueden cambiar ya que los operadores de mayores y menore solo funcionan con estos. Asi */
expresionRelacional ::= expresionAritmetica IGUAL expresionAritmetica
                      | expresionAritmetica DIFERENTE expresionAritmetica
                      | expresionAritmetica MENOR expresionAritmetica
                      | expresionAritmetica MAYOR expresionAritmetica
                      | expresionAritmetica MENOR_IGUAL expresionAritmetica
                      | expresionAritmetica MAYOR_IGUAL expresionAritmetica

                      | expresionBooleana IGUAL expresionBooleana
                      | expresionBooleana DIFERENTE expresionBooleana
                      | expresionChar IGUAL expresionChar
                      | expresionChar DIFERENTE expresionChar
                      | expresionString
                      | PAREN_I expresion PAREN_D; /* Con esta en teoria deberia de volver a arriba. */

expresionChar ::= CHAR_LITERAL
                | obtenerElementoLista
                | funcionLlamada;

expresionString ::= STRING_LITERAL
                  | IDENTIFICADOR;

expresionBooleana ::= TRUE
                    | FALSE
                    | IDENTIFICADOR;


/* >> Expresiones aritmeticas */

expresionAritmetica ::= expresionSuma;


expresionSuma ::= expresionSuma MAS expresionProducto
                | expresionSuma MENOS expresionProducto
                | expresionProducto
                | expresionSuma MAS error
                  {: System.err.println("Error: Expresion no valida despues de '+'"); :}
                | expresionSuma MENOS error
                  {: System.err.println("Error: Expresion no valida despues de '-'"); :};

expresionProducto ::= expresionProducto MULTIPLICACION expresionPotencia
                    | expresionProducto DIVISION expresionPotencia
                    | expresionProducto DIVISION_ENTERA expresionPotencia
                    | expresionProducto MODULO expresionPotencia
                    | expresionPotencia;
          
expresionPotencia ::= expresionFactor POTENCIA expresionPotencia
                    | expresionFactor;


expresionFactor ::= PAREN_I expresionAritmetica PAREN_D
                  | expresionNumerica
                  | expresionAritmeticaUnaria
                  | expresionAritmeticaUnariaNegativa
                  | error
                    {: System.err.println("Error: Expresion aritmetica no valida"); :};

expresionNumerica ::= INT_LITERAL
                    | FLOAT_LITERAL  
                    | IDENTIFICADOR
                    | funcionLlamada
                    | obtenerElementoLista
                    | input
                    | INT_LITERAL IDENTIFICADOR error
                      {: System.err.println("Error: Numero seguido de identificador no es valido (ej: 2f5)"); :}
                    | FLOAT_LITERAL IDENTIFICADOR error
                      {: System.err.println("Error: Numero flotante seguido de identificador no es valido"); :};

expresionAritmeticaUnaria ::= IDENTIFICADOR INCREMENTO
                            | IDENTIFICADOR DECREMENTO;

expresionAritmeticaUnariaNegativa ::= MENOS expresionNumerica;


/* ##### Seccion para el manejo de listas ######*/
lista ::= declaracionLista
        | creacionYAsignacionLista;

declaracionLista ::= LET tipoLista IDENTIFICADOR DELIMITADOR;

creacionYAsignacionLista ::= LET tipoLista IDENTIFICADOR ASIGNACION LLAVE_I elementos LLAVE_D DELIMITADOR;

elementos ::= elementoLista
            | elementos COMA elementoLista;

elementoLista ::= expresionAritmetica /* Este deberia ser expresion aritmetica en ves de -> INT_LITERAL*/
                | CHAR_LITERAL
                | IDENTIFICADOR; /* FIXED: El elemento en lista deberia poder permitir identificadores validos*/

/* FIX: El elemento en lista deberia poder permitir identificadores validos*/
modificarElementoLista ::= IDENTIFICADOR CORCHETE_I expresionAritmetica CORCHETE_D ASIGNACION elementoLista DELIMITADOR 
                         | error CORCHETE_I expresionAritmetica CORCHETE_D ASIGNACION elementoLista DELIMITADOR
                           {: System.err.println("Error: Nombre de lista no valido"); :};

obtenerElementoLista ::= IDENTIFICADOR CORCHETE_I expresionAritmetica CORCHETE_D
                      | error CORCHETE_I expresionAritmetica CORCHETE_D
                        {: System.err.println("Error: Nombre de lista no valido"); :};

tipoLista ::= INT CORCHETE_I CORCHETE_D {: 
                TipoLista tipoL = new TipoLista("int", null);
                RESULT = tipoL;
            :}
           | CHAR CORCHETE_I CORCHETE_D {: 
                TipoLista tipoL = new TipoLista("char", null);
                RESULT = tipoL;
            :}
           | INT CORCHETE_I INT_LITERAL:num CORCHETE_D {: 
                int tama = num;
                TipoLista tipoL = new TipoLista("int", tama);
                RESULT = tipoL;
            :}
           | CHAR CORCHETE_I INT_LITERAL:num CORCHETE_D {: 
                int tama = num;
                TipoLista tipoL = new TipoLista("char", tama);
                RESULT = tipoL;
            :};


