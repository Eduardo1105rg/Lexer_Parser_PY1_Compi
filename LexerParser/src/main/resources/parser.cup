/* Definicion del pasers con CUP para el analisis de la gramatica.  */

/* Imports que se ocupan */
package parser;

import java_cup.runtime.*;
import lexer.*;
import java.io.*;
import lexer.Lexer;

// Estos serian para la parte del manejo de la tabla de simbolos.
import java.util.HashMap;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.Stack;

// Import las clases necesarias para la tabla de simbolos.
import simbolos.Token;
import simbolos.Ambitos;
import simbolos.TipoLista;
import simbolos.TipoExpresiones;
import simbolos.TokenDecide;
import simbolos.CondicionBloque;

// Import de TAC
import simbolos.Cuad;
import simbolos.TAC_Generator;


// Import utils.
import utils.ObtenerValorEnString;


/* Aqui vamos a definir lo que se va a ejecutar al reducir una produccion o algo asi. (Es diferente del 'parser code')*/
action code {: // Esta parte podria ir en un archivo aparte, pero probemoslo asi de momento.


// Esta es basicamente todo el manejo de la tabla de simbolos y asi definir su alcance por ambitos.

  {
    entornoActual = new Ambitos(null); // Ambito raiz, este es el inicial, el que contiene a los demas, aqui estan las globales y todas las funciones.
    mostrarMensajeTS(" \n>> Ambito inicial global creado \n");
  }

  Token funcionActual; // Para trabajar lo que es el analisis semantico de la llamada a funciones.

  Token funcionEnAnalisis; // Esta esa para tener los datos de la funcionn que estamos revisando en este momento.

  // La idea aqui es usar pilas para manejar entradas y salidas (como lo haria un automata de pila) con esto podemos verificar si la pila está vacia o no e ir saliendo de bucles
  Stack<String> pilaEstrucControl = new Stack<>();// La idea con esto que que para saber si estamos dentro de una estructura de control.
  Stack<String> pilaLoopExitLabels = new Stack<>();
  Stack<String> pilaLoopStartLabels = new Stack<>();
  Stack<String> pilaForStartLabels = new Stack<>();
  Stack<String> pilaForExitLabels  = new Stack<>();
  String forVarControlNombre = null;
  List<TipoExpresiones> elementosBuffer = new ArrayList<>(); // un buffer temporal para los elementos de una lista procesandose
  int contador = 0; // Esto es para ayudar a generar el token de los identificadores del decide.

  int contadorFor = 0;

  int contadorLoop = 0;

  // Para tac:
  int indiceParametroActual = 0; // Indice del parametro que se se "lee" actualmente
  int contadorArgActual = 0;

  private String valorDefault (String tipo) {
    switch (tipo) {
        case "int": return "0";
        case "float": return "0.0";
        case "boolean": return "false";
        case "char": return "'\\0'";
        case "string": return "\"\"";
        default: return "0";
    }
  }

  // Funcion para obtener el valor de un tipo de expresion dependiedo de si es null o no, esta hace una llamada a la clase 
  // que contiene la logica de la funcion.
  private String operandoString (TipoExpresiones expr) {
    
    // Llamar a la funcion en utils para obtener el valor, la logica es la misma a la que estaba aqui.
    return ObtenerValorEnString.operandoString(expr);
  }






  // Crear un nuevo ambito y asigarle a lo anterior el que ya estabamos trabajando. [Este esta mas pensado para lo que pase dentro de BLOQUE]
  public void crearAmbito() {
      entornoActual = new Ambitos(entornoActual);
  }

  // Este seria para generar ambitos de funciones.
  public void crearAmbitoFuncion(String nombreFuncion, String tipo, int linea, int columna) {
      // Registrar la función como simbolo en el entorno padre

      Token funcion = new Token(nombreFuncion, tipo, "global", null, "funcion", linea, columna); // Queda mejor hacer el token aqui que en la parte de la produccion directamente.
      entornoActual.insertarNuevoToken(funcion);

      // Crear entorno local para parámetros y variables internas
      entornoActual = new Ambitos(entornoActual);
  }


  // Volver a lo que seria el ambito de mas arriba, el padre por asi decirlo, en algun punto vuelve al punto general del programa.
  public void cerrarAmbito() {
      entornoActual = entornoActual.getAnterior();
      mostrarMensajeTS(" \n>> Ambito cerrado. \n");
  }

  // Ahora se inserta un nuevo simbolo en el ambito en el que estamos.
  public boolean insertarNuevoToken(Token token) {
      return entornoActual.insertarNuevoToken(token);
  }


  // >> Esta seria la seccion para la parte de busquedas.

  // Buscar la existencia de un simbolo especifico en ambito, [Esto deberia de cambiarse para que sean por  especifico para un identificador y especifico para funciones].
  public Token buscarToken(String nombre) {
      return entornoActual.buscar(nombre);
  }

  public Token buscarFuncion(String nombre) {

    for (Ambitos ambito = entornoActual; ambito != null; ambito = ambito.getAnterior()) {
      
        Token token = ambito.buscar(nombre);

        if (token != null && "funcion".equals(token.getCategoria())) {
          return token;
        }
    }
    return null;
  }

  // Mostrar la tabla de simbolos actual.
  public void mostrarTablaActual() {
      System.out.println("Tabla de simbolos actual:");
      for (Token token : entornoActual.getTablaActual().values()) {
          token.mostrarToken();
      }
  }

    // Para buscar el ambito de una funcion especifica.
    public Ambitos buscarAmbitoDeFuncion(String nombre) {
        Ambitos actual = entornoActual;
        while (actual != null) {

            Token token = actual.buscar(nombre);
            if (token != null && "funcion".equals(token.getCategoria())) {
                return actual;
            }

            actual = actual.getAnterior();
        }
        return null;
    }

    // Para obtener los tipos de parametros de una funcion
    public List<String> obtenerTiposParametros(Token funcion) {
        List<String> tipos = new ArrayList<>();
        Ambitos ambitoFuncion = funcion.getAmbitoLocal();
        if (ambitoFuncion == null) return tipos;
        
        for (Token t : ambitoFuncion.getTablaActual().values()) {
            if ("parametro".equals(t.getCategoria())) {
                tipos.add(t.getTipo());
            }
        }
        return tipos;
    }

    // Para obtener el tipo de dato de un identificador, principalmente variables.
    public TipoExpresiones obtenerTipoIdentificador(String nombre, int fila, int columna) {
        for (Ambitos ambito = entornoActual; ambito != null; ambito = ambito.getAnterior()) {
            Token token = ambito.buscar(nombre);
            if (token != null && ("variable".equals(token.getCategoria()) || "parametro".equals(token.getCategoria()) || "global".equals(token.getCategoria()))
            ) {
                String tipo = token.getTipo();
                mostrarMensajeTS("Identificador '" + nombre + "' encontrado como " + token.getCategoria() + " de tipo '" + token.getTipo() + "'");
                if ("int".equals(tipo)) return new TipoExpresiones("int");
                if ("float".equals(tipo)) return new TipoExpresiones("float");
                if ("char".equals(tipo)) return new TipoExpresiones("char");
                if ("boolean".equals(tipo)) return new TipoExpresiones("boolean");
                if ("string".equals(tipo)) return new TipoExpresiones("string");

                // Si el tipo es valido pero no es reconocido por los anteriores.
                return new TipoExpresiones(tipo);
            }
        }
        aumentarCountErroresSemanticos();
        System.err.println(" -> Error semantico: identificador '" + nombre + "' no encontrado o no es una variable." + "Fila: " + fila + " Columna: " + columna);
        return new TipoExpresiones("error", 0);
    }

    // Para obtener el tipo de dato de una funcion.
    public TipoExpresiones obtenerTipoFuncion(Token funcionActualA, int fila, int columna) {
        if (funcionActualA == null || !"funcion".equals(funcionActualA.getCategoria())) {
            aumentarCountErroresSemanticos();
            System.err.println(" -> Error semantico: funcion no valida." + "Fila: " + fila + " Columna: " + columna);
            return new TipoExpresiones("error", 0);
        }
        String tipo = funcionActualA.getTipo(); // Ej: "int", "float", "void", etc.
        if ("void".equals(tipo)) {
            aumentarCountErroresSemanticos();
            System.err.println(" -> Error semantico: la funcion no retorna valor." + "Fila: " + fila + " Columna: " + columna);
            return new TipoExpresiones("error", 0);
        }
        return new TipoExpresiones(tipo);
    }

    // Esto es para validar el tipo de datos esperado en las expresiones.
    public boolean validarTipoEsperado(String esperado, TipoExpresiones tipoReal) {
        if (tipoReal == null || "error".equals(tipoReal.tipoDato)) return false;
        // return esperado.equals(tipoReal.tipoDato);

        // Con esta parte de aqui ya acepta esto "int|float", para que valide los dos a la vez.
        String[] tipos = esperado.split("\\|");
        for (String t : tipos) {
            if (t.equals(tipoReal.tipoDato)) {
                return true;
            }
        }
        return false;
    }

    // Funcion para validar si el tipo de dos argumentos de una expresionn son de tipo iguales y que solo sean numericos, esto podria separarse para dar mensajes mas explicitos.
    public boolean tiposIgualesNumericos(TipoExpresiones a, TipoExpresiones b) {
        if (a == null || b == null) return false;
        String t1 = a.tipoDato;
        String t2 = b.tipoDato;
        return (t1.equals(t2)) && (t1.equals("int") || t1.equals("float")); // Validar los tipos.
    }

    // Para validar que los tipos de datos sean iguales.
    public boolean tiposIguales(TipoExpresiones a, TipoExpresiones b) {
        return a != null && b != null && a.tipoDato != null && a.tipoDato.equals(b.tipoDato);
    }

    // Para validar que el operador sea valido con ese tipo de dato.
    public boolean tipoPermitidoComparacion(String tipo, String operador) {
        switch (operador) {
            case "==": case "!=":
                return tipo.equals("int") || tipo.equals("float") || tipo.equals("char") || tipo.equals("boolean");
            case "<": case ">": case "<=": case ">=":
                return tipo.equals("int") || tipo.equals("float");
            default:
                return false;
        }
    }


    // Funcion para mostrar los mensajes de prints, recive el mensaje que se desee mostrar y hace un print. Esto es principalmente
    // para los mensajes de print que son para hacer debug.
    public void mostrarMensaje(String mensaje) {
        //System.out.println(mensaje); // Esta parte es la que se debe de comentar para cuando no se quiere mostrar nada.
    }


    public void mostrarMensajeTS(String mensaje) {
        //System.out.println(mensaje);
    }



:};



/* Parsers */
parser code {:
    Ambitos entornoActual = null; // Para el entorno que seria basicamente lo que son cada uno de los ambitos de cada una de las partes del codigo leido.

    private int countErroresSemanticos = 0; // Para ir contando la cantidad de errores semanticos.

    private int errorContador = 0;

    public int getErrorContador() {
        return errorContador;
    }

    // Funcion para obtener todos los errores semanticos que se hayan encontrado.

    public int getCountErroresSemanticos () {
        return countErroresSemanticos;
    }

    // Funcion para obtener la informacion de un token, recibe un Symbol y lo procesa usando el archivo SYM.java
    private String obtenerInfoToken(Symbol tok) {
        if (tok == null) return "<EOF>";
        int s = tok.sym;
        Object v = tok.value;
        String val = (v == null) ? "" : (" '" + v.toString() + "'");
        switch (s) {
            case sym.LET: return "LET" + val;
            case sym.GLOBAL: return "GLOBAL";
            case sym.VOID: return "VOID";
            case sym.PRINCIPAL: return "PRINCIPAL";
            case sym.DECIDE: return "DECIDE";
            case sym.OF: return "OF";
            case sym.ELSE: return "ELSE";
            case sym.END: return "END";
            case sym.LOOP: return "LOOP";
            case sym.EXIT: return "EXIT";
            case sym.WHEN: return "WHEN";
            case sym.FOR: return "FOR";
            case sym.STEP: return "STEP";
            case sym.TO: return "TO";
            case sym.DOWNTO: return "DOWNTO";
            case sym.DO: return "DO";
            case sym.RETURN: return "RETURN";
            case sym.BREAK: return "BREAK";
            case sym.OUTPUT: return "OUTPUT";
            case sym.INPUT: return "INPUT";
            case sym.TRUE: return "TRUE";
            case sym.FALSE: return "FALSE";
            case sym.INT: return "INT";
            case sym.FLOAT: return "FLOAT";
            case sym.BOOLEAN: return "BOOLEAN";
            case sym.CHAR: return "CHAR";
            case sym.STRING: return "STRING";
            case sym.IDENTIFICADOR: return "IDENTIFICADOR" + val;
            case sym.INT_LITERAL: return "INT_LITERAL" + val;
            case sym.FLOAT_LITERAL: return "FLOAT_LITERAL" + val;
            case sym.STRING_LITERAL: return "STRING_LITERAL" + val;
            case sym.CHAR_LITERAL: return "CHAR_LITERAL" + val;
            case sym.MAS: return "+";
            case sym.MENOS: return "-";
            case sym.MULTIPLICACION: return "*";
            case sym.DIVISION: return "/";
            case sym.DIVISION_ENTERA: return "//";
            case sym.MODULO: return "%";
            case sym.POTENCIA: return "^";
            case sym.INCREMENTO: return "++";
            case sym.DECREMENTO: return "--";
            case sym.IGUAL: return "==";
            case sym.DIFERENTE: return "!=";
            case sym.MENOR: return "<";
            case sym.MAYOR: return ">";
            case sym.MENOR_IGUAL: return "<=";
            case sym.MAYOR_IGUAL: return ">=";
            case sym.AND: return "AND(@)";
            case sym.OR: return "OR(~)";
            case sym.NOT: return "NOT(Σ)";
            case sym.ASIGNACION: return "=";
            case sym.DELIMITADOR: return "$";
            case sym.COMA: return ",";
            case sym.PAREN_I: return "PAREN_I(є)";
            case sym.PAREN_D: return "PAREN_D(э)";
            case sym.CORCHETE_I: return "[";
            case sym.CORCHETE_D: return "]";
            case sym.LLAVE_I: return "LLAVE_I(¿)";
            case sym.LLAVE_D: return "LLAVE_D(?)";
            case sym.FLECHA: return "->";
            case sym.CONCATENACION_OUTPUT: return "<<";
            case sym.ERROR: return "ERROR" + val;
            default: return "SIMBOLO(" + s + ")" + val;
        }
    }

    public void syntax_error(Symbol cur_token) {
        System.err.println(" -> Error sintactico en linea " + (cur_token != null ? cur_token.left : -1)
                + ", columna " + (cur_token != null ? cur_token.right : -1)
                + ": Token inesperado: " + obtenerInfoToken(cur_token));
        errorContador++;
    }

    public void report_error(String message, Object info) {
    }

    public void unrecovered_syntax_error(Symbol cur_token) {
        System.err.println(" -> Error sintactico no recuperable en linea " + (cur_token != null ? cur_token.left : -1)
                + ", columna " + (cur_token != null ? cur_token.right : -1)
                + ": " + obtenerInfoToken(cur_token));
    }

    public void mostrarTS() {
        entornoActual.mostrarTodosLosAmbitos(entornoActual);
    }

    public void aumentarCountErroresSemanticos () {
        countErroresSemanticos++;
    }

    // PRUEBAS TAC
    public boolean esHoja (TipoExpresiones e) {
        return e.cuads.isEmpty(); // Si no contiene otros cuadruplos quiere decir que es hoja (no tiene subexpresiones)
    }

    public String valorHoja (TipoExpresiones e) {
        // Si es un constante o literal almacenado como un temporal:
        if (e.temp != null) {
            return e.temp;
        }
        return e.temp; // si es hoja no deberia llegar aqui porque el temp deberia tener valor
    }

:};




// >> El profe tambien define esto. >> De momento lo dejo comentado por que no se para que sirve.
// init with {: :};

// scan with {: return lexer.next_token(); :};




/* Definición de terminales (tokens) */
// Son las palabras reservadas
terminal String LET, GLOBAL, VOID, PRINCIPAL, DECIDE, OF, ELSE, END, LOOP, EXIT;
terminal String  WHEN,  RETURN, BREAK, INPUT, FOR, STEP, TO, DOWNTO, DO;

// Modificamos el output para que sea solo usado como sentencia y no en asignaciones o cosas raras:
terminal String OUTPUT;

// Tipos de datos
terminal String INT, FLOAT, BOOLEAN, CHAR, STRING;

// Literales de los tipos de datos, esta es la representacion en string.
terminal Integer INT_LITERAL;
terminal Double FLOAT_LITERAL;
terminal String STRING_LITERAL;
terminal Character CHAR_LITERAL;
terminal Boolean TRUE, FALSE;

// Identificadores.
terminal String IDENTIFICADOR;

// Operadores aritmeticos
terminal MAS, MENOS, MULTIPLICACION, DIVISION, DIVISION_ENTERA, MODULO, POTENCIA;
terminal INCREMENTO, DECREMENTO;

// Operadores relacionales
terminal IGUAL, DIFERENTE, MENOR_IGUAL, MAYOR_IGUAL, MENOR, MAYOR;

// Operadores logicos
terminal AND, OR, NOT;

// Asignacion
terminal ASIGNACION;

// Delimitadores y separadores
terminal DELIMITADOR, COMA;
terminal PAREN_I, PAREN_D,CORCHETE_I, CORCHETE_D, LLAVE_I, LLAVE_D;

// La flecha para los if y el concatenador de los prints.
terminal FLECHA, CONCATENACION_OUTPUT;

// Terminar para la deficion de errores lexicos.
terminal ERROR;

// Nuevos elementos agregados para el PY 2.

terminal LISTA;
terminal ARGUMENTOS;



// --------- Fin elementos nuevos.



/* -------------->>>> Seccion para los no terminales */

/* >> Estructura general*/
non terminal programa, principal, funciones, funcion, params, param;

/* >> Tipos de datos: A estos se les agrega que sean String para que sea mas facil trabajarles la parte semanatica. */
non terminal String tipoDatoFuncion, tipoDatoVariable;

/* >> Sentencias y bloques */
non terminal sentencias, sentencia;

non terminal Token bloque;

/* >> Declaraciones y variables */
non terminal var, varAsignacion, varCyAsignacion, varGlobal;

/* >> Expresiones  */

non terminal TipoExpresiones expresion;

/* > Numericas */
non terminal TipoExpresiones expresionNumerica, expresionSuma, expresionProducto, expresionPotencia, expresionFactor, expresionAritmeticaUnaria, expresionAritmeticaUnariaNegativa;

/* > Boolenas  */
non terminal TipoExpresiones expresionBooleana;

/* > Literales */
non terminal TipoExpresiones expresionChar, expresionString;

/* > Expresiones compuestas */
non terminal TipoExpresiones expresionAritmetica, expresionLogica, expresionRelacional;

/* >> Control de flujo */
non terminal estructruraControl, decide, loop, for;

non terminal TipoExpresiones condicion;

non terminal forInt, loopInicio;

/* >> Funciones y sus llamadas  */
non terminal return, break;

non terminal TipoExpresiones funcionLlamada;

/* >> Este ahora lleva la lista de TipoExpresiones para trabajar con ellos. */
non terminal List<TipoExpresiones> argumentos;

/* Aqui estoy poniendo los no terminales que estan faltando */
non terminal listaFunciones;
non terminal String tipoDatoInput;

non terminal List<CondicionBloque> condiciones;

/* >> Input y ouput */
non terminal List<TipoExpresiones> listaSalida;
non terminal output, output_inline;
non terminal String input;
/* >> Listas */
non terminal lista, declaracionLista, creacionYAsignacionLista ;

non terminal TipoExpresiones elementos, elementoLista, modificarElementoLista, obtenerElementoLista;


// Esta son las nuevas declaraciones: 
non terminal principalParteIzquierda, funcionParteIzquierda, bloqueInicio, funcionLlamadaInicio;

non terminal String tipoDatoParametro; // Le definimo String para que sea mas facil trabajar con lo valores.

non terminal TipoLista tipoLista; // Aqui indicamos que lo que vamos a devolver es un objeto de TipoLista
non terminal Token decideParteIzquierda;

non terminal seExprAritUni, seOutput, seFuncLlama;
non terminal TipoExpresiones inputExpr;

non terminal bloqueError;
// non terminal outputError;
// non terminal String operadorRelacional;
// --- Fin de declaracion de nuevos no terminales. 



/* Precedencia de operadores (de menor a mayor precedencia) */

// Operadores binarios
precedence left OR;
precedence left AND;
precedence right NOT; 

/* Operadores booleanos y relacionales */
precedence left IGUAL, DIFERENTE;
precedence left MENOR, MAYOR, MENOR_IGUAL, MAYOR_IGUAL;

/* Operadores aritmeticos */
precedence left MAS, MENOS;
precedence left MULTIPLICACION, DIVISION, DIVISION_ENTERA, MODULO;
precedence right POTENCIA;

// Operadores unarios
precedence left INCREMENTO, DECREMENTO;
precedence right MENOS; /* Pasar a negativo: Revisar la gramatica original para una posible correccion. */


/* Precedencia para resolver conflictos */
precedence left COMA;
precedence right ASIGNACION;


/* expect 6; Esto es para decirle a cup qie espere hasta 6 congliuctos y que los acepte */

/* Esta es la que dice como se inicia todo. */
start with programa;



/* -------------------------  >> Definicion << -------------------------------------------------------------------  */


/* Producciones generales */
/* FIX: La estructura del principal está como opcional, debe de ser obligatorio y al final (por diseño) */
/* FIXED: Se arreglo la estructura para que siempre haya un bloque principal */
programa ::= varGlobal programa
           | funciones principal:pri {: 
                if (buscarFuncion("principal") == null) {
                    System.err.println(" -> Error semantico: no se ha definido la funcion principal." + "Linea: " + prileft + " Columna: " + priright);
                    aumentarCountErroresSemanticos();
                }
                // mostrarTS();
            :} 
           | principal:pri {: 
                if (buscarFuncion("principal") == null) {
                    System.err.println(" -> Error semantico: no se ha definido la funcion principal." + "Linea: " + prileft + " Columna: " + priright);
                    aumentarCountErroresSemanticos();
                }
                // mostrarTS();
            :};
        

principalParteIzquierda ::= VOID PRINCIPAL:pri PAREN_I PAREN_D {: 
                            Token principal = new Token("principal", "void", "global", null, "funcion", prileft, priright);
                            if (!insertarNuevoToken(principal)) {
                                System.err.println(" -> Error semantico: funcion 'principal' ya declarada." + "Linea: " + prileft + " Columna: " + priright);
                                aumentarCountErroresSemanticos();
                            }


                            mostrarMensajeTS("\n >> Reconociendo una funcion 1. \n");
                            crearAmbito(); // entorno local para principal
                            principal.setAmbitoLocal(entornoActual);
                            funcionEnAnalisis = principal; // Para trabajar con lo datos de la funcion.

                            // Generación TAC
                            simbolos.TAC_Generator.generarLabel("FUNC_principal");
                            simbolos.TAC_Generator.generarBeginFunc("principal");
                            indiceParametroActual = 0;
                        :};

principal ::= principalParteIzquierda bloque:blo {: 
            insertarNuevoToken(blo);

            //   mostrarTablaActual();
              cerrarAmbito(); // cerramos entorno de principal

              TAC_Generator.generarEndFunc("principal");
              mostrarMensajeTS("\n >> Cerando el reconociendo una funcion 1. \n");
          :};

// Se le agrega el result para que las producciones sepan mejor el valor semantico que van a tener.
tipoDatoFuncion ::= INT {: RESULT = "int"; :}
                  | FLOAT {: RESULT = "float"; :}
                  | CHAR {: RESULT = "char"; :}
                  | BOOLEAN {: RESULT = "boolean"; :};

tipoDatoVariable ::= INT {: RESULT = "int"; :}
                  | FLOAT {: RESULT = "float"; :}
                  | BOOLEAN {: RESULT = "boolean"; :}
                  | CHAR {: RESULT = "char"; :}
                  | STRING {: RESULT = "string"; :};


/* Esta modificacion es para intentar resolver el conflicto de funcion */
funciones ::= listaFunciones;

listaFunciones ::= funcion
                 | listaFunciones funcion;


// Para esta porte de las funciones, las dividimos en parte izquierda y parte derecha para que sea mas facil el analisis.
funcionParteIzquierda ::= tipoDatoFuncion:tipo IDENTIFICADOR:ID PAREN_I  {: 
                        Token funcion = new Token(ID, tipo, "global", null, "funcion", IDleft, IDright);
                        if (!insertarNuevoToken(funcion)) {
                            System.err.println(" -> Error semantico: funcion '" + ID + "' ya declarada." + "Linea: " + IDleft + " Columna: " + IDright);
                            aumentarCountErroresSemanticos();
                        }

                        mostrarMensajeTS("\n >> Reconociendo una funcion 1. \n");
                        crearAmbito(); // Crear el ambito local de una funcion, esto antes de que se cree el bloque.
                        funcion.setAmbitoLocal(entornoActual); // Me parece que este deberia de 
                        funcionEnAnalisis = funcion; // Guardamos la funcion que acabamos de crear para que sea mas facil trabajarla despues.
                        TAC_Generator.generarLabel ("FUNC_" + ID);
                        TAC_Generator.generarBeginFunc (ID);
                        indiceParametroActual = 0;
                      :}; 
// Fin de produccion.
  


// Funciones en la parte derecha.
funcion ::= funcionParteIzquierda params PAREN_D bloque:blo {: 
            insertarNuevoToken(blo);
            cerrarAmbito(); // Cerramos el ambito local de una funcion.
            TAC_Generator.generarEndFunc (funcionEnAnalisis.getNombre());
            mostrarMensajeTS("\n >> Creando el reconociendo una funcion 1. \n");
        :}
        | funcionParteIzquierda PAREN_D bloque:blo {: 
            insertarNuevoToken(blo);
            cerrarAmbito(); 
            TAC_Generator.generarEndFunc (funcionEnAnalisis.getNombre());
            mostrarMensajeTS("\n >> Creando el reconociendo una funcion 1. \n");
        :}
        | funcionParteIzquierda params PAREN_D bloque:blo error {: System.err.println(" -> Error sintectico, se encontro un elemento inesperado despues del la funcion." + "Linea: " + bloleft + ", Columna: " + bloright); insertarNuevoToken(blo); cerrarAmbito(); :}
        | funcionParteIzquierda PAREN_D bloque:blo error {: System.err.println(" -> Error sintectico, se encontro un elemento inesperado despues del la funcion." + "Linea: " + bloleft + ", Columna: " + bloright); insertarNuevoToken(blo); cerrarAmbito(); :}; // Fin de produccion.


// >>>>>>>>>>Parte de los parametros de una funcion
params ::= param
         | params COMA param
         | error COMA param:pa {: System.err.println(" -> Error: No puede haber una (,) sola al inicio de los parametros." + "Linea: " + paleft + ", Columna: " + paright); :};

// Definirle el valos de formas mas explicita para que puedan ser leidos.
tipoDatoParametro ::= INT {: RESULT = "int"; :}
                    | FLOAT {: RESULT = "float"; :}
                    | BOOLEAN {: RESULT = "boolean"; :}
                    | CHAR {: RESULT = "char"; :}
                    | STRING {: RESULT = "string"; :};
                 
param ::= tipoDatoParametro:tipo IDENTIFICADOR:ID {: 
          Token parametro = new Token(ID, tipo, "parametro", null, "parametro", IDleft, IDright);
          if (!insertarNuevoToken(parametro)) {
              System.err.println(" -> Error semantico: parametro '" + ID + "' ya declarado." + "Linea: " + IDleft + ", Columna: " + IDright);
              aumentarCountErroresSemanticos();
          }
          TAC_Generator.generarPopParam (indiceParametroActual++, ID, tipo.toString()); // Se luga el parametro al indice
        :}
      | tipoLista:tipo IDENTIFICADOR:ID {: //Despues se tiene que hacer algo para trabajar con lo del tamaño.
          Token parametro = new Token(ID, tipo.tipoBase, "parametro", null, "parametro", IDleft, IDright);
          if (!insertarNuevoToken(parametro)) {
              System.err.println(" -> Error semantico: parametro '" + ID + "' ya declarado." + "Linea: " + IDleft + ", Columna: " + IDright);
              aumentarCountErroresSemanticos();
          }
          TAC_Generator.generarPopParam (indiceParametroActual++, ID, tipo.toString());
        :}
      | error IDENTIFICADOR:ID {: System.err.println(" -> Error: Para los parametros de una funcion se debe de indicar su tipo de dato." + "Linea: " + IDleft + ", Columna: " + IDright); :};


// -------------------------- Seccion del bloque primario de lo que son las funciones.

bloqueInicio ::= LLAVE_I {: 
    crearAmbito(); 
:};

bloqueError ::= error sentencias LLAVE_D:ld {: 
                // Ambitos ambitoBloque = entornoActual;
                // cerrarAmbito();
                
                System.err.println(" -> Error: Los bloques deben de tener una llave de apertura (¿)." + "Linea: " + ldleft + ", Columna: " + ldright); 
                // RESULT = new Token("bloqueError", null, "local", null, "bloqueError", ldleft, ldright);
                // RESULT.setAmbitoLocal(entornoActual);
            :}
         | error LLAVE_D:ld {: 
                // Ambitos ambitoBloque = entornoActual;
                // cerrarAmbito();

                System.err.println(" -> Error: Los bloques deben de tener una llave de apertura (¿). " + "Linea: " + ldleft + ", Columna: " + ldright); 
                // RESULT = new Token("bloqueError", null, "local", null, "bloqueError", ldleft, ldright);
                // RESULT.setAmbitoLocal(ambitoBloque);
            :}
         | LLAVE_I:li sentencias error {: 
                // Ambitos ambitoBloque = entornoActual;
                // cerrarAmbito();

                System.err.println(" -> Error: Los bloques deben de tener una llave de cierre (?). " + "Linea: " + lileft + ", Columna: " + liright); 
                // RESULT = new Token("bloqueError", null, "local", null, "bloqueError", lileft, liright);
                // RESULT.setAmbitoLocal(ambitoBloque);
            :};


/* Producciones de sentencias y bloques */
bloque ::= bloqueInicio sentencias LLAVE_D:ld {: 
            // Guardar el entorno antes de cerrarlo
            //   mostrarTablaActual();
              Ambitos ambitoBloque = entornoActual;
              cerrarAmbito();

              // Crear un token de bloque o devolver el ambito
              RESULT = new Token("bloque", null, "local", null, "bloque", ldleft, ldright);
              RESULT.setAmbitoLocal(ambitoBloque);

          :}
        | bloqueError:Id {:
                Ambitos ambitoBloque = entornoActual;
                cerrarAmbito();
        
                RESULT = new Token("bloqueError", null, "local", null, "bloqueError", Idleft, Idright);
                RESULT.setAmbitoLocal(ambitoBloque);

        :};


// No tocar esta parte, por alguna razon si funciona y no dio el error de tokens inesperados, esto es brujeria.
sentencias ::= /* vacío */
             | sentencias sentencia ;



sentencia ::= var
            | varAsignacion  
            | varCyAsignacion
            | lista
            | estructruraControl
            | seFuncLlama
            | return
            | break
            | seOutput
            | modificarElementoLista
            | seExprAritUni;

seFuncLlama ::= funcionLlamada DELIMITADOR;
seOutput ::= output DELIMITADOR;
seExprAritUni ::= expresionAritmeticaUnaria DELIMITADOR;

/* FIX: El identificador no debe de ser validado, se valida en producción identificador, sino encuentra busca terminal  */
/*FIXED: Eliminando la linea que valida nombre: | error PAREN_I argumentos PAREN_D  {: System.err.println("Error: Nombre de funcion no valido"); :}*/
funcionLlamadaInicio ::= IDENTIFICADOR:ID PAREN_I {: 
                      Token funcion = buscarFuncion(ID);
                      if (funcion == null) {
                          System.err.println(" -> Error semantico: funcion '" + ID + "' no declarada." + "Linea: " + IDleft + ", Columna: " + IDright);
                          funcionActual = null;
                          aumentarCountErroresSemanticos();
                      } else {
                          mostrarMensajeTS("Llamada a funcion '" + ID + "' valida.");
                          funcionActual = funcion;
                          // Se podria hacer algo para guardar el token y validar sus argumentos luego.
                      }
                      contadorArgActual = 0; // Reiniciamos el conteo de argumentos cuando lee los llamada
                  :};
// Para la llamada a una funcion.
funcionLlamada ::= funcionLlamadaInicio argumentos:args PAREN_D {: 

                      if (funcionActual == null) {
                          System.err.println(" -> Error semantico: No se puede validardar los argumentos de la funcion, debido a que la funcion  buscada no esta declarada." + "Fila: " + argsleft + ", Columna: " + argsright);
                          aumentarCountErroresSemanticos();
                          RESULT = new TipoExpresiones("error");
                      } else {

                        List<TipoExpresiones> argumentos = args;//(List<String>) ((Symbol)args).value;
                        List<String> parametrosEsperados = obtenerTiposParametros(funcionActual);

                        if (argumentos.size() != parametrosEsperados.size()) {
                            System.err.println(" -> Error semantico: funcion '" + funcionActual.getNombre() + "' esperaba " + parametrosEsperados.size() + " argumentos, pero recibio " + argumentos.size() + "Fila: " + argsleft + ", Columna: " + argsright);
                        } else {
                            for (int i = 0; i < argumentos.size(); i++) {
                                if (!argumentos.get(i).getTipo().equals(parametrosEsperados.get(i))) {
                                    System.err.println(" -> Error semantico: argumento " + (i+1) + " de funcion '" + funcionActual.getNombre() + "' esperaba tipo '" + parametrosEsperados.get(i) + "', pero recibio '" + argumentos.get(i).getTipo() + "' " + "Fila: " + argsleft + ", Columna: " + argsright);
                                }
                            }
                        }
                        // Generacion TAC
                        if ("void".equals(funcionActual.getTipo())) {
                            TAC_Generator.generarCall (funcionActual.getNombre(), contadorArgActual++, null);
                            RESULT = new TipoExpresiones("void");
                        } else {
                            String t = TAC_Generator.newTemp();
                            TAC_Generator.generarCall (funcionActual.getNombre(), contadorArgActual++, t);
                            TipoExpresiones res = new TipoExpresiones(funcionActual.getTipo());
                            res.temp = t;
                            RESULT = res;
                        }
                      }
                  :}

                 | funcionLlamadaInicio:fu PAREN_D {: // Aqui estaba pasando directo y mas bien se ocupa validar si efectivamente no tiene argumentos.
                        if (funcionActual == null) {
                            System.err.println(" -> Error semantico: No se puede validardar los argumentos de la funcion, debido a que la funcion  buscada no esta declarada." + "Fila: " + fuleft + ", Columna: " + furight);
                            aumentarCountErroresSemanticos();
                            RESULT = new TipoExpresiones("error");
                        } else {

                            List<String> parametrosEsperados = obtenerTiposParametros(funcionActual);
                            if (parametrosEsperados.size() != 0) {
                                System.err.println(" -> Error semantico: funcion '" + funcionActual.getNombre() + "' esperaba " + parametrosEsperados.size() + " parametros, pero recibio 0 " + "Fila: " + fuleft + ", Columna: " + furight);
                                aumentarCountErroresSemanticos();
                                RESULT = new TipoExpresiones("error");
                            } else {
                            
                                // Generacion TAC
                                if ("void".equals(funcionActual.getTipo())) {
                                    TAC_Generator.generarCall (funcionActual.getNombre(), 0, null);
                                    RESULT = new TipoExpresiones("void");
                                } else {
                                    String t = TAC_Generator.newTemp();
                                    TAC_Generator.generarCall (funcionActual.getNombre(), 0, t);
                                    TipoExpresiones res = new TipoExpresiones(funcionActual.getTipo());
                                    res.temp = t;
                                    RESULT = res;
                                }
                            }
                        }
                    :};


argumentos ::= expresion:expr {: 
                  String valor = operandoString (expr);
                  TAC_Generator.generarParam (valor);
                  contadorArgActual++;

                  List<TipoExpresiones> args = new ArrayList<>();
                  args.add(expr); // suponiendo que expresion devuelve tipo: ((Symbol)expr).value.toString()
                  RESULT = args;//new Symbol(sym.ARGUMENTOS, args);
              :}
             | argumentos:prev COMA expresion:expr {:
                  String valor = operandoString (expr);
                  TAC_Generator.generarParam (valor);
                  contadorArgActual++;

                  //((List<String>) ((Symbol)prev).value).add(expr.getTipo()); //((Symbol)expr).value.toString()
                  //RESULT = new Symbol(sym.ARGUMENTOS, ((Symbol)prev).value);
                
                  // Esto se cambia ya que ahora va a trabajar con la lista de TipoExpresiones.
                  prev.add(expr);
                  RESULT = prev;
              :}
             | error COMA:com expresion  {: System.err.println(" -> Error: Argumento no valido antes de ','" + "Fila: " + comleft + ", Columna: " + comright); :}
             | argumentos COMA:com error {: System.err.println(" -> Error: Se esperaba expresion despues de ','" + "Fila: " + comleft + ", Columna: " + comright); :}
             | argumentos error expresion:expr {: System.err.println(" -> Error: Se esperaba ',' entre argumentos" + "Fila: " + exprleft + ", Columna: " + exprright); :};
             
return ::= RETURN:ret DELIMITADOR {: 
            if (!"void".equals(funcionEnAnalisis.getTipo())) {
                System.err.println(" -> Error semantico: la funcion '" + funcionEnAnalisis.getNombre() + "' debe retornar un valor de tipo '" + funcionEnAnalisis.getTipo() + "'." + "Fila: " + retleft + ", Columna: " + retright);
                aumentarCountErroresSemanticos();
            }
            // Generación tac -> RET
            TAC_Generator.generarReturn (null);
        :}
         | RETURN expresion:expr DELIMITADOR {: 
                String tipoExpr = expr.getTipo(); // suponiendo que expresion devuelve un String con el tipo, pero creo que devolvera una clase con otros datos.
                String tipoFuncion = funcionEnAnalisis.getTipo();

                if ("void".equals(tipoFuncion)) {
                    System.err.println(" -> Error semantico: la funcion '" + funcionEnAnalisis.getNombre() + "' no debe retornar ningun valor." + "Fila: " + exprleft + ", Columna: " + exprright);
                    aumentarCountErroresSemanticos();
                } else if (!tipoExpr.equals(tipoFuncion)) {
                    System.err.println(" -> Error semantico: la funcion '" + funcionEnAnalisis.getNombre() + "' debe retornar tipo '" + tipoFuncion + "', pero se retorno tipo '" + tipoExpr + "'." + "Fila: " + exprleft + ", Columna: " + exprright);
                    aumentarCountErroresSemanticos();
                }   
                // Generacion TAC
                String valorRet = operandoString (expr);
                TAC_Generator.generarReturn (valorRet);
            :}
         | RETURN expresion:expr error {: System.err.println(" -> Error: Se esperaba un delimitador '$' despues de la expresion del return." + "Fila: " + exprleft + ", Columna: " + exprright); :}
         | RETURN:ret error {: System.err.println(" -> Error: Se esperaba un delimitador '$' despues del return." + "Fila: " + retleft + ", Columna: " + retright); :};

break ::= BREAK:bre DELIMITADOR {: 
            if (pilaEstrucControl.isEmpty()) {
                System.err.println(" -> Error semantico: 'break' fuera de estructura de control." + "Fila: " + breleft + ", Columna: " + breright);
                aumentarCountErroresSemanticos();
            } else {
                String topo = pilaEstrucControl.peek();
                if ("loop".equals(topo)) {
                    if (pilaLoopExitLabels.isEmpty()) {
                        System.err.println(" -> Error interno: no hay etiqueta de salida de loop." + "Fila: " + breleft + ", Columna: " + breright);
                    } else {
                        TAC_Generator.generarCuadSaltoIncondicional(pilaLoopExitLabels.peek());
                    }
                } else if ("for".equals(topo)) {
                    if (pilaForExitLabels.isEmpty()) {
                        System.err.println(" -> Error interno: no hay etiqueta de salida de for." + "Fila: " + breleft + ", Columna: " + breright);
                    } else {
                        TAC_Generator.generarCuadSaltoIncondicional(pilaForExitLabels.peek());
                    }
                } else {
                    System.err.println(" -> Error semantico: 'break' solo permitido en loop o for." + "Fila: " + breleft + ", Columna: " + breright);
                    aumentarCountErroresSemanticos();
                }
            }
        :};

inputExpr ::= INPUT PAREN_I tipoDatoInput:td PAREN_D {:
    String temp = TAC_Generator.newTemp();
    TAC_Generator.generarRead(td, temp);
    TipoExpresiones r = new TipoExpresiones(td);
    r.temp = temp;
    RESULT = r;
:};

tipoDatoInput ::= INT {: RESULT = "int"; :}
                | FLOAT {: RESULT = "float"; :};

// Ouput para imprimir los datos.
output ::= output_inline {: RESULT = "output"; :};

output_inline ::= OUTPUT PAREN_I listaSalida:lst PAREN_D {:
    if (lst == null) {
        // No se ocupa hacer nada ya que el error se reporta en la produccion de listaSalida.
    } else {
        for (TipoExpresiones e : lst) {
            String v = operandoString(e);
            simbolos.TAC_Generator.generarPrint(v);
        }
    }
:};

// Para la parte del output no de deben de permitir imprimir datos tipo char.
listaSalida ::= expresion:e {:
        if (e.getTipo().equals("char")) {
            System.err.println(" -> Error semantico: 'char' no es un tipo valido para 'output'." + "Fila: " + eleft + ", Columna: " + eright);
            aumentarCountErroresSemanticos();
            RESULT = null;
        } else {        
            ArrayList<TipoExpresiones> l = new ArrayList<>();
            l.add(e);
            RESULT = l;        
        }
    :}
    | listaSalida:prev CONCATENACION_OUTPUT expresion:e {:
        if (e.getTipo().equals("char")) {
            System.err.println(" -> Error semantico: 'char' no es un tipo valido para 'output'." + "Fila: " + eleft + ", Columna: " + eright);
            aumentarCountErroresSemanticos();
        } else {
            prev.add(e);
            RESULT = prev;
        }
    :};

/* -------------------- Estructuras de control ----------------------------- */
estructruraControl ::= decide
                     | loop
                     | for
                     ;

decideParteIzquierda ::= DECIDE:deci OF {: 
                            // esta parte deberia ser mas bien para cuando se cierre el ambito.
                            Token estructura = new Token("otro_decide_" + contador++, "estructura", "local", null, "decide", decileft, deciright);
                            // insertarNuevoToken(estructura);
                            crearAmbito();
                            pilaEstrucControl.push("decide");

                            RESULT = estructura;
                        :};

// Aqui hay que agregar algo para agregar a la pila de estructura de control.
decide ::= decideParteIzquierda:deciP condiciones:condi END DECIDE:deci DELIMITADOR {:
                String L_end = TAC_Generator.newEtiqueta();
                for (CondicionBloque cb : condi) {
                    String tCond = operandoString (cb.getCondicion());
                    String t_next = TAC_Generator.newEtiqueta ();
                    TAC_Generator.generarCuadIfFalse (tCond, t_next);
                    TAC_Generator.unir (cb.getTac());
                    TAC_Generator.generarCuadSaltoIncondicional (L_end); //Un salto luego del decide 
                    TAC_Generator.generarLabel (t_next);
                }
                TAC_Generator.generarLabel (L_end);

                // Token estructura = new Token("otro_decide_" + contador++, "estructura", "local", null, "decide", decileft, deciright);
                TokenDecide bloques = new TokenDecide();
                for (CondicionBloque cb : condi) {
                   bloques.addCondiBloque(cb);
                }
                
                deciP.setBloqueDecide(bloques); // Guardamos la estructura interna.
                deciP.setAmbitoLocal(entornoActual); // Este de aqui basicamente no se ocupa, puesto que guardamos las estrcuturas de los bloques por aparte.
                cerrarAmbito(); 
                insertarNuevoToken(deciP);
                pilaEstrucControl.pop();
            :}
         | decideParteIzquierda:deciP condiciones:condi ELSE {: TAC_Generator.iniciarBuffer(); :} bloque:blo END DECIDE DELIMITADOR {:
                List<Cuad> tacElse = TAC_Generator.finalizarBuffer();
                String L_end = TAC_Generator.newEtiqueta();

                for (CondicionBloque cb : condi) {
                    String tCond = operandoString (cb.getCondicion());
                    String t_next = TAC_Generator.newEtiqueta ();
                    TAC_Generator.generarCuadIfFalse (tCond, t_next);
                    TAC_Generator.unir (cb.getTac());
                    TAC_Generator.generarCuadSaltoIncondicional (L_end); //Un salto luego del decide 
                    TAC_Generator.generarLabel (t_next);
                }
                TAC_Generator.unir(tacElse);
                TAC_Generator.generarLabel (L_end);
                
                TokenDecide bloques = new TokenDecide();
                for (CondicionBloque cb : condi) {
                   bloques.addCondiBloque(cb);
                } 

                bloques.setBloqueElse(blo);
                deciP.setBloqueDecide(bloques); // Guardamos la estructura interna.
                deciP.setAmbitoLocal(entornoActual); // Este de aqui basicamente no se ocupa, puesto que guardamos las estrcuturas de los bloques por aparte.
                cerrarAmbito(); 
                insertarNuevoToken(deciP);
                pilaEstrucControl.pop();

            :} // Posiblemente requiramos crear una ambito especifico para el else.
         
         | decideParteIzquierda:izq error condiciones END DECIDE DELIMITADOR {: System.err.println(" -> Error: Se esperaba 'of' despues de 'decide'." + "Fila: " + izqleft + ", Columna: " + izqright); cerrarAmbito(); :}
         | decideParteIzquierda:izq error END DECIDE DELIMITADOR {: System.err.println(" -> Error: Condiciones no validas en estructura decide." + "Fila: " + izqleft + ", Columna: " + izqright); cerrarAmbito(); :}
         | decideParteIzquierda:izq condiciones error DECIDE DELIMITADOR  {: System.err.println(" -> Error: Se esperaba 'end' antes de 'decide'." + "Fila: " + izqleft + ", Columna: " + izqright); cerrarAmbito();  :}
         | decideParteIzquierda:izq condiciones END error DELIMITADOR {: System.err.println(" -> Error: Se esperaba 'decide' despues de 'end'." + "Fila: " + izqleft + ", Columna: " + izqright); cerrarAmbito(); :};

// Esta es la que se usa para DECIDE OF
condiciones ::= condicion:cond FLECHA {: TAC_Generator.iniciarBuffer(); :} bloque:blo {:
                        List<Cuad> tacBloque = TAC_Generator.finalizarBuffer();
                        if (!"boolean".equals(cond.getTipo())) {
                            System.err.println(" -> Error semantico: la condicion en 'decide' debe ser de tipo boolean, pero se recibio '" + cond.getTipo() + "'" + "Fila: " + condleft + ", Columna: " + condright);
                            aumentarCountErroresSemanticos();
                        }
                        CondicionBloque cb = new CondicionBloque (cond, blo);
                        cb.setTac(tacBloque);
                        List<CondicionBloque> lista = new ArrayList<>();
                        lista.add(cb);
                        RESULT = lista;
                    :}
                | condiciones:lista condicion:cond FLECHA {: TAC_Generator.iniciarBuffer(); :} bloque:blo {: 
                        List<Cuad> tacBloque = TAC_Generator.finalizarBuffer();
                        if (!"boolean".equals(cond.getTipo())) {
                            System.err.println(" -> Error semantico: la condicion en 'decide' debe ser de tipo boolean, pero se recibio '" + cond.getTipo() + "'" + "Fila: " + condleft + ", Columna: " + condright);
                            aumentarCountErroresSemanticos();
                        }
                        CondicionBloque cb = new CondicionBloque (cond, blo);
                        cb.setTac(tacBloque);
                        lista.add(cb);
                        RESULT = lista;
                    :};

// Esta parte es mas general y es para cada una 
condicion ::= PAREN_I expresion:expr PAREN_D {: // Esto probablemente tenga una forma diferente despues, la parte de expr va a ser diferente y se tendra que cambiar esta validacion.
                    String tipo = expr.getTipo();
                    if (!"boolean".equals(tipo)) {
                        System.err.println(" -> Error semantico: la condicion en 'decide' debe ser de tipo boolean, pero se recibio '" + tipo + "'" + "Fila: " + exprleft + ", Columna: " + exprright);
                        RESULT = new TipoExpresiones("error");
                        aumentarCountErroresSemanticos();
                    } else {
                        RESULT = expr;
                    }
                :}
            | error expresion:expr PAREN_D {: System.err.println(" -> Error: Se esperaba parentesis de apertura 'є' en condicion." + "Fila: " + exprleft + ", Columna: " + exprright); RESULT = new TipoExpresiones("error"); :}
            | PAREN_I expresion:expr error {: System.err.println(" -> Error: Se esperaba parentesis de cierre 'э' en condicion." + "Fila: " + exprleft + ", Columna: " + exprright); RESULT = new TipoExpresiones("error"); :}
            | PAREN_I:pare error PAREN_D {: System.err.println(" -> Error: Expresion no valida en condicion." + "Fila: " + pareleft + ", Columna: " + pareright); RESULT = new TipoExpresiones("error"); :};


loopInicio ::= LOOP {: 

                // En esta parte debemos de crear el entorno y crear al token que almacenara ese entorno.
                // para que una vez que finalice el loop, agreguemos al entorno padre el token

                crearAmbito(); // Crear el ambito.
                String lStart = TAC_Generator.newEtiqueta();
                String lExit = TAC_Generator.newEtiqueta();
                pilaEstrucControl.push("loop"); // Registrar el la pila que hay una nueva estructura.
                pilaLoopStartLabels.push(lStart);
                pilaLoopExitLabels.push(lExit);

                TAC_Generator.generarLabel(lStart); // L_start
                TAC_Generator.iniciarBuffer();
            :};

loop ::= loopInicio:loopIni sentencias EXIT WHEN condicion:cond DELIMITADOR END LOOP DELIMITADOR {:
                // Mantenemos el cuerpo del loop
                List<Cuad> cuerpo = TAC_Generator.finalizarBuffer();
                TAC_Generator.unir(cuerpo);

                // Se valida que la expresion sea booleana sino se fuerza un false
                String tCond = operandoString(cond);
                if (!"boolean".equals(cond.getTipo())) {
                    System.err.println(" -> Error semantico: condicion de loop debe ser booleana, se recibio '" + cond.getTipo() + "'." + "Fila: " + condleft + ", Columna: " + condright);
                    aumentarCountErroresSemanticos();
                    if ("null".equals(tCond)) {
                        tCond = TAC_Generator.newTemp();
                        TAC_Generator.generarCuad("=", "0", null, tCond); // false por defecto
                    }
                }

                // exit when cond  => si cond TRUE, salir; si FALSE, repetir
                simbolos.TAC_Generator.generarCuad("IF", tCond, null, pilaLoopExitLabels.peek());
                simbolos.TAC_Generator.generarCuadSaltoIncondicional(pilaLoopStartLabels.peek());
                simbolos.TAC_Generator.generarLabel(pilaLoopExitLabels.peek());

                pilaLoopStartLabels.pop();
                pilaLoopExitLabels.pop();
                pilaEstrucControl.pop();
                Token estructura = new Token("otro_loop_" + (contadorLoop++), "estructura", "local", null, "loop", loopInileft, loopIniright);
                estructura.setAmbitoLocal(entornoActual);
                cerrarAmbito();
                insertarNuevoToken(estructura);
            :};

// El for debe de ser una asignacion y la variable debe de estar previamente creada
forInt ::= FOR IDENTIFICADOR:id ASIGNACION expresionAritmetica:exp {:
                crearAmbito();
                pilaEstrucControl.push("for");
                Token varTok = entornoActual.buscar(id);
                if (varTok == null) {
                    System.err.println(" -> Error semantico: La variable '" + id + "' no ha sido declarada para el for." + "Fila: " + idleft + ", Columna: " + idright);
                    aumentarCountErroresSemanticos();
                } else if (!"int".equals(varTok.getTipo())) {
                    System.err.println(" -> Error semantico: La variable de control '" + id + "' debe ser int, tipo real: " + varTok.getTipo() + "Fila: " + idleft + ", Columna: " + idright);
                    aumentarCountErroresSemanticos();
                }
                if (!"int".equals(exp.getTipo())) {
                    System.err.println(" -> Error semantico: La expresion inicial del for debe ser int, tipo real: " + exp.getTipo() + "Fila: " + expleft + ", Columna: " + expright);
                    aumentarCountErroresSemanticos();
                }
                // TAC inicial
                String initVal = operandoString(exp);
                simbolos.TAC_Generator.generarCuadAsignacion(initVal, id, exp.getTipo());

                String fStart = simbolos.TAC_Generator.newEtiqueta();
                String fExit  = simbolos.TAC_Generator.newEtiqueta();
                pilaForStartLabels.push(fStart);
                pilaForExitLabels.push(fExit);
                forVarControlNombre = id;
            :};


for ::= forInt:init STEP INT_LITERAL:step TO expresionAritmetica:lim DO {:
            if (forVarControlNombre == null) {
                System.err.println(" -> Error semantico: variable de control del for no registrada." + "Fila: " + initleft + ", Columna: " + initright);
            }
            if (step.intValue() <= 0) {
                System.err.println(" -> Error semantico: STEP debe ser entero positivo, recibido: " + step + "Fila: " + stepleft + ", Columna: " + stepright);
                aumentarCountErroresSemanticos();
            }
            if (!"int".equals(lim.getTipo())) {
                System.err.println(" -> Error semantico: limite del for debe ser int, recibido: " + lim.getTipo() + "Fila: " + limleft + ", Columna: " + limright);
                aumentarCountErroresSemanticos();
            }
            String fStart = pilaForStartLabels.peek();
            String fExit  = pilaForExitLabels.peek();
            TAC_Generator.generarLabel(fStart);
            String limValue = operandoString(lim);
            String tCond = TAC_Generator.newTemp();
            simbolos.TAC_Generator.generarCuad("<=", forVarControlNombre, limValue, tCond, "boolean");
            simbolos.TAC_Generator.generarCuadIfFalse(tCond, fExit);

            TAC_Generator.iniciarBuffer();
        :} bloque:blo {:
            List<Cuad> bodyFor = simbolos.TAC_Generator.finalizarBuffer();
            simbolos.TAC_Generator.unir(bodyFor);

            // step
            String stepLit = step.toString();
            String tInc = simbolos.TAC_Generator.newTemp();
            simbolos.TAC_Generator.generarCuad("+", forVarControlNombre, stepLit, tInc, "int");
            simbolos.TAC_Generator.generarCuadAsignacion(tInc, forVarControlNombre, "int");

            // Bucle del for
            simbolos.TAC_Generator.generarCuadSaltoIncondicional(pilaForStartLabels.peek());
            simbolos.TAC_Generator.generarLabel(pilaForExitLabels.peek());

            pilaForStartLabels.pop();
            pilaForExitLabels.pop();
            pilaEstrucControl.pop();
            forVarControlNombre = null;

            Token estructura = new Token("otro_for_" + contadorFor++, "estructura", "local", null, "for", initleft, initright);
            estructura.setAmbitoLocal(entornoActual);
            insertarNuevoToken(blo);
            cerrarAmbito();
            insertarNuevoToken(estructura);
        :}
     | forInt:init STEP INT_LITERAL:step DOWNTO expresionAritmetica:lim DO {:
            if (forVarControlNombre == null) {
                System.err.println(" -> Error semantico: variable de control del for no registrada." + "Fila: " + initleft + ", Columna: " + initright);
            }
            if (step.intValue() <= 0) {
                System.err.println(" -> Error semantico: STEP debe ser entero positivo, recibido: " + step + "Fila: " + stepleft + ", Columna: " + stepright);
                aumentarCountErroresSemanticos();
            }
            if (!"int".equals(lim.getTipo())) {
                System.err.println(" -> Error semantico: limite del for debe ser int, recibido: " + lim.getTipo() + "Fila: " + limleft + ", Columna: " + limright);
                aumentarCountErroresSemanticos();
            }
            String L_start = TAC_Generator.newEtiqueta();
            String L_exit  = TAC_Generator.newEtiqueta();
            pilaForStartLabels.push(L_start);
            pilaForExitLabels.push(L_exit);
            TAC_Generator.generarLabel(L_start);
            TAC_Generator.iniciarBuffer();
        :} bloque:blo {:
            java.util.List<Cuad> cuerpo = TAC_Generator.finalizarBuffer();
            TAC_Generator.unir(cuerpo);

            String var = forVarControlNombre;
            String endVal = operandoString(lim);
            if (endVal == null || "null".equals(endVal)) endVal = "0";

            String tCond = TAC_Generator.newTemp();
            TAC_Generator.generarCuad(">=", var, endVal, tCond);
            TAC_Generator.generarCuadIfFalse(tCond, pilaForExitLabels.peek());

            String tDec = TAC_Generator.newTemp();
            TAC_Generator.generarCuad("-", var, step.toString(), tDec);
            TAC_Generator.generarCuadAsignacion(tDec, var, "int");

            TAC_Generator.generarCuadSaltoIncondicional(pilaForStartLabels.peek());
            TAC_Generator.generarLabel(pilaForExitLabels.peek());

            pilaForExitLabels.pop();
            pilaForStartLabels.pop();
            pilaEstrucControl.pop();
            forVarControlNombre = null;

            Token estructura = new Token("otro_for_" + contadorFor++, "estructura", "local", null, "for", initleft, initright);
            estructura.setAmbitoLocal(entornoActual);
            insertarNuevoToken(blo);
            cerrarAmbito();
            insertarNuevoToken(estructura);
        :};

var ::= LET tipoDatoVariable:tipo IDENTIFICADOR:id DELIMITADOR {: 
            if (entornoActual.buscar(id) != null) {
                System.err.println(" -> Error semantico: la variable '" + id + "' ya fue declarada. Fila: " + idleft + ", Columna: " + idright);
                aumentarCountErroresSemanticos();
            } else {
                // nombre, tipo, ambito, valor, categoria, linea, columna
                Token tokenVar = new Token(id, tipo, "local", null, "variable", idleft, idright);
                insertarNuevoToken(tokenVar);
                //TAC_Generator.generarCuadAsignacion (valorDefault (tipo), id, tipo.toString());
                TAC_Generator.registrarTipo(id, tipo.toString());
                mostrarMensajeTS("\n >> Definicion var registrada. var \n");

            }
        :}
        | LET tipoDatoVariable:tipo error DELIMITADOR {: System.err.println(" -> Error sintactico: Se debe de colocar un identificador al definir una variable." + "Fila: " + tipoleft + ", Columna: " + tiporight); :};
        //| LET error IDENTIFICADOR:di DELIMITADOR {: System.err.println(" -> Error sintactico: Se debe de definir el tipo de dato al crear una variable." + "Fila: " + idleft + ", Columna: " + idright)); :}; /* | LET tipoDatoVariable IDENTIFICADOR ASIGNACION expresion DELIMITADOR    -- Se cambio esto por que era lo mismo */

varAsignacion ::= IDENTIFICADOR:id ASIGNACION expresion:exp DELIMITADOR {: 
                    Token token = entornoActual.buscar(id);
                    if (token == null) {
                        System.err.println(" -> Error semantico: La variable '" + id + "' no ha sido declarada. Fila: " + idleft + ", Columna: " + idright);
                        aumentarCountErroresSemanticos();
                    } else if (!token.getTipo().equals(exp.tipoDato)) {
                        System.err.println(" -> Error semantico: Tipo incompatible en asignacion. Se esperaba '" + token.getTipo() + "', pero se recibio '" + exp.tipoDato + "'. Fila: " + idleft + ", Columna: " + idright);
                        aumentarCountErroresSemanticos();
                    } else {
                        // Generamos TAC: Si la expresión producjo temporales usamos el ultimo temp, si es hoja usamos el valor directo.
                        String fuente = (exp.temp != null) ? exp.temp : null;
                        System.out.println("Temporal: " + exp.temp);
                        if (fuente == null) {
                            // Usar el valor literal
                            if (exp.valorI != null) {
                                fuente = exp.valorI.toString();
                            } else if (exp.valorF != null) {
                                fuente = exp.valorF.toString();
                            } else if (exp.valorS != null) {
                                fuente = exp.valorS;
                            } else if (exp.valorC != null) {
                                fuente = exp.valorC.toString();
                            } else if (exp.valorB != null) {
                                fuente = exp.valorB.toString();
                            }
                        }
                        if (fuente == null) {
                            System.err.println ("Error: No se pudo obtener el valor de la expresion para asignar a la variable '" + id + "'. Fila: " + idleft + ", Columna: " + idright);
                        } else {
                            TAC_Generator.generarCuadAsignacion (fuente, id, token.getTipo());
                        }
                        //token.setValor(exp.valor); // actualizar el valor de la variable
                        // token.setValor(null);
                        mostrarMensajeTS("\n >> Var globar registrada. varAsignacion\n");
                        
                    }
                :};
                 
varCyAsignacion ::= LET tipoDatoVariable:tipo IDENTIFICADOR:id ASIGNACION expresion:exp DELIMITADOR {: 
                        if (entornoActual.buscar(id) != null) {
                            System.err.println(" -> Error semantico: La variable '" + id + "' ya fue declarada. Fila: " + idleft + ", Columna: " + idright);
                            aumentarCountErroresSemanticos();
                        } else {
                            Token tokenLocal = new Token(id, tipo, "local", null, "variable", idleft, idright);

                            if (tipo.equals(exp.tipoDato)) {
                                String fuente = exp.temp;
                                if (fuente == null) {
                                    if (exp.valorI != null)      fuente = exp.valorI.toString();
                                    else if (exp.valorF != null) fuente = exp.valorF.toString();
                                    else if (exp.valorS != null) fuente = exp.valorS;
                                    else if (exp.valorC != null) fuente = exp.valorC.toString();
                                    else if (exp.valorB != null) fuente = exp.valorB.toString();
                                }
                                if (fuente == null || "null".equals(fuente)) {
                                    fuente = valorDefault(tipo);
                                }
                                TAC_Generator.generarCuadAsignacion(fuente, id, tipo.toString());
                                insertarNuevoToken(tokenLocal);
                         
                            } else {
                                System.err.println(" -> Error semantico: El tipo de la variable '" + id + "' no es compatible con el tipo de la expresion. Se esperaba '" + tipo + "', pero se recibio '" + exp.tipoDato + "'. Fila: " + idleft + ", Columna: " + idright);
                                aumentarCountErroresSemanticos();
                                TAC_Generator.generarCuadAsignacion(valorDefault(tipo), id, tipo.toString());
                            }

                            mostrarMensajeTS("\n >> Variable local registrada. varCyAsignacion \n");
                        }
                    :}
                  | LET:le tipoDatoVariable IDENTIFICADOR ASIGNACION error DELIMITADOR {: System.err.println(" -> Error: Expresion no valida despues de '='." + "Fila: " + leleft + ", Columna: " + leright); :}
                  | LET:le tipoDatoVariable IDENTIFICADOR error  {: System.err.println(" -> Error: Se esperaba '=' despues del identificador." + "Fila: " + leleft + ", Columna: " + leright); :}
                  | LET:le tipoDatoVariable error ASIGNACION expresion DELIMITADOR {: System.err.println(" -> Error: Identificador no valido." + "Fila: " + leleft + ", Columna: " + leright); :}
                  | LET:le error IDENTIFICADOR ASIGNACION expresion DELIMITADOR {: System.err.println(" -> Error: Tipo de dato no valido." + "Fila: " + leleft + ", Columna: " + leright); :};

/* FIX: ERROR en global para que detecte 'global tipo identificador...' */
/* FIXED: Se agrega produ de error en falta de global */
varGlobal ::= GLOBAL tipoDatoVariable:tipo IDENTIFICADOR:id DELIMITADOR {:
                    if (entornoActual == null) {
                        entornoActual = new Ambitos (null);
                    }
                    if (entornoActual.buscar(id) != null) {
                        System.err.println("-> Error semantico: La variable global '" + id + "' ya fue declarada."  + "Fila: " + idleft + ", Columna: " + idright);
                        aumentarCountErroresSemanticos();
                    } else {
                        //String nombre, String tipo, String ambito, Object valor, String categoria, int linea, int columna
                        Token tokenGlobal = new Token (id, tipo, "global", null, "global", idleft, idright );
                        if (entornoActual.insertarNuevoToken(tokenGlobal)) {
                            String def = valorDefault(tipo);
                            TAC_Generator.registrarTipo(id, tipo.toString());
                            TAC_Generator.generarCuadAsignacion(def, id, tipo.toString());
                        }
                        mostrarMensajeTS("\n >> Var globar registrada. \n");
                    }
                    mostrarMensajeTS(">> Reconocida variable global simple");
                :}
            | GLOBAL tipoDatoVariable:tipo IDENTIFICADOR:id ASIGNACION expresion:exp DELIMITADOR {: 
                    if (entornoActual == null) {
                        entornoActual = new Ambitos (null);
                    }
                    if (entornoActual.buscar(id) != null) {
                        System.err.println("-> Error semantico: la variable global '" + id + "' ya fue declarada." + "Fila: " + idleft + ", Columna: " + idright);
                        aumentarCountErroresSemanticos();

                    } else if (!tipo.equals(exp.tipoDato)) {
                        System.err.println("-> Error semantico: El tipo de la variable global no es compatible con el tipo de la expresion que se le asigna. Se esperaba '" + tipo + "', pero se recibió '" + exp.tipoDato + "'." + "Fila: " + idleft + ", Columna: " + idright);
                        aumentarCountErroresSemanticos();
                    } else {
                        Token tokenGlobal = new Token (id, tipo, "global", null, "global", idleft, idright );
                        if (entornoActual.insertarNuevoToken(tokenGlobal)) {
                            // Obtener la fuente
                            String fuente = exp.temp;
                            if (fuente == null) {
                                if (exp.valorI != null) {
                                    fuente = exp.valorI.toString();
                                } else if (exp.valorF != null) {
                                    fuente = exp.valorF.toString();
                                } else if (exp.valorS != null) {
                                    fuente = exp.valorS;
                                } else if (exp.valorC != null) {
                                    fuente = exp.valorC.toString();
                                } else if (exp.valorB != null) {
                                    fuente = exp.valorB.toString();
                                }
                            }
                            if (fuente == null) {
                                fuente = valorDefault (tipo);
                            }
                            
                            TAC_Generator.generarCuadAsignacion (fuente, id, tipo.toString());
                        }
                        mostrarMensajeTS("\n >> Var globar con expresion registrada. \n");

                    }
                :}
                // Estos errores estan dando shift reduce, probablemente hay alguna otra expresion que tambien los tenga.
            // | error tipoDatoVariable IDENTIFICADOR DELIMITADOR {: System.err.println(" -> Error: Se esperaba la palabra 'global' al inicio de la declaracion." + "Fila: " + gloleft + ", Columna: " + gloright); :};
            | GLOBAL:glo error IDENTIFICADOR DELIMITADOR {: System.err.println(" -> Error sintactico: se debe de definir el tipo de dato para la variable global." + "Fila: " + gloleft + ", Columna: " + gloright); :}
            | GLOBAL:glo tipoDatoVariable error DELIMITADOR {: System.err.println(" -> Error sintactico: Se debe de definir una identificador para la variable global." + "Fila: " + gloleft + ", Columna: " + gloright); :}
            | GLOBAL:glo tipoDatoVariable IDENTIFICADOR error {: System.err.println(" -> Error sintactico: Se debe de colocar un delimitador al definir una variable global." + "Fila: " + gloleft + ", Columna: " + gloright); :};





// /* ##### Seccion para las expresiones ######*/
expresion ::= expresionLogica:exp {: RESULT = exp; mostrarMensaje("\n Expresion en validacion -> expresion completa: inicio de la derivacion" + "Tipo final:" + exp.getTipo() + "\n"); :};


/* Modificar las derivacion para expresion logica con el fin de que pueda volver a arriba:  expresionLogica AND expresionLogica| expresionLogica OR expresionLogica*/
expresionLogica ::= expresionLogica:izq AND expresionRelacional:der {: 
                    if (!"boolean".equals(izq.tipoDato) || !"boolean".equals(der.tipoDato)) {
                        System.err.println(" -> Error semantico: El operador 'AND' requiere expresiones booleanas." + "Fila: " + izqleft + ", Columna: " + izqright);
                        aumentarCountErroresSemanticos();
                        RESULT = new TipoExpresiones("error");
                    } else {
                        mostrarMensaje("\n Expresion en validacion -> expr rela: and \n");
                        String a1 = izq.temp != null ? izq.temp : (izq.valorB != null ? izq.valorB.toString() : "null");
                        String a2 = der.temp != null ? der.temp : (der.valorB != null ? der.valorB.toString() : "null");
                        String t = TAC_Generator.newTemp();
                        izq.append(der);
                        TAC_Generator.generarCuad("AND", a1, a2, t, "boolean"); // luego veo como representarlo
                        TipoExpresiones res = new TipoExpresiones("boolean");
                        res.cuads = izq.cuads;
                        res.temp = t;
                        RESULT = res;
                    }
                :}
                | expresionLogica:izq OR expresionRelacional:der {: 
                    if (!"boolean".equals(izq.tipoDato) || !"boolean".equals(der.tipoDato)) {
                        System.err.println(" -> Error semantico: operador 'OR' requiere expresiones booleanas." + "Fila: " + izqleft + ", Columna: " + izqright);
                        aumentarCountErroresSemanticos();
                        RESULT = new TipoExpresiones("error");
                    } else {
                        mostrarMensaje("\n Expresion en validacion -> expr rela: or \n");
                        String a1 = izq.temp != null ? izq.temp : (izq.valorB != null ? izq.valorB.toString() : "null");
                        String a2 = der.temp != null ? der.temp : (der.valorB != null ? der.valorB.toString() : "null");
                        String t = TAC_Generator.newTemp();
                        izq.append(der);
                        TAC_Generator.generarCuad("OR", a1, a2, t, "boolean"); // igual que arriba luego veo como representarlo
                        TipoExpresiones res = new TipoExpresiones("boolean");
                        res.cuads = izq.cuads;
                        res.temp = t;
                        RESULT = res;
                    }
                :}
                | NOT expresionLogica:exp {: 
                    if (!"boolean".equals(exp.tipoDato)) {
                        System.err.println(" -> Error semantico: operador 'NOT' requiere expresion booleana." + "Fila: " + expleft + ", Columna: " + expright);
                        aumentarCountErroresSemanticos();
                        RESULT = new TipoExpresiones("error");
                    } else {
                        mostrarMensaje("\n Expresion en validacion -> expr rela: not  \n");
                        String a1 = exp.temp != null ? exp.temp : (exp.valorB != null ? exp.valorB.toString() : "null");
                        String t = TAC_Generator.newTemp();
                        TAC_Generator.generarCuadUnario("NOT", a1, t, "boolean");
                        TipoExpresiones res = new TipoExpresiones("boolean");
                        res.cuads = exp.cuads;
                        res.temp = t;
                        RESULT = res;
                    }
                :}
                | expresionRelacional:exp {: // En teoria esta deveria de dejar pasar el valor directo
                    RESULT = exp;
                    mostrarMensaje("\n Expresion en validacion -> expr logi: expr rela\n");
                    
                :};

                  

expresionRelacional ::= expresionAritmetica:izq IGUAL expresionAritmetica:der {:  // En esto podriamos separar las validaciones para que den errores mas explicitos.
                            if (!tiposIguales(izq, der) || !tipoPermitidoComparacion(izq.tipoDato, "==")) {
                                System.err.println(" -> Error semantico: La comparacion '==' no es valida entre tipos '" + izq.tipoDato + "' y '" + der.tipoDato + "'." + "Fila: " + izqleft + ", Columna: " + izqright);
                                aumentarCountErroresSemanticos();
                                RESULT = new TipoExpresiones("error");
                            } else {
                                mostrarMensaje("\n Expresion en validacion -> expr rela: igual\n");
                                String a1 = operandoString (izq);
                                String a2 = operandoString (der);
                                String t = TAC_Generator.newTemp();
                                // izq.append(der);
                                TAC_Generator.generarCuad("==", a1, a2, t, "boolean");
                                TipoExpresiones res = new TipoExpresiones("boolean");
                                // res.cuads = izq.cuads;
                                res.temp = t;
                                RESULT = res;
                            }
                        :}
                        | expresionAritmetica:izq DIFERENTE expresionAritmetica:der {: 
                            if (!tiposIguales(izq, der) || !tipoPermitidoComparacion(izq.tipoDato, "!=")) {
                                System.err.println(" -> Error semantico: La comparación '!=' no es valida entre tipos '" + izq.tipoDato + "' y '" + der.tipoDato + "'." + "Fila: " + izqleft + ", Columna: " + izqright);
                                aumentarCountErroresSemanticos();
                                RESULT = new TipoExpresiones("error");
                            } else {
                                mostrarMensaje("\n Expresion en validacion -> expr rela: diferente \n");
                                String a1 = operandoString(izq);
                                String a2 = operandoString(der);
                                String t = TAC_Generator.newTemp();
                                // izq.append(der);
                                TAC_Generator.generarCuad("!=", a1, a2, t, "boolean");
                                TipoExpresiones res = new TipoExpresiones("boolean");
                                // res.cuads = izq.cuads;
                                res.temp = t;
                                RESULT = res;
                            }
                        :}
                        | expresionAritmetica:izq MENOR expresionAritmetica:der {: 
                            if (!tiposIguales(izq, der) || !tipoPermitidoComparacion(izq.tipoDato, "<")) {
                                System.err.println(" -> Error semantico: La comparación '<' no es valida entre tipos '" + izq.tipoDato + "' y '" + der.tipoDato +"'." + "Fila: " + izqleft + ", Columna: " + izqright);
                                aumentarCountErroresSemanticos();
                                RESULT = new TipoExpresiones("error");
                            } else {
                                mostrarMensaje("\n Expresion en validacion -> expr rela: menor\n");
                                String a1 = operandoString(izq);
                                String a2 = operandoString(der);
                                String t = TAC_Generator.newTemp();
                                // izq.append(der);
                                TAC_Generator.generarCuad ("<", a1, a2, t, "boolean");
                                TipoExpresiones res = new TipoExpresiones("boolean");
                                // res.cuads = izq.cuads;
                                res.temp = t;
                                RESULT = res;
                            }
                        :}
                        | expresionAritmetica:izq MAYOR expresionAritmetica:der {: 
                            if (!tiposIguales(izq, der) || !tipoPermitidoComparacion(izq.tipoDato, ">")) {
                                System.err.println(" -> Error semantico: La comparacion '>' no es valida entre tipos '" + izq.tipoDato + "' y '" + der.tipoDato + "'." + "Fila: " + izqleft + ", Columna: " + izqright);
                                aumentarCountErroresSemanticos();
                                RESULT = new TipoExpresiones("error");
                            } else {
                                mostrarMensaje("\n Expresion en validacion -> expr rela: mayor\n");
                                String a1 = operandoString(izq);
                                String a2 = operandoString(der);
                                String t = TAC_Generator.newTemp();
                                // izq.append(der);
                                TAC_Generator.generarCuad (">", a1, a2, t, "boolean");
                                TipoExpresiones res = new TipoExpresiones("boolean");
                                // res.cuads = izq.cuads;
                                res.temp = t;
                                RESULT = res;
                            }
                        :}
                        | expresionAritmetica:izq MENOR_IGUAL expresionAritmetica:der {: 
                            if (!tiposIguales(izq, der) || !tipoPermitidoComparacion(izq.tipoDato, "<=")) {
                                System.err.println(" -> Error semantico: La comparacion '<=' no es valida entre tipos '" + izq.tipoDato + "' y '" + der.tipoDato + "'." + "Fila: " + izqleft + ", Columna: " + izqright);
                                aumentarCountErroresSemanticos();
                                RESULT = new TipoExpresiones("error");
                            } else {
                                mostrarMensaje("\n Expresion en validacion -> expr rela: menor igual\n");
                                String a1 = operandoString(izq);
                                String a2 = operandoString(der);
                                String t = TAC_Generator.newTemp();
                                // izq.append(der);
                                TAC_Generator.generarCuad ("<=", a1, a2, t, "boolean");
                                TipoExpresiones res = new TipoExpresiones("boolean");
                                // res.cuads = izq.cuads;
                                res.temp = t;
                                RESULT = res;
                            }
                        :}
                        | expresionAritmetica:izq MAYOR_IGUAL expresionAritmetica:der {: 
                            if (!tiposIguales(izq, der) || !tipoPermitidoComparacion(izq.tipoDato, ">=")) {
                                System.err.println(" -> Error semantico: La comparacion '>=' no es valida entre tipos '" + izq.tipoDato + "' y '" + der.tipoDato + "'." + "Fila: " + izqleft + ", Columna: " + izqright);
                                aumentarCountErroresSemanticos();
                                RESULT = new TipoExpresiones("error");
                            } else {
                                mostrarMensaje("\n Expresion en validacion -> expr rela: mayor igual\n");
                                String a1 = operandoString(izq);
                                String a2 = operandoString(der);
                                String t = TAC_Generator.newTemp();
                                // izq.append(der);
                                TAC_Generator.generarCuad (">=", a1, a2, t, "boolean");
                                TipoExpresiones res = new TipoExpresiones("boolean");
                                // res.cuads = izq.cuads;
                                res.temp = t;
                                RESULT = res;
                            }
                        :}
                      | expresionAritmetica:expr {: RESULT = expr; mostrarMensaje("\n Expresion en validacion -> expre rela: expr arit" + "Tipo final:" + expr.getTipo() + "\n"); :};
                      //| PAREN_I expresion:expr PAREN_D {: RESULT = expr; mostrarMensaje("\n Expresion en validacion -> expre rela: parentesis" + "Tipo final:" + expr.getTipo() + "\n"); :}; /* Con esta en teoria deberia de volver a arriba. */



expresionChar ::= CHAR_LITERAL:charLi {: 
                    RESULT = new TipoExpresiones("char", charLi); 
                :};

expresionString ::= STRING_LITERAL:strLit {: 
                    RESULT = new TipoExpresiones("string", strLit); 
                :};

expresionBooleana ::= TRUE{: 
                        RESULT = new TipoExpresiones("boolean", Boolean.TRUE); 
                    :}
                    | FALSE {: 
                        RESULT = new TipoExpresiones("boolean", Boolean.FALSE); 
                    :};


/* >> Expresiones aritmeticas */

expresionAritmetica ::= expresionSuma:expr {: RESULT = expr; mostrarMensaje("\n Expresion en validacion -> expr arit: inicip expr arit " + "Tipo final:" + expr.getTipo() + "\n");  :};


expresionSuma ::= expresionSuma:izq MAS expresionProducto:der {:
                    if (!tiposIgualesNumericos(izq, der)) {
                        System.err.println(" -> Error semantico: La suma requiere tipos numericos iguales (int o float) valor. Fila: " + izqleft + ", Columna: " + izqright);
                        aumentarCountErroresSemanticos();
                        RESULT = new TipoExpresiones("error");
                    } else {
                        mostrarMensaje("\n Expresion en validacion -> expr suma: suma\n");
                        if (izq == null || der == null) {
                            RESULT = new TipoExpresiones("error");
                            aumentarCountErroresSemanticos();
                        } else if ("error".equals(izq.getTipo()) || "error".equals(der.getTipo())) {
                            RESULT = new TipoExpresiones("error");
                        } else {
                            String tipoResultado = "int";
                            if ("float".equals(izq.getTipo()) || "float".equals(der.getTipo())) {
                                tipoResultado = "float";
                            }

                            String a1 = izq.temp != null ? izq.temp : (izq.valorI != null ? izq.valorI.toString() : (izq.valorF != null ? izq.valorF.toString() : izq.valorS));
                            String a2 = der.temp != null ? der.temp : (der.valorI != null ? der.valorI.toString() : (der.valorF != null ? der.valorF.toString() : der.valorS));

                            if (a1 == null){
                                a1 = "null";
                            }

                            if (a2 == null){
                                a2 = "null";
                            }

                            String tipoRes = tipoResultado;

                            String t = TAC_Generator.newTemp();
                            izq.append(der);
                            TAC_Generator.generarCuad ("+", a1, a2, t, tipoRes);
                            TipoExpresiones res = new TipoExpresiones (tipoResultado);
                            res.temp = t;
                            RESULT = res;
                        }
                    }
                :}
                | expresionSuma:izq MENOS expresionProducto:der {: 
                        if (!tiposIgualesNumericos(izq, der)) {
                            System.err.println(" -> Error semantico: La resta requiere tipos numericos iguales (int o float). Fila: " + izqleft + ", Columna: " + izqright);
                            aumentarCountErroresSemanticos();
                            RESULT = new TipoExpresiones("error");
                        } else {
                            mostrarMensaje("\n Expresion en validacion -> expr suma: resta\n");
                            if (izq == null || der == null) {
                                RESULT = new TipoExpresiones("error");
                            } else if ("error".equals(izq.getTipo()) || "error".equals(der.getTipo())) {
                                RESULT = new TipoExpresiones("error");
                            } else {
                                String tipoResultado = "int";
                                if ("float".equals(izq.getTipo()) || "float".equals(der.getTipo())) {
                                    tipoResultado = "float";
                                }

                                String a1 = izq.temp != null ? izq.temp : (izq.valorI != null ? izq.valorI.toString() : (izq.valorF != null ? izq.valorF.toString() : izq.valorS));
                                String a2 = der.temp != null ? der.temp : (der.valorI != null ? der.valorI.toString() : (der.valorF != null ? der.valorF.toString() : der.valorS));

                                if (a1 == null){
                                    a1 = "null";
                                }

                                if (a2 == null){
                                    a2 = "null";
                                }

                                String tipoRes = tipoResultado;

                                String t = TAC_Generator.newTemp();
                                izq.append(der);
                                TAC_Generator.generarCuad ("-", a1, a2, t, tipoRes);
                                TipoExpresiones res = new TipoExpresiones (tipoResultado);
                                res.temp = t;
                                RESULT = res;
                            }
                        }
                    :}
                | expresionProducto:expr {: RESULT = expr; mostrarMensaje("\n Expresion en validacion -> expr suma: expr prod \n"); :}
                | expresionSuma:expr MAS error {: System.err.println(" -> Error: Expresion no valida despues de '+'." + "Linea: " + exprleft + ", Columna: " + exprright); RESULT = new TipoExpresiones("error"); :}
                | expresionSuma:expr MENOS error {: System.err.println(" -> Error: Expresion no valida despues de '-'." + "Linea: " + exprleft + ", Columna: " + exprright); RESULT = new TipoExpresiones("error"); :};

expresionProducto ::= expresionProducto:izq MULTIPLICACION expresionPotencia:der {:
                    if (!tiposIgualesNumericos(izq, der)) {
                        System.err.println(" -> Error semantico: La multiplicacion requiere tipos numericos iguales (int o float). Fila: " + izqleft + ", Columna: " + izqright);
                        aumentarCountErroresSemanticos();
                        RESULT = new TipoExpresiones("error");
                    } else {
                        if (izq == null || der == null) {
                            RESULT = new TipoExpresiones ("error");
                        } else if ("error".equals(izq.getTipo()) || "error".equals(der.getTipo())) {
                            RESULT = new TipoExpresiones("error");
                        } else {
                            String tipoResultado = "int";
                            if ("float".equals(izq.getTipo()) || "float".equals(der.getTipo())) {
                                tipoResultado = "float";
                            }

                            String a1 = izq.temp != null ? izq.temp : (izq.valorI != null ? izq.valorI.toString() : (izq.valorF != null ? izq.valorF.toString() : izq.valorS));
                            String a2 = der.temp != null ? der.temp : (der.valorI != null ? der.valorI.toString() : (der.valorF != null ? der.valorF.toString() : der.valorS));

                            if (a1 == null){
                                a1 = "null";
                            }

                            if (a2 == null){
                                a2 = "null";
                            }

                            String tipoRes = tipoResultado;

                            String t = TAC_Generator.newTemp();
                            TAC_Generator.generarCuad ("*", a1, a2, t, tipoRes);

                            TipoExpresiones res = new TipoExpresiones (tipoResultado);
                            res.temp = t;
                            RESULT = res;
                        }
                    }
                    :}
                    | expresionProducto:izq DIVISION expresionPotencia:der {: 
                        if (!tiposIgualesNumericos(izq, der)) {
                            System.err.println(" -> Error semantico: La division requiere tipos numericos iguales (int o float). Fila: " + izqleft + ", Columna: " + izqright);
                            aumentarCountErroresSemanticos();
                            RESULT = new TipoExpresiones("error");
                        } else {
                            mostrarMensaje("\n Expresion en validacion -> expr prod div entera \n");
                            String a1 = izq.temp != null ? izq.temp : (izq.valorI != null ? izq.valorI.toString() : (izq.valorF != null ? izq.valorF.toString() : izq.valorS));
                            String a2 = der.temp != null ? der.temp : (der.valorI != null ? der.valorI.toString() : (der.valorF != null ? der.valorF.toString() : der.valorS));
                            if (a1 == null) a1 = "null";
                            if (a2 == null) a2 = "null";
                            String tipoRes = "float";
                            String t = TAC_Generator.newTemp();
                            izq.append(der);
                            TAC_Generator.generarCuad("/", a1, a2, t, tipoRes);
                            TipoExpresiones res = new TipoExpresiones("float");
                            res.cuads = izq.cuads;
                            res.temp = t;
                            RESULT = res;
                        }
                    :}
                    | expresionProducto:izq DIVISION_ENTERA expresionPotencia:der {: 
                        if (!"int".equals(izq.tipoDato) || !"int".equals(der.tipoDato)) {
                            System.err.println(" -> Error semantico: La division entera solo se permite entre enteros. Fila: " + izqleft + ", Columna: " + izqright);
                            aumentarCountErroresSemanticos();
                            RESULT = new TipoExpresiones("error");
                        } else {
                            mostrarMensaje("\n Expresion en validacion -> expr prod div entera \n");
                            String a1 = izq.temp != null ? izq.temp : (izq.valorI != null ? izq.valorI.toString() : (izq.valorF != null ? izq.valorF.toString() : izq.valorS));
                            String a2 = der.temp != null ? der.temp : (der.valorI != null ? der.valorI.toString() : (der.valorF != null ? der.valorF.toString() : der.valorS));
                            if (a1 == null) a1 = "null";
                            if (a2 == null) a2 = "null";
                            String tipoRes = "int";
                            String t = TAC_Generator.newTemp();
                            izq.append(der);
                            TAC_Generator.generarCuad("//", a1, a2, t, tipoRes);
                            TipoExpresiones res = new TipoExpresiones("int");
                            res.cuads = izq.cuads;
                            res.temp = t;
                            RESULT = res;
                        }
                    :}
                    | expresionProducto:izq MODULO expresionPotencia:der {: 
                        if (!"int".equals(izq.tipoDato) || !"int".equals(der.tipoDato)) {
                            System.err.println(" -> Error semantico: El modulo solo se permite entre enteros. Fila: " + izqleft + ", Columna: " + izqright);
                            aumentarCountErroresSemanticos();
                            RESULT = new TipoExpresiones("error");
                        } else {
                            mostrarMensaje("\n Expresion en validacion -> expr prod modulo \n");
                            String a1 = izq.temp != null ? izq.temp : (izq.valorI != null ? izq.valorI.toString() : (izq.valorF != null ? izq.valorF.toString() : izq.valorS));
                            String a2 = der.temp != null ? der.temp : (der.valorI != null ? der.valorI.toString() : (der.valorF != null ? der.valorF.toString() : der.valorS));
                            if (a1 == null) a1 = "null";
                            if (a2 == null) a2 = "null";
                            String tipoRes = "int";
                            String t = TAC_Generator.newTemp();
                            izq.append(der);
                            TAC_Generator.generarCuad("%", a1, a2, t, tipoRes);
                            TipoExpresiones res = new TipoExpresiones("int");
                            res.cuads = izq.cuads;
                            res.temp = t;
                            RESULT = res;
                        }
                    :}
                    | expresionPotencia:expr {: RESULT = expr; mostrarMensaje("\n Expresion en validacion -> expr prod exp poten\n"); :};


// Para este hay que validar si el exponente y la base son enteros y solo enteros. // "error".equals(base.getTipo()) || "error".equals(exp.getTipo()) ||
expresionPotencia ::= expresionFactor:base POTENCIA expresionPotencia:exp {: 
                    if (base == null || exp == null || !validarTipoEsperado("int|float", base) || !validarTipoEsperado("int", exp)) {
                        RESULT = new TipoExpresiones("error");
                        System.err.println(" -> Error semantico: Las potentencia debe de ser base int o float y el exponente debe ser int. Tipos definidos: Base -> '" + base.tipoDato + "' y Exponente -> '" + exp.tipoDato + "'." + "Linea: " + baseleft + ", Columna: " + baseright);
                        aumentarCountErroresSemanticos();
                    } else {
                        mostrarMensaje("\n Expresion en validacion -> expr prod potencia \n");
                        String a1 = base.temp != null ? base.temp : (base.valorI != null ? base.valorI.toString() : (base.valorF != null ? base.valorF.toString() : base.valorS));
                        String a2 = exp.temp != null ? exp.temp : (exp.valorI != null ? exp.valorI.toString() : (exp.valorF != null ? exp.valorF.toString() : exp.valorS));
                        if (a1 == null) a1 = "null";
                        if (a2 == null) a2 = "null";
                        String t = TAC_Generator.newTemp();
                        base.append(exp);
                        String tipoFinal = ("float".equals(base.tipoDato) || "float".equals(exp.tipoDato)) ? "float" : "int";
                        TAC_Generator.generarCuad("^", a1, a2, t, tipoFinal);
                        TipoExpresiones res = new TipoExpresiones(tipoFinal);
                        res.cuads = base.cuads;
                        res.temp = t;
                        RESULT = res;
                    }
                    :}
                    | expresionFactor:expr {: RESULT = expr; mostrarMensaje("\n Expresion en validacion -> po expr fac\n"); :};


expresionFactor ::= PAREN_I expresion:expr PAREN_D {: RESULT = expr; mostrarMensaje("\n Expresion en validacion -> expresionFactor: paren expr \n"); :}
                  | expresionNumerica:expr {: RESULT = expr; mostrarMensaje("\n Expresion en validacion -> fac exp num \n"); :}
                  | expresionAritmeticaUnaria:expr {: RESULT = expr; mostrarMensaje("\n Expresion en validacion -> fac uni \n"); :}
                  | expresionAritmeticaUnariaNegativa:expr {: RESULT = expr; mostrarMensaje("\n Expresion en validacion -> facuni nega \n"); :};
                //   | error {: System.err.println("Error: Expresion aritmetica no valida"); :};

expresionNumerica ::= INT_LITERAL:n {: 
                        RESULT = new TipoExpresiones("int", n); 
                        mostrarMensaje("\n Expresion en validacion -> num int \n"); 
                        
                        :}
                    | FLOAT_LITERAL:f  {: RESULT = new TipoExpresiones("float", f); mostrarMensaje("\n Expresion en validacion -> num flo \n"); :}
                    | IDENTIFICADOR:id {: 
                        // Pruebas TAC:
                        Token t = entornoActual != null ? entornoActual.buscar (id) : null;
                        if (t == null) {
                            System.err.println(" -> Error semantico: El identificador '" + id + "' no ha sido declarado. Fila: " + idleft + ", Columna: " + idright);
                            RESULT = new TipoExpresiones("error");
                        } else {
                            TipoExpresiones te = new TipoExpresiones (t.getTipo());
                            te.temp = id;
                            RESULT = te;
                        }
                        // RESULT = obtenerTipoIdentificador(id, idleft, idright); 
                        mostrarMensaje("\n Expresion en validacion -> num id \n");
                        // RESULT = te;
                    :}
                    | funcionLlamada:func {:
                        //TipoExpresiones funcTION = obtenerTipoFuncion(funcionActual, funcleft, funcright);
                        RESULT = func;
                        mostrarMensaje("\n Expresion en validacion -> num func\n");
                    :}
                    | obtenerElementoLista:ob {: 
                        // RESULT = obtenerTipoElementoLista(ob); 
                        RESULT = ob;//new TipoExpresiones("int"); //>> Esta se tiene que arrglar para que funcione con la funcion que deberia.
                        :}
                    | inputExpr:inp {:
                        RESULT = inp;
                    :}

                    // Esta parte es para intentar olucionar los problemas:
                    | expresionChar:charExp {: 
                        
                        mostrarMensaje("\n Expresion en validacion -> char \n");
                        RESULT = charExp;
                    :}
                    | expresionString:strExp {: 
                        
                        RESULT = strExp;
                        mostrarMensaje("\n Expresion en validacion -> String\n");
                    :}
                    | expresionBooleana:boolExp {: 
                        
                        RESULT = boolExp;
                        mostrarMensaje("\n Expresion en validacion -> expr booneana\n");
                    :}

                    | INT_LITERAL:n IDENTIFICADOR error
                      {: System.err.println(" -> Error: Numero seguido de identificador no es valido (ej: 2f5)." + "Linea: " + nleft + ", Columna: " + nright); RESULT = new TipoExpresiones("error",n);:}
                    | FLOAT_LITERAL:n IDENTIFICADOR error
                      {: System.err.println(" -> Error: Numero flotante seguido de identificador no es valido." + "Linea: " + nleft + ", Columna: " + nright); RESULT = new TipoExpresiones("error", n); :}; 
                    // Fin de la expresion.



// Faltan trabajar estas para que se validen semanticamente.
expresionAritmeticaUnaria ::= IDENTIFICADOR:id INCREMENTO {:
                                TipoExpresiones tipo = obtenerTipoIdentificador(id, idleft, idright);
                                System.out.println("Tipo obtenido para id '" + id + "': " + tipo.tipoDato);
                                if (!validarTipoEsperado("int|float", tipo)) {
                                    System.err.println(" -> Error semantico: El operador '++' no es valido para tipo '" + tipo.tipoDato + "'." + "Linea: " + idleft + ", Columna: " + idright);
                                    aumentarCountErroresSemanticos();
                                    RESULT = new TipoExpresiones("error");
                                } else {
                                    // Depende del tipo int o float se genera cuad diferente
                                    mostrarMensaje("\n Expresion en validacion -> Unaria incremento.\n");
                                    TipoExpresiones res = new TipoExpresiones(tipo.tipoDato); 
                                    String a1 = id; // el identificador como operando
                                    String t = TAC_Generator.newTemp();
                                    TAC_Generator.generarCuadUnario("++", a1, t, tipo.tipoDato);
                                    res.temp = t;
                                    RESULT = res;
                                }
                            :}
                            | IDENTIFICADOR:id DECREMENTO {:
                                TipoExpresiones tipo = obtenerTipoIdentificador(id, idleft, idright);
                                if (!validarTipoEsperado("int|float", tipo)) {
                                    System.err.println(" -> Error semantico: El operador '--' no es valido para tipo '" + tipo.tipoDato + "'." + "Linea: " + idleft + ", Columna: " + idright);
                                    aumentarCountErroresSemanticos();
                                    RESULT = new TipoExpresiones("error");
                                } else {
                                    RESULT = tipo;
                                    mostrarMensaje("\n Expresion en validacion -> Unaria decremento. \n");

                                    TipoExpresiones res = new TipoExpresiones(tipo.tipoDato); 
                                    String a1 = id; // el identificador como operando
                                    String t = TAC_Generator.newTemp();
                                    TAC_Generator.generarCuadUnario("--", a1, t, tipo.tipoDato);
                                    res.temp = t;
                                    RESULT = res;
                                }
                            :};
// Fin de la expresion unaria.


expresionAritmeticaUnariaNegativa ::= MENOS expresionNumerica:expr {: 
                                        if (!validarTipoEsperado("int|float", expr) || expr == null || "error".equals(expr.getTipo())) {
                                            System.err.println(" -> Error semantico: operador para pasar a negativo una operacion no es valido para tipo '" + expr.tipoDato + "''." + "Linea: " + exprleft + ", Columna: " + exprright);
                                            aumentarCountErroresSemanticos();
                                            RESULT = new TipoExpresiones("error");
                                        } else {
                                            //System.out.println("\n Expresion en validacion -> Unaria negativa.\n");
                                            mostrarMensaje("\n Expresion en validacion -> Unaria negativa.\n");


                                            // El argumento es numero (int o float)
                                            String a1 = expr.temp != null ? expr.temp : (expr.valorI != null ? expr.valorI.toString() : (expr.valorF != null ? expr.valorF.toString() : expr.valorS));
                                            if (a1 == null) {
                                                a1 = "null";
                                            }
                                            String t = TAC_Generator.newTemp();
                                            TAC_Generator.generarCuadUnario ("NEG", a1, t, expr.tipoDato); // voy a ver como manejo la negacion en representacion TAC
                                            TipoExpresiones res = new TipoExpresiones(expr.tipoDato);
                                            res.cuads = expr.cuads;
                                            res.temp = t;
                                            RESULT = res;
                                        }
                                    :};
// Fin de la expresion aritmetica unaria negativa.




/* ##### Seccion para el manejo de listas ######*/
lista ::= declaracionLista
        | creacionYAsignacionLista;

declaracionLista ::= LET tipoLista:tipo IDENTIFICADOR:id DELIMITADOR {: 
                    if (entornoActual.buscar(id) != null) {
                        System.err.println(" -> Error semantico: la lista '" + id + "' ya fue declarada. Fila: " + idleft + ", Columna: " + idright);
                        aumentarCountErroresSemanticos();
                    } else {
                        // nombre, tipoBase, ambito, valor, categoria, linea, columna
                        Token tokenLista = new Token(id, tipo.tipoBase, "local", null, "lista", idleft, idright);
                        tokenLista.setTipoLista(tipo);
                        insertarNuevoToken(tokenLista);
                        if (tipo.tamano != null) {
                            TAC_Generator.generarAlloc (id, tipo.tipoBase, tipo.tamano); // Con esto se busca hacer como un alloc dependiendo del tipo
                        }
                    }
                :};

creacionYAsignacionLista ::= LET tipoLista:tipo IDENTIFICADOR:id ASIGNACION LLAVE_I elementos:elems LLAVE_D DELIMITADOR {: 
                                if (entornoActual.buscar(id) != null) {
                                    System.err.println(" -> Error semantico: La lista '" + id + "' ya fue declarada. Fila: " + idleft + ", Columna: " + idright);
                                    aumentarCountErroresSemanticos();
                                
                                } else if (!elems.tipoDato.equals(tipo.tipoBase)) {
                                    System.err.println(" -> Error semantico: Los elementos de la lista '" + id + "' no coinciden con el tipo declarado. Se esperaba '" + tipo.tipoBase + "', pero se recibio '" + elems.tipoDato + "'. Fila: " + idleft + ", Columna: " + idright);
                                    aumentarCountErroresSemanticos();
                                } else if (tipo.tamano != null && elems.tamano > tipo.tamano) {
                                    System.err.println(" -> Error semantico: La lista '" + id + "' excede el tamaño declarado. Se esperaba maximo " + tipo.tamano + " elementos, pero se recibieron " + elems.tamano + ". Fila: " + idleft + ", Columna: " + idright);
                                    aumentarCountErroresSemanticos();
                                } else {
                                    Token tokenLista = new Token(id, tipo.tipoBase, "local", null, "lista", idleft, idright);
                                    tipo.setTamano(elems.tamano); // Modificamos el tamaño de la lista por si la definieron como []
                                    tokenLista.setTipoLista(tipo);
                                    insertarNuevoToken(tokenLista);
                                    // Set por cada elemento de lista
                                    for (int i = 0 ; i<elems.tamano ; i++) {
                                        TipoExpresiones elem = elementosBuffer.get(i);
                                        String valor = operandoString (elem);
                                        if (valor == null || "null".equals(valor)){
                                            // No me acuerdo los tipos exactos permitidos pero ponemos default en todos
                                            if ("int".equals(tipo.tipoBase))
                                                valor = "0";
                                            else if ("float".equals(tipo.tipoBase)) 
                                                valor = "0.0";
                                            else if ("boolean".equals(tipo.tipoBase)) 
                                                valor = "false";
                                            else if ("char".equals(tipo.tipoBase)) 
                                                valor = "'\\0'";
                                            else if ("string".equals(tipo.tipoBase)) 
                                                valor = "\"\"";
                                            else valor = "0";                                        
                                        }
                                        TAC_Generator.generarSet (id, Integer.toString(i), valor);
                                    }
                                    elementosBuffer.clear(); // para limpiar el buffer temporal
                                }
                            :};

elementos ::= elementoLista:elem {:
                ArrayList<TipoExpresiones> lista = new ArrayList<>();
                lista.add(elem);
                elementosBuffer = lista;

                // Un paquete con tipo y tamaño para la creacion
                TipoExpresiones tipoTamaño = new TipoExpresiones(elem.getTipo());
                tipoTamaño.tamano = 1;
                RESULT = tipoTamaño;
            :}
            | elementos:prev COMA elementoLista:elem {:
                elementosBuffer.add(elem);
                if (!prev.getTipo().equals(elem.getTipo())) {
                    System.err.println(" -> Error semantico: lista heterogenea. Se esperaba '" + prev.getTipo() + "', recibio '" + elem.getTipo() + "'." + "Linea: " + prevleft + ", Columna: " + prevright);
                    aumentarCountErroresSemanticos();
                    prev.tipoDato = "error";
                }
                prev.tamano++;
                RESULT = prev;
            :};


/* Este deberia ser expresion aritmetica en ves de -> INT_LITERAL*/
elementoLista ::= expresionAritmetica:op {:
    RESULT = op;
:};

modificarElementoLista ::= IDENTIFICADOR:id CORCHETE_I expresionAritmetica:indice CORCHETE_D ASIGNACION elementoLista:elem DELIMITADOR {:
                            Token tk = entornoActual.buscar(id);
                            if (tk == null || !"lista".equals(tk.getCategoria())) {
                                System.err.println(" -> Error semantico: '" + id + "' no es una lista declarada." + "Linea: " + idleft + ", Columna: " + idright);
                                aumentarCountErroresSemanticos();
                            } else {
                                if (!"int".equals(indice.getTipo())) {
                                    System.err.println(" -> Error semantico: el indice para lista '" + id + "' debe ser int, recibido '" + indice.getTipo() + "'." + "Linea: " + idleft + ", Columna: " + idright);
                                    aumentarCountErroresSemanticos();
                                }
                                TipoLista tl = tk.getTipoLista();
                                if (tl != null && tl.tipoBase != null && !tl.tipoBase.equals(elem.getTipo())) {
                                    System.err.println(" -> Error semantico: asignacion incompatible en lista '" + id + "'. Se esperaba '" + tl.tipoBase + "', recibio '" + elem.getTipo() + "'." + "Linea: " + idleft + ", Columna: " + idright);
                                    aumentarCountErroresSemanticos();
                                }
                                // Generacion de TAC set
                                String idx = operandoString(indice);
                                if (idx == null || "null".equals(idx)) idx = indice.temp;
                                String val = operandoString(elem);
                                if (val == null || "null".equals(val)) val = elem.temp;
                                simbolos.TAC_Generator.generarSet(id, idx, val);
                            }
                            RESULT = elem;
                        :};

obtenerElementoLista ::= IDENTIFICADOR:id CORCHETE_I expresionAritmetica:op CORCHETE_D {:
                        Token tk = entornoActual.buscar(id);
                        if (tk == null || !"lista".equals(tk.getCategoria())) {
                            System.err.println(" -> Error semantico: '" + id + "' no es una lista declarada." + "Linea: " + idleft + ", Columna: " + idright);
                            aumentarCountErroresSemanticos();
                            RESULT = new TipoExpresiones("error");
                        } else {
                            if (!"int".equals(op.getTipo())) {
                                System.err.println(" -> Error semantico: el indice para lista '" + id + "' debe ser int, recibido '" + op.getTipo() + "'" + "Linea: " + idleft + ", Columna: " + idright);
                                aumentarCountErroresSemanticos();
                            } else if (tk.getTipoLista() != null && tk.getTipoLista().tamano != null && op.valorI != null) {
                                int max = tk.getTipoLista().tamano;
                                if (op.valorI < 0 || op.valorI >= max) {
                                    System.err.println(" -> Advertencia: posible acceso fuera de rango en '" + id + "' indice " + op.valorI + ".Linea: " + idleft + ", Columna: " + idright);
                                }
                            }
                            // Generacin de TAC get 
                            String idx = operandoString(op);
                            if (idx == null || "null".equals(idx)) idx = op.temp;
                            String tRes = simbolos.TAC_Generator.generarGet(id, idx);

                            String tipoBase = (tk.getTipoLista() != null && tk.getTipoLista().tipoBase != null) ? tk.getTipoLista().tipoBase : tk.getTipo();
                            TipoExpresiones r = new TipoExpresiones(tipoBase);
                            r.temp = tRes;
                            RESULT = r;
                        }
                    :};

tipoLista ::= INT CORCHETE_I CORCHETE_D {: 
                TipoLista tipoL = new TipoLista("int", null);
                RESULT = tipoL;
            :}
           | CHAR CORCHETE_I CORCHETE_D {: 
                TipoLista tipoL = new TipoLista("char", null);
                RESULT = tipoL;
            :}

            // Aqui hay que agregar algo para validar que el numero sea un entero positivo mayor que cero.
           | INT CORCHETE_I INT_LITERAL:num CORCHETE_D {: 
                int tama = num;
                TipoLista tipoL = new TipoLista("int", tama);
                RESULT = tipoL;
            :}
           | CHAR CORCHETE_I INT_LITERAL:num CORCHETE_D {: 
                int tama = num;
                TipoLista tipoL = new TipoLista("char", tama);
                RESULT = tipoL;
            :};


