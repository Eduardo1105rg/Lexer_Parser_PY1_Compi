/* Definicion del pasers con CUP para el analisis de la gramatica.  */

/* Imports que se ocupan */
package parser;

import java_cup.runtime.*;
import lexer.*;
import java.io.*;
import lexer.Lexer;

// Estos serian para la parte del manejo de la tabla de simbolos.
import java.util.HashMap;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.Stack;

// Import las clases necesarias para la tabla de simbolos.
import simbolos.Token;
import simbolos.Ambitos;
import simbolos.TipoLista;
import simbolos.TipoExpresiones;


/* Parsers */
parser code {:
    private int errorContador = 0;

    public int getErrorContador() {
        return errorContador;
    }

    public void syntax_error(Symbol cur_token) {
        errorContador++;
        String tokenInfo = obtenerInfoToken(cur_token);
        System.err.println("Error sintactico en linea " + cur_token.left + 
                          ", columna " + cur_token.right + ": " + tokenInfo);
    }
    // Mapeo de tokens a mensajes claros para debugueo
    private String obtenerInfoToken(Symbol token) {
        switch (token.sym) {
            case sym.IDENTIFICADOR:
                return "Se encontro identificador inesperado: '" + token.value + "'";
            case sym.INT_LITERAL:
                return "Se encontro numero entero inesperado: '" + token.value + "'";
            case sym.FLOAT_LITERAL:
                return "Se encontro numero flotante inesperado: '" + token.value + "'";
            case sym.STRING_LITERAL:
                return "Se encontro texto inesperado";
            case sym.CHAR_LITERAL:
                return "Se encontro caracter inesperado";
            case sym.ASIGNACION:
                return "Se encontro '=' inesperado";
            case sym.DELIMITADOR:
                return "Se encontro '$' inesperado";
            case sym.EOF:
                return "Final de archivo inesperado";
            default:
                return "Token inesperado: " + token.value;
        }
    }

    public void report_error(String message, Object info) {
    }

    public void unrecovered_syntax_error(Symbol cur_token) {
        System.err.println("Error sintactico irrecuperable en linea " + cur_token.left + 
                          ", columna " + cur_token.right + ": No se puede continuar el analisis");
    }




  // El profe tiene esto en el codigo de el, me parece que es para hacer la sobrecarga, pero no s epara que llama al lexer.


  // Lexer lexer;

  // public Parser (Lexer lexer) {
  //   this.lexer = lexer;
  //   this.symbolFactory = new DefaultSymbolFactory();
  // }


:};

/* Aqui vamos a definir lo que se va a ejecutar al reducir una produccion o algo asi. (Es diferente del 'parser code')*/
action code {: // Esta parte podria ir en un archivo aparte, pero probemoslo asi de momento.

  // Esta es basicamente todo el manejo de la tabla de simbolos y asi definir su alcance por ambitos.
  Ambitos entornoActual = null;

  {
    entornoActual = new Ambitos(null); // Ambito raiz, este es el inicial, el que contiene a los demas, aqui estan las globales y todas las funciones.
  }

  Token funcionActual; // Para trabajar lo que es el analisis semantico de la llamada a funciones.

  Token funcionEnAnalisis; // Esta esa para tener los datos de la funcionn que estamos revisando en este momento.

  Stack<String> pilaEstrucControl = new Stack<>();// La idea con esto que que para saber si estamos dentro de una estructura de control.
  int contador = 0; // Esto es para ayudar a generar el token de los identificadores.

  // Crear un nuevo ambito y asigarle a lo anterior el que ya estabamos trabajando. [Este esta mas pensado para lo que pase dentro de BLOQUE]
  public void crearAmbito() {
      entornoActual = new Ambitos(entornoActual);
  }

  // Este seria para generar ambitos de funciones.
  public void crearAmbitoFuncion(String nombreFuncion, String tipo, int linea, int columna) {
      // Registrar la función como simbolo en el entorno padre

      Token funcion = new Token(nombreFuncion, tipo, "global", null, "funcion", linea, columna); // Queda mejor hacer el token aqui que en la parte de la produccion directamente.
      entornoActual.insertarNuevoToken(funcion);

      // Crear entorno local para parámetros y variables internas
      entornoActual = new Ambitos(entornoActual);
  }


  // Volver a lo que seria el ambito de mas arriba, el padre por asi decirlo, en algun punto vuelve al punto general del programa.
  public void cerrarAmbito() {
      entornoActual = entornoActual.getAnterior();
  }

  // Ahora se inserta un nuevo simbolo en el ambito en el que estamos.
  public boolean insertarNuevoToken(Token token) {
      return entornoActual.insertarNuevoToken(token);
  }


  // >> Esta seria la seccion para la parte de busquedas.

  // Buscar la existencia de un simbolo especifico en ambito, [Esto deberia de cambiarse para que sean por  especifico para un identificador y especifico para funciones].
  public Token buscarToken(String nombre) {
      return entornoActual.buscar(nombre);
  }

  public Token buscarFuncion(String nombre) {

    for (Ambitos ambito = entornoActual; ambito != null; ambito = ambito.getAnterior()) {
      
        Token token = ambito.buscar(nombre);

        if (token != null && "funcion".equals(token.getCategoria())) {
          return token;
        }
    }
    return null;
  }

  // Mostrar la tabla de simbolos actual.
  public void mostrarTablaActual() {
      System.out.println("Tabla de símbolos actual:");
      for (Token token : entornoActual.getTablaActual().values()) {
          token.mostrarToken();
      }
  }

    // Para buscar el ambito de una funcion especifica.
    public Ambitos buscarAmbitoDeFuncion(String nombre) {
        Ambitos actual = entornoActual;
        while (actual != null) {

            Token token = actual.buscar(nombre);
            if (token != null && "funcion".equals(token.getCategoria())) {
                return actual;
            }

            actual = actual.getAnterior();
        }
        return null;
    }

    // Para obtener los tipos de parametros de una funcion
    public List<String> obtenerTiposParametros(Token funcion) {
        List<String> tipos = new ArrayList<>();
        Ambitos ambitoFuncion = funcion.getAmbitoLocal();
        if (ambitoFuncion == null) return tipos;
        
        for (Token t : ambitoFuncion.getTablaActual().values()) {
            if ("parametro".equals(t.getCategoria())) {
                tipos.add(t.getTipo());
            }
        }
        return tipos;
    }

    public void mostrarTodosLosAmbitos() {
        System.out.println("╔════════════════════════════════════════════════════════════════════════════╗");
        System.out.println("║                    TABLA DE SÍMBOLOS EN TODOS LOS ÁMBITOS                 ║");
        System.out.println("╠════════════════════════════════════════════════════════════════════════════╣");
        System.out.printf("║ %-15s │ %-10s │ %-10s │ %-10s │ %-10s │ %-5s │ %-5s ║\n",
                        "Nombre", "Tipo", "Categoría", "Ambito", "Valor", "Linea", "Col");
        System.out.println("╠════════════════════════════════════════════════════════════════════════════╣");

        int nivel = 0;
        for (Ambitos ambito = entornoActual; ambito != null; ambito = ambito.getAnterior()) {
            String nombreAmbito = "Nivel_" + nivel;
            for (Token t : ambito.getTablaActual().values()) {
                System.out.printf("║ %-15s │ %-10s │ %-10s │ %-10s │ %-10s │ %-5d │ %-5d ║\n",
                                t.getNombre(), t.getTipo(), t.getCategoria(),
                                nombreAmbito, String.valueOf(t.getValor()),
                                t.getLinea(), t.getColumna());
            }
            nivel++;
        }

        System.out.println("╚════════════════════════════════════════════════════════════════════════════╝");
    }


    // Para obtener el tipo de dato de un identificador, principalmente variables.
    public TipoExpresiones obtenerTipoIdentificador(String nombre) {
        for (Ambitos ambito = entornoActual; ambito != null; ambito = ambito.getAnterior()) {
            Token token = ambito.buscar(nombre);
            if (token != null && "variable".equals(token.getCategoria())) {
                String tipo = token.getTipo(); 

                if ("int".equals(tipo)) return new TipoExpresiones("int");
                if ("float".equals(tipo)) return new TipoExpresiones("float");
                if ("char".equals(tipo)) return new TipoExpresiones("char");
                if ("boolean".equals(tipo)) return new TipoExpresiones("boolean");
                if ("string".equals(tipo)) return new TipoExpresiones("string");
                // if ("lista".equals(tipo)) {
                //     // Para lo de la lista.
                //     String tipoBase = token.getTipoBase(); // Ej: "int"
                //     Integer tamano = token.getTamano();    // Ej: 8
                //     return new TipoExpresiones(tipoBase, tamano);
                // }
            }
        }
        System.err.println("Error semantico: identificador '" + nombre + "' no encontrado o no es una variable.");
        return new TipoExpresiones("error", 0);
    }

    // Para obtener el tipo de dato de una funcion.
    public TipoExpresiones obtenerTipoFuncion(Token funcionActualA) {
        if (funcionActualA == null || !"funcion".equals(funcionActualA.getCategoria())) {
            System.err.println("Error semantico: funcion no valida.");
            return new TipoExpresiones("error", 0);
        }
        String tipo = funcionActualA.getTipo(); // Ej: "int", "float", "void", etc.
        if ("void".equals(tipo)) {
            System.err.println("Error semantico: la funcion no retorna valor.");
            return new TipoExpresiones("error", 0);
        }
        return new TipoExpresiones(tipo);
    }

    // Esto es para validar el tipo de datos esperado en las expresiones.
    public boolean validarTipoEsperado(String esperado, TipoExpresiones tipoReal) {
        if (tipoReal == null || "error".equals(tipoReal.tipoDato)) return false;
        return esperado.equals(tipoReal.tipoDato);
    }



:};


// >> El profe tambien define esto. >> De momento lo dejo comentado por que no se para que sirve.
// init with {: :};

// scan with {: return lexer.next_token(); :};




/* Definición de terminales (tokens) */
// Son las palabras reservadas
terminal LET, GLOBAL, VOID, PRINCIPAL, DECIDE, OF, ELSE, END, LOOP, EXIT;
terminal  WHEN,  RETURN, BREAK, INPUT, FOR, STEP, TO, DOWNTO, DO;

// Modificamos el output para que sea solo usado como sentencia y no en asignaciones o cosas raras:
terminal String OUTPUT;

// Tipos de datos
terminal String INT, FLOAT, BOOLEAN, CHAR, STRING;

// Literales de los tipos de datos, esta es la representacion en string.
terminal Integer INT_LITERAL;
terminal Double FLOAT_LITERAL;
terminal String STRING_LITERAL;
terminal Character CHAR_LITERAL;
terminal Boolean TRUE, FALSE;

// Identificadores.
terminal String IDENTIFICADOR;

// Operadores aritmeticos
terminal MAS, MENOS, MULTIPLICACION, DIVISION, DIVISION_ENTERA, MODULO, POTENCIA;
terminal INCREMENTO, DECREMENTO;

// Operadores relacionales
terminal IGUAL, DIFERENTE, MENOR_IGUAL, MAYOR_IGUAL, MENOR, MAYOR;

// Operadores logicos
terminal AND, OR, NOT;

// Asignacion
terminal ASIGNACION;

// Delimitadores y separadores
terminal DELIMITADOR, COMA;
terminal PAREN_I, PAREN_D,CORCHETE_I, CORCHETE_D, LLAVE_I, LLAVE_D;

// La flecha para los if y el concatenador de los prints.
terminal FLECHA, CONCATENACION_OUTPUT;

// Terminar para la deficion de errores lexicos.
terminal ERROR;

// Nuevos elementos agregados para el PY 2.

terminal LISTA;
terminal ARGUMENTOS;



// --------- Fin elementos nuevos.



/* -------------->>>> Seccion para los no terminales */

/* >> Estructura general*/
non terminal programa, principal, funciones, funcion, params, param;

/* >> Tipos de datos: A estos se les agrega que sean String para que sea mas facil trabajarles la parte semanatica. */
non terminal String tipoDatoFuncion, tipoDatoVariable;

/* >> Sentencias y bloques */
non terminal bloque, sentencias, sentencia;

/* >> Declaraciones y variables */
non terminal var, varAsignacion, varCyAsignacion, varGlobal;

/* >> Expresiones  */

non terminal expresion;

/* > Numericas */
non terminal TipoExpresiones expresionNumerica, expresionSuma, expresionProducto, expresionPotencia, expresionFactor, expresionAritmeticaUnaria, expresionAritmeticaUnariaNegativa;

/* > Boolenas  */
non terminal TipoExpresiones expresionBooleana;

/* > Literales */
non terminal TipoExpresiones expresionChar, expresionString;

/* > Expresiones compuestas */
non terminal TipoExpresiones expresionAritmetica, expresionLogica, expresionRelacional;

/* >> Control de flujo */
non terminal estructruraControl, decide, condicion, loop, for;

/* >> Funciones y sus llamadas  */
non terminal funcionLlamada, argumentos, return, break;

/* Aqui estoy poniendo los no terminales que estan faltando */
non terminal  condiciones, listaFunciones;
non terminal String tipoDatoInput;

/* >> Input y ouput */
non terminal output, output_inline;
non terminal String input;
/* >> Listas */
non terminal lista, declaracionLista, creacionYAsignacionLista, elementos, elementoLista, modificarElementoLista, obtenerElementoLista;


// Esta son las nuevas declaraciones: 
non terminal principalParteIzquierda, funcionParteIzquierda, bloqueInicio, funcionLlamadaInicio;

non terminal String tipoDatoParametro; // Le definimo String para que sea mas facil trabajar con lo valores.

non terminal TipoLista tipoLista; // Aqui indicamos que lo que vamos a devolver es un objeto de TipoLista
non terminal decideParteIzquierda;
non terminal String operadorRelacional;
// --- Fin de declaracion de nuevos no terminales. 



/* Precedencia de operadores (de menor a mayor precedencia) */

// Operadores binarios
precedence left OR;
precedence left AND;
precedence right NOT; 

/* Operadores booleanos y relacionales */
precedence left IGUAL, DIFERENTE;
precedence left MENOR, MAYOR, MENOR_IGUAL, MAYOR_IGUAL;

/* Operadores aritmeticos */
precedence left MAS, MENOS;
precedence left MULTIPLICACION, DIVISION, DIVISION_ENTERA, MODULO;
precedence right POTENCIA;

// Operadores unarios
precedence left INCREMENTO, DECREMENTO;
precedence right MENOS; /* Pasar a negativo: Revisar la gramatica original para una posible correccion. */


/* Precedencia para resolver conflictos */
precedence left COMA;
precedence right ASIGNACION;


/* expect 6; Esto es para decirle a cup qie espere hasta 6 congliuctos y que los acepte */

/* Esta es la que dice como se inicia todo. */
start with programa;



/* -------------------------  >> Definicion << -------------------------------------------------------------------  */


/* Producciones generales */
/* FIX: La estructura del principal está como opcional, debe de ser obligatorio y al final (por diseño) */
/* FIXED: Se arreglo la estructura para que siempre haya un bloque principal */
programa ::= varGlobal programa
           | funciones principal {: 
                if (buscarFuncion("principal") == null) {
                    System.err.println("Error semantico: no se ha definido la funcion principal.");
                }
                mostrarTodosLosAmbitos();
            :} 
           | principal {: 
                if (buscarFuncion("principal") == null) {
                    System.err.println("Error semantico: no se ha definido la funcion principal.");
                }
                mostrarTodosLosAmbitos();
            :}
           | error programa {: System.err.println("Error: Declaracion global o funcion no valida"); :};

principalParteIzquierda ::= VOID PRINCIPAL:pri PAREN_I PAREN_D {: 
                            Token principal = new Token("principal", "void", "global", null, "funcion", prileft, priright);
                            if (!insertarNuevoToken(principal)) {
                                System.err.println("Error semántico: función 'principal' ya declarada.");
                            }

                            crearAmbito(); // entorno local para principal
                            funcionEnAnalisis = principal; // Para trabajar con lo datos de la funcion.
                        :};

principal ::= principalParteIzquierda bloque {: 
              cerrarAmbito(); // cerramos entorno de principal
          :};

// Se le agrega el result para que las producciones sepan mejor el valor semantico que van a tener.
tipoDatoFuncion ::= INT {: RESULT = "int"; :}
                  | FLOAT {: RESULT = "float"; :}
                  | BOOLEAN {: RESULT = "boolean"; :};

tipoDatoVariable ::= INT {: RESULT = "int"; :}
                  | FLOAT {: RESULT = "float"; :}
                  | BOOLEAN {: RESULT = "boolean"; :}
                  | CHAR {: RESULT = "char"; :}
                  | STRING {: RESULT = "string"; :}
                   | error {: System.err.println("Error: tipo de variable debe ser int, float, boolean, char o string"); :};



/* Esta modificacion es para intentar resolver el conflicto de funcion */
funciones ::= listaFunciones;

listaFunciones ::= funcion
                 | listaFunciones funcion;


// Para esta porte de las funciones, las dividimos en parte izquierda y parte derecha para que sea mas facil el analisis.
funcionParteIzquierda ::= tipoDatoFuncion:tipo IDENTIFICADOR:ID PAREN_I  {: 
                        Token funcion = new Token(ID, tipo, "global", null, "funcion", IDleft, IDright);
                        if (!insertarNuevoToken(funcion)) {
                            System.err.println("Error semantico: funcion '" + ID + "' ya declarada.");
                        }

                        crearAmbito(); // Crear el ambito local de una funcion, esto antes de que se cree el bloque.
                        funcion.setAmbitoLocal(entornoActual);
                        funcionEnAnalisis = funcion; // Guardamos la funcion que acabamos de crear para que sea mas facil trabajarla despues.
                      :}; // Fin de produccion.
  


// Funciones en la parte derecha.
funcion ::= funcionParteIzquierda params PAREN_D bloque {: 
            cerrarAmbito(); // Cerramos el ambito local de una funcion.
        :}
        | PAREN_D bloque {: cerrarAmbito(); :}; // Fin de produccion.


// >>>>>>>>>>Parte de los parametros de una funcion
params ::= param
         | params COMA param
         | error COMA param{: System.err.println("Error: No puede haber una (,) sola al inicio de los parametros."); :};

// Definirle el valos de formas mas explicita para que puedan ser leidos.
tipoDatoParametro ::= INT {: RESULT = "int"; :}
                    | FLOAT {: RESULT = "float"; :}
                    | BOOLEAN {: RESULT = "boolean"; :}
                    | CHAR {: RESULT = "char"; :}
                    | STRING {: RESULT = "string"; :};
                    // | tipoLista {: RESULT = new Symbol(sym.LISTA, "lista"); :}; // Este se tiene que mover ya que no dejara trabajar con lo del semantico

param ::= tipoDatoParametro:tipo IDENTIFICADOR:ID {: 
          Token parametro = new Token(ID, tipo, "parametro", null, "parametro", IDleft, IDright);
          if (!insertarNuevoToken(parametro)) {
              System.err.println("Error semantico: parametro '" + ID + "' ya declarado.");
          }
        :}
      | tipoLista:tipo IDENTIFICADOR:ID {: //Despues se tiene que hacer algo para trabajar con lo del tamaño.
          Token parametro = new Token(ID, tipo.tipoBase, "parametro", null, "parametro", IDleft, IDright);
          if (!insertarNuevoToken(parametro)) {
              System.err.println("Error semantico: parametro '" + ID + "' ya declarado.");
          }
        :}
      | error IDENTIFICADOR {: System.err.println("Error: Para los parametros de una funcion se debe de indicar su tipo de dato."); :};


// -------------------------- Seccion del bloque primario de lo que son las funciones.

bloqueInicio ::= LLAVE_I {: 
    crearAmbito(); 
:};

/* Producciones de sentencias y bloques */
bloque ::= bloqueInicio sentencias LLAVE_D {: 
              cerrarAmbito(); 
          :}

          | bloqueInicio LLAVE_D {: 
              cerrarAmbito(); 
          :}

         | error sentencias LLAVE_D {: System.err.println("Error: Los bloques deben de tener una llave de apertura (¿)."); :}
         | error LLAVE_D {: System.err.println("Error: Los bloques deben de tener una llave de apertura (¿). "); :}
         | LLAVE_I sentencias error {: System.err.println("Error: Los bloques deben de tener una llave de cierre (?). "); :};

sentencias ::= sentencia
             | sentencias sentencia;

sentencia ::= var
            | varAsignacion  
            | varCyAsignacion
            | lista
            | estructruraControl
            | funcionLlamada DELIMITADOR
            | return
            | break
            | input DELIMITADOR
            | output DELIMITADOR
            // | output_inline DELIMITADOR
            | modificarElementoLista
            | expresionAritmeticaUnaria DELIMITADOR;

/* FIX: El identificador no debe de ser validado, se valida en producción identificador, sino encuentra busca terminal  */
/*FIXED: Eliminando la linea que valida nombre: | error PAREN_I argumentos PAREN_D  {: System.err.println("Error: Nombre de funcion no valido"); :}*/
funcionLlamadaInicio ::= IDENTIFICADOR:ID PAREN_I {: 
                      Token funcion = buscarFuncion(ID);
                      if (funcion == null) {
                          System.err.println("Error semantico: funcion '" + ID + "' no declarada.");
                          funcionActual = null;
                      } else {
                          System.out.println("Llamada a funcion '" + ID + "' valida.");
                          funcionActual = funcion;
                          // Se podria hacer algo para guardar el token y validar sus argumentos luego.
                      }
                  :};
// Para la llamada a una funcion.
funcionLlamada ::= funcionLlamadaInicio argumentos:args PAREN_D {: 

                      if (funcionActual == null) {
                          System.err.println("Error: No se puede validardar los argumentos de la funcion, debido a que la funcion  buscada no esta declarada.");
                          
                      } else {

                        List<String> argumentos = (List<String>) ((Symbol)args).value;
                        List<String> parametrosEsperados = obtenerTiposParametros(funcionActual);

                        if (argumentos.size() != parametrosEsperados.size()) {
                            System.err.println("Error semantico: funcion '" + funcionActual.getNombre() + "' esperaba " + parametrosEsperados.size() + " argumentos, pero recibio " + argumentos.size());
                        } else {
                            for (int i = 0; i < argumentos.size(); i++) {
                                if (!argumentos.get(i).equals(parametrosEsperados.get(i))) {
                                    System.err.println("Error semantico: argumento " + (i+1) + " de funcion '" + funcionActual.getNombre() + "' esperaba tipo '" + parametrosEsperados.get(i) + "', pero recibio '" + argumentos.get(i) + "'");
                                }
                            }
                        }

                      }
                  :}
                 | funcionLlamadaInicio PAREN_D;


argumentos ::= expresion:expr {: 
                  List<String> args = new ArrayList<>();
                  args.add("Prueba_tipo"); // suponiendo que expresion devuelve tipo: ((Symbol)expr).value.toString()
                  RESULT = new Symbol(sym.ARGUMENTOS, args);
              :}
             | argumentos:prev COMA expresion:expr {: 
                  ((List<String>) ((Symbol)prev).value).add("Prueba_tipo"); //((Symbol)expr).value.toString()
                  RESULT = new Symbol(sym.ARGUMENTOS, ((Symbol)prev).value);
              :}
             | error COMA expresion  {: System.err.println("Error: Argumento no valido antes de ','"); :}
             | argumentos COMA error {: System.err.println("Error: Se esperaba expresion despues de ','"); :}
             | argumentos error expresion {: System.err.println("Error: Se esperaba ',' entre argumentos"); :};
             
return ::= RETURN DELIMITADOR {: 
            if (!"void".equals(funcionEnAnalisis.getTipo())) {
                System.err.println("Error semantico: la funcion '" + funcionEnAnalisis.getNombre() + "' debe retornar un valor de tipo '" + funcionEnAnalisis.getTipo() + "'.");
            }
        :}
         | RETURN expresion:expr DELIMITADOR {: 
                String tipoExpr = (String) expr; // suponiendo que expresion devuelve un String con el tipo, pero creo que devolvera una clase con otros datos.
                String tipoFuncion = funcionEnAnalisis.getTipo();

                if ("void".equals(tipoFuncion)) {
                    System.err.println("Error semantico: la funcion '" + funcionEnAnalisis.getNombre() + "' no debe retornar ningun valor.");
                } else if (!tipoExpr.equals(tipoFuncion)) {
                    System.err.println("Error semantico: la funcion '" + funcionEnAnalisis.getNombre() + "' debe retornar tipo '" + tipoFuncion + "', pero se retorno tipo '" + tipoExpr + "'.");
                }
            :}
         | RETURN expresion error {: System.err.println("Error: Se esperaba un delimitador '$'"); :}
         | RETURN error {: System.err.println("Error: Se esperaba un delimitador '$'"); :};

break ::= BREAK DELIMITADOR {: 
            if (pilaEstrucControl.isEmpty()) {
                System.err.println("Error semantico: 'break' fuera de una estructura de control.");
            }
        :};

/*FIX: Se debe hacer algo para que cuando el cup lea un IDENTIFICADOR -> PAREN_I detecte que es input, no una llamada a función*/
input ::= INPUT PAREN_I tipoDatoInput:tipo PAREN_D {:
                if (!"int".equals(tipo) && !"float".equals(tipo)) {
                    System.err.println("Error semantico: tipo '" + tipo + "' no valido para input. Solo se permite int o float. Fila: " + tipoleft + ", Columna: " + tiporight);
                    RESULT = "error";
                } else {
                    RESULT = tipo; // Devolvemos el tipo esperado.
                }
            :}
        | INPUT PAREN_I error PAREN_D {: System.err.println("Error: Tipo de dato no valido para input, debe ser int o float."); :};

tipoDatoInput ::= INT {: RESULT = "int"; :}
                | FLOAT {: RESULT = "float"; :};

// Ouput para imprimir los datos.
output ::= output_inline {: RESULT = "output"; :}
         | output CONCATENACION_OUTPUT output_inline         
         | output error output_inline {: System.err.println("Error: Se debe de definir el caracter de concatenacion (<<) para los outpout "); :};

output_inline ::= OUTPUT PAREN_I expresion PAREN_D
| error PAREN_I expresion PAREN_D {: System.err.println("Error: Se debe de definir la palabra de (input) para indicar una salida en consola."); :};



/* -------------------- Estructuras de control ----------------------------- */
estructruraControl ::= decide {: pilaEstrucControl.pop(); :}
                     | loop {: pilaEstrucControl.pop(); :}
                     | for {: pilaEstrucControl.pop(); :};


decideParteIzquierda ::= DECIDE:deci OF {: 
                            Token estructura = new Token("otro_decide_" + contador++, "estructura", "local", null, "decide", decileft, deciright);
                            insertarNuevoToken(estructura);
                            crearAmbito();
                            pilaEstrucControl.push("decide");
                        :};


// Aqui hay que agregar algo para agregar a la pila de estructura de control.
decide ::= decideParteIzquierda condiciones END DECIDE DELIMITADOR {: pilaEstrucControl.pop(); cerrarAmbito(); :}
         | decideParteIzquierda condiciones ELSE bloque END DECIDE DELIMITADOR {: pilaEstrucControl.pop(); cerrarAmbito(); :} // Posiblemente requiramos crear una ambito especifico para el else.
         | decideParteIzquierda error condiciones END DECIDE DELIMITADOR {: System.err.println("Error: Se esperaba 'of' despues de 'decide'"); :}
         | decideParteIzquierda error END DECIDE DELIMITADOR {: System.err.println("Error: Condiciones no validas en estructura decide"); :}
         | decideParteIzquierda condiciones error DECIDE DELIMITADOR  {: System.err.println("Error: Se esperaba 'end' antes de 'decide'"); :}
         | decideParteIzquierda condiciones END error DELIMITADOR {: System.err.println("Error: Se esperaba 'decide' despues de 'end'"); :};

condiciones ::= condicion FLECHA bloque
              | condiciones condicion FLECHA bloque;

condicion ::= PAREN_I expresion:expr PAREN_D {: // Esto probablemente tenga una forma diferente despues, la parte de expr va a ser diferente y se tendra que cambiar esta validacion.
                    String tipo = (String) expr;
                    if (!"boolean".equals(tipo)) {
                        System.err.println("Error semantico: la condición en 'decide' debe ser de tipo boolean, pero se recibio '" + tipo + "'");
                    }
                :}
            | error expresion PAREN_D {: System.err.println("Error: Se esperaba parentesis de apertura 'є' en condicion"); :}
            | PAREN_I expresion error {: System.err.println("Error: Se esperaba parentesis de cierre 'э' en condicion"); :}
            | PAREN_I error PAREN_D {: System.err.println("Error: Expresion no valida en condicion"); :};


loop ::= LOOP bloque EXIT WHEN condicion DELIMITADOR END LOOP DELIMITADOR
       | LOOP bloque break EXIT WHEN condicion DELIMITADOR END LOOP DELIMITADOR
       | LOOP error EXIT WHEN condicion DELIMITADOR END LOOP DELIMITADOR {: System.err.println("Error: Bloque no valido en estructura loop"); :}
       | LOOP bloque error WHEN condicion DELIMITADOR END LOOP DELIMITADOR {: System.err.println("Error: Se esperaba 'exit' antes de 'when'"); :}
       | LOOP bloque EXIT error condicion DELIMITADOR END LOOP DELIMITADOR {: System.err.println("Error: Se esperaba 'when' despues de 'exit'"); :}
       | LOOP bloque EXIT WHEN condicion DELIMITADOR error LOOP DELIMITADOR {: System.err.println("Error: Se esperaba 'end' antes de 'loop'"); :};

for ::= FOR IDENTIFICADOR STEP INT_LITERAL TO expresion DO bloque DELIMITADOR
      | FOR IDENTIFICADOR STEP INT_LITERAL DOWNTO expresion DO bloque DELIMITADOR
      | FOR error STEP INT_LITERAL TO expresion DO bloque DELIMITADOR {: System.err.println("Error: Se esperaba identificador despues de 'for'"); :}
      | FOR IDENTIFICADOR error INT_LITERAL TO expresion DO bloque DELIMITADOR {: System.err.println("Error: Se esperaba 'step' despues del identificador"); :}
      | FOR IDENTIFICADOR STEP error TO expresion DO bloque DELIMITADOR {: System.err.println("Error: Se esperaba numero entero despues de 'step'"); :}
      | FOR IDENTIFICADOR STEP INT_LITERAL error expresion DO bloque DELIMITADOR {: System.err.println("Error: Se esperaba 'to' o 'downto' en bucle for"); :}
      | FOR IDENTIFICADOR STEP INT_LITERAL TO expresion error bloque DELIMITADOR {: System.err.println("Error: Se esperaba 'do' antes del bloque"); :};

/* Producciones de declaraciones y variables con DELIMITADOR (pendiente) */
var ::= LET tipoDatoVariable IDENTIFICADOR DELIMITADOR; /* | LET tipoDatoVariable IDENTIFICADOR ASIGNACION expresion DELIMITADOR    -- Se cambio esto por que era lo mismo */

varAsignacion ::= IDENTIFICADOR ASIGNACION expresion DELIMITADOR;
                 
varCyAsignacion ::= LET tipoDatoVariable IDENTIFICADOR ASIGNACION expresion DELIMITADOR
                  | LET tipoDatoVariable IDENTIFICADOR ASIGNACION error DELIMITADOR 
                    {: System.err.println("Error: Expresion no valida despues de '='"); :}
                  | LET tipoDatoVariable IDENTIFICADOR error 
                    {: System.err.println("Error: Se esperaba '=' despues del identificador"); :}
                  | LET tipoDatoVariable error ASIGNACION expresion DELIMITADOR
                    {: System.err.println("Error: Identificador no valido"); :}
                  | LET error IDENTIFICADOR ASIGNACION expresion DELIMITADOR
                    {: System.err.println("Error: Tipo de dato no valido"); :};

/* FIX: ERROR en global para que detecte 'global tipo identificador...' */
/* FIXED: Se agrega produ de error en falta de global */
varGlobal ::= GLOBAL tipoDatoVariable IDENTIFICADOR DELIMITADOR
            | error tipoDatoVariable IDENTIFICADOR DELIMITADOR
              {: System.err.println("Error: Se esperaba la palabra 'global' al inicio de la declaracion"); :}
            | GLOBAL tipoDatoVariable IDENTIFICADOR ASIGNACION expresion DELIMITADOR;

/* ##### Seccion para las expresiones ######*/
expresion ::= expresionLogica;


/* Modificar las derivacion para expresion logica con el fin de que pueda volver a arriba:  expresionLogica AND expresionLogica| expresionLogica OR expresionLogica*/
expresionLogica ::= expresionLogica AND expresionRelacional
                  | expresionLogica OR expresionRelacional
                  | NOT expresionLogica                  
                  | expresionRelacional; 
                  

/* Los de expresionAritmetica no se pueden cambiar ya que los operadores de mayores y menore solo funcionan con estos. Asi */
expresionRelacional ::= expresionRelacional operadorRelacional expresionAritmetica
                      | expresionAritmetica
                      | PAREN_I expresion PAREN_D;

operadorRelacional ::= IGUAL | DIFERENTE | MENOR | MAYOR | MENOR_IGUAL | MAYOR_IGUAL;


//  Para intentar solucionar lo de expresiones.
// valorLiteral ::= INT_LITERAL {:RESULT = "int":}
//                | FLOAT_LITERAL
//                | TRUE
//                | FALSE
//                | CHAR_LITERAL
//                | STRING_LITERAL;

// valorReferencia ::= IDENTIFICADOR
//                   | funcionLlamada
//                   | obtenerElementoLista
//                   | input;



expresionChar ::= CHAR_LITERAL:charLi {: 
                    RESULT = new TipoExpresiones("char", charLi); 
                :};

expresionString ::= STRING_LITERAL:strLit {: 
                    RESULT = new TipoExpresiones("string", strLit); 
                :};

expresionBooleana ::= TRUE{: 
                        RESULT = new TipoExpresiones("boolean", true); 
                    :}
                                        | FALSE {: 
                        RESULT = new TipoExpresiones("boolean", false); 
                    :};


/* >> Expresiones aritmeticas */

expresionAritmetica ::= expresionSuma;


expresionSuma ::= expresionSuma MAS expresionProducto
                | expresionSuma MENOS expresionProducto
                | expresionProducto
                | expresionSuma MAS error
                  {: System.err.println("Error: Expresion no valida despues de '+'"); :}
                | expresionSuma MENOS error
                  {: System.err.println("Error: Expresion no valida despues de '-'"); :};

expresionProducto ::= expresionProducto MULTIPLICACION expresionPotencia
                    | expresionProducto DIVISION expresionPotencia
                    | expresionProducto DIVISION_ENTERA expresionPotencia
                    | expresionProducto MODULO expresionPotencia
                    | expresionPotencia;
          
expresionPotencia ::= expresionFactor POTENCIA expresionPotencia
                    | expresionFactor;


expresionFactor ::= PAREN_I expresionAritmetica PAREN_D
                  | expresionNumerica
                  | expresionAritmeticaUnaria
                  | expresionAritmeticaUnariaNegativa
                  | error
                    {: System.err.println("Error: Expresion aritmetica no valida"); :};

expresionNumerica ::= INT_LITERAL:n {: RESULT = new TipoExpresiones("int", n); :}
                    | FLOAT_LITERAL:f  {: RESULT = new TipoExpresiones("float", f); :}
                    | IDENTIFICADOR:id {: 
                        
                        RESULT = obtenerTipoIdentificador(id); 
                    
                    :}
                    | funcionLlamada:func {: 
                        RESULT = obtenerTipoFuncion(funcionActual); 
                    :}
                    | obtenerElementoLista:ob {: 
                        // RESULT = obtenerTipoElementoLista(ob); 
                        RESULT = new TipoExpresiones("int");
                        :}
                    | input:inp {: RESULT = new TipoExpresiones(inp); :}

                    // Esta parte es para intentar olucionar los problemas:
                    | expresionChar:charExp {: 
                        // if (!validarTipoEsperado("int|float", charExp)) {
                        //     System.err.println("Error semantico: tipo '" + charExp.tipoDato + "' no valido en expresion numerica.");
                        // }
                        RESULT = charExp;
                    :}
                    | expresionString:strExp {: 
                        // if (!validarTipoEsperado("int|float", strExp)) {
                        //     System.err.println("Error semantico: tipo '" + strExp.tipoDato + "' no valido en expresion numerica.");
                        // }
                        RESULT = strExp;
                    :}
                    | expresionBooleana:boolExp {: 
                        // if (!validarTipoEsperado("int|float", boolExp)) {
                        //     System.err.println("Error semantico: tipo '" + boolExp.tipoDato + "' no valido en expresion numerica.");
                        // }
                        RESULT = boolExp;
                    :}

                    | INT_LITERAL IDENTIFICADOR error
                      {: System.err.println("Error: Numero seguido de identificador no es valido (ej: 2f5)"); :}
                    | FLOAT_LITERAL IDENTIFICADOR error
                      {: System.err.println("Error: Numero flotante seguido de identificador no es valido"); :};

expresionAritmeticaUnaria ::= IDENTIFICADOR INCREMENTO
                            | IDENTIFICADOR DECREMENTO;

expresionAritmeticaUnariaNegativa ::= MENOS expresionNumerica;


/* ##### Seccion para el manejo de listas ######*/
lista ::= declaracionLista
        | creacionYAsignacionLista;

declaracionLista ::= LET tipoLista IDENTIFICADOR DELIMITADOR;

creacionYAsignacionLista ::= LET tipoLista IDENTIFICADOR ASIGNACION LLAVE_I elementos LLAVE_D DELIMITADOR;

elementos ::= elementoLista
            | elementos COMA elementoLista;

elementoLista ::= expresionAritmetica:op; /* Este deberia ser expresion aritmetica en ves de -> INT_LITERAL*/
                // | CHAR_LITERAL
                // | IDENTIFICADOR; /* FIXED: El elemento en lista deberia poder permitir identificadores validos*/

/* FIX: El elemento en lista deberia poder permitir identificadores validos*/
modificarElementoLista ::= IDENTIFICADOR CORCHETE_I expresionAritmetica CORCHETE_D ASIGNACION elementoLista DELIMITADOR 
                         | error CORCHETE_I expresionAritmetica CORCHETE_D ASIGNACION elementoLista DELIMITADOR
                           {: System.err.println("Error: Nombre de lista no valido"); :};

obtenerElementoLista ::= IDENTIFICADOR:ID CORCHETE_I expresionAritmetica:op CORCHETE_D
                      | error CORCHETE_I expresionAritmetica CORCHETE_D
                        {: System.err.println("Error: Nombre de lista no valido"); :};

tipoLista ::= INT CORCHETE_I CORCHETE_D {: 
                TipoLista tipoL = new TipoLista("int", null);
                RESULT = tipoL;
            :}
           | CHAR CORCHETE_I CORCHETE_D {: 
                TipoLista tipoL = new TipoLista("char", null);
                RESULT = tipoL;
            :}
           | INT CORCHETE_I INT_LITERAL:num CORCHETE_D {: 
                int tama = num;
                TipoLista tipoL = new TipoLista("int", tama);
                RESULT = tipoL;
            :}
           | CHAR CORCHETE_I INT_LITERAL:num CORCHETE_D {: 
                int tama = num;
                TipoLista tipoL = new TipoLista("char", tama);
                RESULT = tipoL;
            :};


