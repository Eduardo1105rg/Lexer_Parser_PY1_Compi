/* Definicion del pasers con CUP para el analisis de la gramatica. */

/* Imports que se ocupan */
package parser;

import java_cup.runtime.*;
import lexer.*;
import java.io.*;
import lexer.Lexer;

/* Parsers */
parser code {:
    private int errorContador = 0;

    public int getErrorContador() {
        return errorContador;
    }

    public void syntax_error(Symbol cur_token) {
        errorContador++;
        report_error("Error de sintaxis", cur_token);
    }

    public void report_error(String message, Object info) {
        StringBuilder error = new StringBuilder();
        
        if (info instanceof Symbol) {
            Symbol s = (Symbol) info;
            
            // Se agrega linea y columna si se pueden obtener
            if (s.left >= 0) {
                error.append("Línea ").append(s.left);
                if (s.right >= 0) {
                    error.append(", columna ").append(s.right);
                }
                error.append(": ");
            }
            
            error.append(message);
            
        } else {
            error.append(message);
        }
        
        System.err.println(error.toString());
    }

    public void unrecovered_syntax_error(Symbol cur_token) {
        report_error("Error sintáctico irrecuperable - continuando análisis", cur_token);
    }

:};

/* Definición de terminales (tokens) */
// Son las palabras reservadas
terminal LET, GLOBAL, VOID, PRINCIPAL, DECIDE, OF, ELSE, END, LOOP, EXIT;
terminal  WHEN,  RETURN, BREAK, INPUT, FOR, STEP, TO, DOWNTO, DO, OUTPUT;
 

// Tipos de datos
terminal INT, FLOAT, BOOLEAN, CHAR, STRING;

// Literales de los tipos de datos, esta es la representacion en string.
terminal Integer INT_LITERAL;
terminal Double FLOAT_LITERAL;
terminal String STRING_LITERAL;
terminal Character CHAR_LITERAL;
terminal Boolean TRUE, FALSE;

// Identificadores.
terminal IDENTIFICADOR;

// Operadores aritmeticos
terminal MAS, MENOS, MULTIPLICACION, DIVISION, DIVISION_ENTERA, MODULO, POTENCIA;
terminal INCREMENTO, DECREMENTO;

// Operadores relacionales
terminal IGUAL, DIFERENTE, MENOR_IGUAL, MAYOR_IGUAL, MENOR, MAYOR;

// Operadores logicos
terminal AND, OR, NOT;

// Asignacion
terminal ASIGNACION;

// Delimitadores y separadores
terminal DELIMITADOR, COMA;
terminal PAREN_I, PAREN_D,CORCHETE_I, CORCHETE_D, LLAVE_I, LLAVE_D;

// La flecha para los if y el concatenador de los prints.
terminal FLECHA, CONCATENACION_OUTPUT;

// Terminar para la deficion de errores lexicos.
terminal ERROR;




/* -------------->>>> Seccion para los no terminales */

/* >> Estructura general*/
non terminal programa, principal, funciones, funcion, params, param;

/* >> Tipos de datos */
non terminal tipoDatoFuncion, tipoDatoVariable;

/* >> Sentencias y bloques */
non terminal bloque, sentencias, sentencia;

/* >> Declaraciones y variables */
non terminal var, varAsignacion, varCyAsignacion, varGlobal;

/* >> Expresiones  */

non terminal expresion;

/* > Numericas */
non terminal expresionNumerica, expresionSuma, expresionProducto, expresionPotencia, expresionFactor, expresionAritmeticaUnaria, expresionAritmeticaUnariaNegativa;

/* > Boolenas  */
non terminal expresionBooleana;

/* > Literales */
non terminal  expresionChar, expresionString;

/* > Expresiones compuestas */
non terminal expresionAritmetica, expresionLogica, expresionRelacional;

/* >> Control de flujo */
non terminal estructruraControl, decide, condicion, loop, for;

/* >> Funciones y sus llamadas  */
non terminal funcionLlamada, argumentos, return, break;

/* Aqui estoy poniendo los no terminales que estan faltando */
non terminal  tipoDatoInput, condiciones, listaFunciones;


/* >> Input y ouput */
non terminal input, output, output_inline;

/* >> Listas */
non terminal lista, declaracionLista, creacionYAsignacionLista, elementos, elementoLista, modificarElementoLista, obtenerElementoLista, tipoLista;



/* Precedencia de operadores (de menor a mayor precedencia) */

// Operadores binarios
precedence left OR;
precedence left AND;
precedence right NOT; 

/* Operadores booleanos y relacionales */
precedence left IGUAL, DIFERENTE;
precedence left MENOR, MAYOR, MENOR_IGUAL, MAYOR_IGUAL;

/* Operadores aritmeticos */
precedence left MAS, MENOS;
precedence left MULTIPLICACION, DIVISION, DIVISION_ENTERA, MODULO;
precedence right POTENCIA;

// Operadores unarios
precedence left INCREMENTO, DECREMENTO;
precedence right MENOS; /* Pasar a negativo: Revisar la gramatica original para una posible correccion. */


/* Precedencia para resolver conflictos */
precedence left COMA;
precedence right ASIGNACION;


/* expect 6; Esto es para decirle a cup qie espere hasta 6 congliuctos y que los acepte */

/* Esta es la que dice como se inicia todo. */
start with programa;



/* -------------------------  >> Definicion << -------------------------------------------------------------------  */


/* Producciones generales */
programa ::= varGlobal programa
           | funciones programa  
           | principal;

principal ::= VOID PRINCIPAL PAREN_I PAREN_D bloque;

tipoDatoFuncion ::= INT
                  | FLOAT
                  | BOOLEAN;

tipoDatoVariable ::= INT
                   | FLOAT
                   | BOOLEAN
                   | CHAR
                   | STRING
                   | error {: System.err.println("Error: tipo de variable debe ser int, float, boolean, char o string"); :};

/*funciones ::= funcion
            | funciones funcion;*/

/* Esta modificacion es para intentar resolver el conflicto de funcion */
funciones ::= listaFunciones;

listaFunciones ::= funcion
                 | listaFunciones funcion;

funcion ::= tipoDatoFuncion IDENTIFICADOR PAREN_I params PAREN_D bloque
          | tipoDatoFuncion IDENTIFICADOR PAREN_I PAREN_D bloque
          | error IDENTIFICADOR PAREN_I params PAREN_D bloque {: System.err.println("Error: Tipo de dato de funcion no valido, de"); :}
          | error PAREN_I params PAREN_D bloque {: System.err.println("Error: Identificador no encontrado"); :}
          | error params PAREN_D bloque {: System.err.println("Error: Faltan parentesis de apertura ("); :}
          | error bloque {: System.err.println("Error: Faltan parentesis de cierre )"); :};

params ::= param
         | params COMA param;

param ::= INT IDENTIFICADOR
        | FLOAT IDENTIFICADOR
        | BOOLEAN IDENTIFICADOR
        | CHAR IDENTIFICADOR
        | STRING IDENTIFICADOR
        | tipoLista IDENTIFICADOR;

/* Producciones de sentencias y bloques */
bloque ::= LLAVE_I sentencias LLAVE_D
         | LLAVE_I LLAVE_D;

sentencias ::= sentencia
             | sentencias sentencia;

sentencia ::= var
            | varAsignacion  
            | varCyAsignacion
            | lista
            | estructruraControl
            | funcionLlamada DELIMITADOR
            | return
            | break
            | input DELIMITADOR
            | output DELIMITADOR
            | output_inline DELIMITADOR
            | modificarElementoLista
            | expresionAritmeticaUnaria DELIMITADOR;

funcionLlamada ::= IDENTIFICADOR PAREN_I argumentos PAREN_D
                 | IDENTIFICADOR PAREN_I PAREN_D;

argumentos ::= expresion
             | argumentos COMA expresion;

return ::= RETURN DELIMITADOR
         | RETURN expresion DELIMITADOR;

break ::= BREAK DELIMITADOR;

input ::= INPUT PAREN_I tipoDatoInput PAREN_D;

tipoDatoInput ::= INT
                | FLOAT;
            
output ::= output_inline
         | output CONCATENACION_OUTPUT output_inline;

output_inline ::= OUTPUT PAREN_I expresion PAREN_D;

/* Estructuras de control */
estructruraControl ::= decide 
                     | loop 
                     | for;

decide ::= DECIDE OF condiciones END DECIDE DELIMITADOR
         | DECIDE OF condiciones ELSE bloque END DECIDE DELIMITADOR;

condiciones ::= condicion FLECHA bloque
              | condiciones condicion FLECHA bloque;

condicion ::= PAREN_I expresion PAREN_D;

loop ::= LOOP bloque EXIT WHEN condicion DELIMITADOR END LOOP DELIMITADOR
       | LOOP bloque break EXIT WHEN condicion DELIMITADOR END LOOP DELIMITADOR;

for ::= FOR IDENTIFICADOR STEP INT_LITERAL TO expresion DO bloque DELIMITADOR
      | FOR IDENTIFICADOR STEP INT_LITERAL DOWNTO expresion DO bloque DELIMITADOR;

/* Producciones de declaraciones y variables con DELIMITADOR (pendiente) */
var ::= LET tipoDatoVariable IDENTIFICADOR DELIMITADOR; /* | LET tipoDatoVariable IDENTIFICADOR ASIGNACION expresion DELIMITADOR    -- Se cambio esto por que era lo mismo */

varAsignacion ::= IDENTIFICADOR ASIGNACION expresion DELIMITADOR;
                 
varCyAsignacion ::= LET tipoDatoVariable IDENTIFICADOR ASIGNACION expresion DELIMITADOR;

varGlobal ::= GLOBAL tipoDatoVariable IDENTIFICADOR DELIMITADOR
            | GLOBAL tipoDatoVariable IDENTIFICADOR ASIGNACION expresion DELIMITADOR;

/* ##### Seccion para las expresiones ######*/
expresion ::= expresionAritmetica
            | expresionLogica
            | expresionChar
            | expresionString;


/* Modificar las derivacion para expresion logica con el fin de que pueda volver a arriba:  expresionLogica AND expresionLogica| expresionLogica OR expresionLogica*/
expresionLogica ::= expresionRelacional AND expresionLogica
                  | expresionRelacional OR expresionLogica
                  | NOT expresionLogica                  
                  | expresionRelacional
                  | expresionBooleana; 
                  

/* Los de expresionAritmetica no se pueden cambiar ya que los operadores de mayores y menore solo funcionan con estos. Asi */
expresionRelacional ::= expresionAritmetica IGUAL expresionAritmetica
                      | expresionAritmetica DIFERENTE expresionAritmetica
                      | expresionAritmetica MENOR expresionAritmetica
                      | expresionAritmetica MAYOR expresionAritmetica
                      | expresionAritmetica MENOR_IGUAL expresionAritmetica
                      | expresionAritmetica MAYOR_IGUAL expresionAritmetica

                      | expresionBooleana IGUAL expresionBooleana
                      | expresionBooleana DIFERENTE expresionBooleana
                      | expresionChar IGUAL expresionChar
                      | expresionChar DIFERENTE expresionChar

                      | PAREN_I expresion PAREN_D; /* Con esta en teoria deberia de volver a arriba. */

expresionSimplificada ::= obtenerElementoLista
                          | funcionLlamada
                          | IDENTIFICADOR;
       

expresionChar ::= CHAR_LITERAL
                | obtenerElementoLista
                | funcionLlamada;

expresionString ::= STRING_LITERAL
                  | IDENTIFICADOR;

expresionBooleana ::= TRUE
                    | FALSE
                    | IDENTIFICADOR;


/* >> Expresiones aritmeticas */

expresionAritmetica ::= expresionSuma;


expresionSuma ::= expresionSuma MAS expresionProducto
                | expresionSuma MENOS expresionProducto
                | expresionProducto;

expresionProducto ::= expresionProducto MULTIPLICACION expresionPotencia
                    | expresionProducto DIVISION expresionPotencia
                    | expresionProducto DIVISION_ENTERA expresionPotencia
                    | expresionProducto MODULO expresionPotencia
                    | expresionPotencia;
          
expresionPotencia ::= expresionFactor POTENCIA expresionPotencia
                    | expresionFactor;


expresionFactor ::= PAREN_I expresionAritmetica PAREN_D
                  | expresionNumerica
                  | expresionAritmeticaUnaria
                  | expresionAritmeticaUnariaNegativa;

expresionNumerica ::= INT_LITERAL
                    | FLOAT_LITERAL
                    | IDENTIFICADOR
                    | funcionLlamada /* Esta psoiblemente se tenga que separar en los dos tipos de llamada */
                    | obtenerElementoLista
                    | input;

expresionAritmeticaUnaria ::= IDENTIFICADOR INCREMENTO
                            | IDENTIFICADOR DECREMENTO;

expresionAritmeticaUnariaNegativa ::= MENOS expresionNumerica;


/* ##### Seccion parael manejo de listas ######*/
lista ::= declaracionLista
        | creacionYAsignacionLista;

declaracionLista ::= LET tipoLista IDENTIFICADOR DELIMITADOR;

creacionYAsignacionLista ::= LET tipoLista IDENTIFICADOR ASIGNACION LLAVE_I elementos LLAVE_D DELIMITADOR;

elementos ::= elementoLista
            | elementos COMA elementoLista;

elementoLista ::= INT_LITERAL
                | CHAR_LITERAL;

modificarElementoLista ::= IDENTIFICADOR CORCHETE_I expresionAritmetica CORCHETE_D ASIGNACION elementoLista DELIMITADOR;

obtenerElementoLista ::= IDENTIFICADOR CORCHETE_I expresionAritmetica CORCHETE_D;

tipoLista ::= INT CORCHETE_I CORCHETE_D
            | CHAR CORCHETE_I CORCHETE_D
            | INT CORCHETE_I INT_LITERAL CORCHETE_D
            | CHAR CORCHETE_I INT_LITERAL CORCHETE_D;

